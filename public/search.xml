<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>ES6语法总结(一)</title>
    <url>/2019/10/11/ES6%E6%80%BB%E7%BB%93%E4%B8%80(%E5%8F%98%E9%87%8F%E4%B8%8E%E5%87%BD%E6%95%B0)/</url>
    <content><![CDATA[<h1 id="ES6语法总结"><a href="#ES6语法总结" class="headerlink" title="ES6语法总结"></a>ES6语法总结</h1><h2 id="块级绑定（let-，var，const）"><a href="#块级绑定（let-，var，const）" class="headerlink" title="块级绑定（let ，var，const）"></a>块级绑定（<em>let ，var，const</em>）</h2><h3 id="传统var的问题（变量提升，块级作用域）"><a href="#传统var的问题（变量提升，块级作用域）" class="headerlink" title="传统var的问题（变量提升，块级作用域）"></a>传统var的问题（<em>变量提升，块级作用域</em>）</h3><p>var是用来声明各类型变量的关键字，但存在一个问题–<strong>变量提升</strong>（<em>在当前作用域内使用var关键词声明的变量都会提升到当前作用域的顶部</em>）例:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getValue</span>(<span class="params">condition</span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (condition) &#123;</span><br><span class="line"><span class="keyword">var</span> value = <span class="string">"blue"</span>;</span><br><span class="line"><span class="comment">// 其他代码</span></span><br><span class="line"><span class="keyword">return</span> value;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// value 在此处可访问，值为 undefined</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// value 在此处可访问，值为 undefined</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<a id="more"></a>
<p>在这里可以很明显的知道value虽然定义在了if为真后的语句块中但事实上在整个函数内部都能访问的到，这段代码实际上相当于</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getValue</span>(<span class="params">condition</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> value;</span><br><span class="line"><span class="keyword">if</span> (condition) &#123;</span><br><span class="line">value = <span class="string">"blue"</span></span><br></pre></td></tr></table></figure>

<p>这就可能会产生一些意想不到的问题了，因此ES6中增加了一个<strong>块级作用域</strong>的概念（<em>就是让所声明的变量在指定块的作用域外无法被访问。块级作用域（词法作用域）在如下情况被创建：</em></p>
<ol>
<li><em>在一个函数内部</em></li>
<li><em>在一个代码块（由一对花括号{}包裹）内部）</em> </li>
</ol>
<h3 id="let与const"><a href="#let与const" class="headerlink" title="let与const"></a>let与const</h3><h4 id="共同特性："><a href="#共同特性：" class="headerlink" title="共同特性："></a>共同特性：</h4><ul>
<li><p>块级声明：两者均为块级声明即仅在当前定义语句行开始生效，以let为例：</p>
</li>
<li><pre><code class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">getValue</span>(<span class="params">condition</span>) </span>{
<span class="keyword">if</span> (condition) {
<span class="comment">//console.log(value)报错</span>

 <span class="keyword">let</span> value = <span class="string">"blue"</span>;

<span class="comment">//console.log(value) blue</span>
eturn value;
} <span class="keyword">else</span> {

<span class="keyword">return</span> <span class="literal">null</span>;
}

}
&lt;!--￼<span class="number">2</span>--&gt;

在这个函数中我们用||运算符给timeout，timeout都赋予了默认值，但是当timeout为<span class="number">0</span>时由于<span class="number">0</span>的布尔值为<span class="literal">false</span>所以会被设为<span class="number">2000</span>但有时候其实是需要赋值为<span class="number">0</span>的，所以在我们为函数赋默认值时有时候会有出现传<span class="number">0</span>或‘’参数被覆盖的情况，解决这种情况可以用<span class="keyword">typeof</span>===‘<span class="literal">undefined</span>’解决但是增加了很多代码量，所以es6中对这种情况进行了改进</code></pre>
</li>
<li><p>ES6中参数对象–(<strong>具名对象</strong>)</p>
<ul>
<li><strong>语法</strong>:<code>function makeRequest(url, timeout = 2000, callback = function() {}) }</code>ES6中一般在参数列表声明时赋与默认值，在这种情况下只有两种函数才会有默认值</li>
</ul>
</li>
</ul>
<ol>
<li><p>​        未传入第二三个对象</p>
</li>
<li><p>传入undfined(这里的null是一个数据类型，因此传入null不会赋予默认值)</p>
<ul>
<li><p><strong>消除对arguments对象的影响</strong>：在ES5中在函数对与参数的任意操作都会影响到arguments对象里面的值，只有在ES5严格模式下才会消除影响而只要被启用了ES6规则都可以消除影响</p>
</li>
<li><p><strong>传递默认表达式</strong>：在设置具名参数默认值的时候不仅可以使用基本参数类型还可以使用表达式，即</p>
</li>
<li><pre><code class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">getValue</span>(<span class="params"></span>) </span>{
<span class="keyword">return</span> <span class="number">5</span>;
}
<span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">first=<span class="number">1</span>, second = getValue(</span>)) </span>{
<span class="keyword">return</span> first + second;
}
<span class="built_in">console</span>.log(add(<span class="number">1</span>, <span class="number">1</span>)); <span class="comment">// 2</span>
<span class="built_in">console</span>.log(add(<span class="number">1</span>)); <span class="comment">// 6</span>
<span class="built_in">console</span>.log(add(<span class="number">1</span>)); <span class="comment">// 7</span>
&lt;!--￼<span class="number">3</span>--&gt;

 keys就是一个剩余参数对象，他会包含object之后的所有参数对象

- 使用的时候要注意两个点<span class="number">1.</span>不能再剩余参数之后再声明参数，<span class="number">2.</span>不能再settr字面量属性中使用</code></pre>
</li>
</ul>
</li>
</ol>
<ul>
<li><p>拓展运算符(…)</p>
</li>
<li><p>拓展运算符会便利参数对象所有可枚举的属性，拷贝到当前对象中，对象，数组。字符串等均可使用</p>
</li>
<li><p>箭头函数(=&gt;)</p>
<ul>
<li>语法：<code>（）=&gt;{函数体}</code>,当只有一个参数或者之有一条执行语句时可以省略括号，当有多个参数，无参数，函数体有多条语句时必须用<code>（）=&gt;{}</code>的格式</li>
<li>特点：<ul>
<li><strong>没有this绑定</strong>:箭头函数体内部的this与调用它的父级指向一致</li>
<li><strong>没有arguments绑定</strong>：函数体内无法使用arguments访问它本身的参数对象，但是可以访问父级的arguments对象</li>
<li><strong>具名参数和不具名参数</strong>:在箭头函数中都能正常使用</li>
</ul>
</li>
</ul>
</li>
<li><p>尾调用优化：</p>
<ul>
<li><p>语法：在函数的最后一句调用某函数的第一句(也可以是自己)例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Something</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> SomethingElse(); <span class="comment">// 尾调用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>作用：会清除当前函数的栈帧并重复使用以此提高性能在ES6严格模式中有以下情况会启用尾调用：</p>
<ol>
<li>尾调用不能引用当前栈帧中的变量（意味着该函数不能是闭包）；</li>
<li>进行尾调用的函数在尾调用返回结果后不能做额外操作；</li>
<li>尾调用的结果作为当前函数的返回值。</li>
</ol>
</li>
<li><p>应用：一般是应用在递归函数，或者有复杂计算过程的函数时效果明显，</p>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6语法总结(二)</title>
    <url>/2019/11/21/ES6%E6%80%BB%E7%BB%93%E4%BA%8C(%E5%AF%B9%E8%B1%A1%E5%92%8C%E6%95%B0%E7%BB%84)/</url>
    <content><![CDATA[<h1 id="ES6语法总结"><a href="#ES6语法总结" class="headerlink" title="ES6语法总结"></a>ES6语法总结</h1><h2 id="对象-Object"><a href="#对象-Object" class="headerlink" title="对象(Object)"></a>对象(Object)</h2><ul>
<li><p><strong>属性初始化器速记</strong>：在ES6中当对象字面量中的属性只有名称时， JS 引擎会在周边作用域查找同名变量。若找到，该变量的值将会被赋给对象字面量的同名属性。所以当属性和值相同时可以只写一个名称例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        name,</span><br><span class="line">        age</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a></li>
<li><p><strong>方法简写</strong>:在ES6为字面量定义函数时必须指定一个名称并用完整的函数定义来为对象添加方法，在ES6中也将其做了优化</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">name: <span class="string">"zhoushaung"</span>,</span><br><span class="line">sayName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="comment">//es5 </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">sayName()&#123;<span class="comment">//es6 </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>可计算的属性名</strong>:对象实例能使用“需计算的属性名”，只要用方括号表示法来代替小数点表示法即可,在ES6中的计算属性名是对象字面量语法的一部分所以可以直接用变量或字符串字作为属性名，同时在[]也可以使用表达式</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> suffix = <span class="string">" man"</span>;</span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">[suffix+<span class="string">"name"</span>]: <span class="string">"zhoushuang"</span>,</span><br><span class="line">[suffix+<span class="string">"gender"</span>]: <span class="string">"male"</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(person[<span class="string">"man name"</span>]); <span class="comment">// "zhoushuang"</span></span><br><span class="line"><span class="built_in">console</span>.log(person[<span class="string">"mane gender"</span>]); <span class="comment">//male</span></span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p><strong>新增方法(Object.is(),Object.assign())</strong>：</p>
<ul>
<li><p>Object.is:用来弥补相等运算符的不足(<code>==</code>和<code>===</code>)，在一般相等运算符无法判定值相同类型不同的情况，在严格相等运算符中无法判定为 +0 与 -0 相等， NaN === NaN 等情况，而Object.is会判定两个数据的类型和值是否相等例</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(+<span class="number">0</span> == <span class="number">-0</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(+<span class="number">0</span> === <span class="number">-0</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.is(+<span class="number">0</span>, <span class="number">-0</span>)); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">NaN</span> == <span class="literal">NaN</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">NaN</span> === <span class="literal">NaN</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.is(<span class="literal">NaN</span>, <span class="literal">NaN</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span> == <span class="number">1</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span> == <span class="string">"1"</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span> === <span class="number">1</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span> === <span class="string">"1"</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.is(<span class="number">5</span>, <span class="number">5</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.is(<span class="number">5</span>, <span class="string">"5"</span>)); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>



</li>
</ul>
</li>
</ul>
<ul>
<li><p>Object.assign:用来对两个对象进行混入操作，该方法接受任意数量的参数并且会按照参数列表中的顺序来依次接收它们的属性，也就是说当有同名属性时可能会出现后来的参数覆盖前面的情况</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj1 = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.assign(obj1,</span><br><span class="line">&#123;</span><br><span class="line">type: <span class="string">"shuaib"</span>,</span><br><span class="line">name: <span class="string">"zhoushuang"</span></span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">type: <span class="string">"handsome"</span></span><br><span class="line">&#125;</span><br><span class="line">);</span><br><span class="line"><span class="built_in">console</span>.log(obj1.type); <span class="comment">// "handsome"</span></span><br><span class="line"><span class="built_in">console</span>.log(obj1.name); <span class="comment">// "zhoushuang"</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<ul>
<li><p><strong>重复的对象字面量属性</strong>:当同一对象存在重复属性时，排在后面的属性的值会成为该属性的实际值而不会报错</p>
</li>
<li><p><strong>可枚举属性的顺序(Object.getOwnPropertyNames())</strong>：该方法会根据以下规则返回对象的属性：</p>
<ol>
<li>所有的数字类型键，按升序排列。</li>
<li>所有的字符串类型键，按被添加到对象的顺序排列。</li>
<li>所有的符号类型（详见第六章）键，也按添加顺序排列。</li>
</ol>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">a</span>: <span class="number">1</span>,<span class="number">0</span>: <span class="number">1</span>,<span class="attr">c</span>: <span class="number">1</span>,<span class="number">2</span>: <span class="number">1</span>,<span class="attr">b</span>: <span class="number">1</span>,<span class="number">1</span>: <span class="number">1</span>&#125;;</span><br><span class="line">obj.d = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyNames(obj).join(<span class="string">""</span>)); <span class="comment">// "012acbd"</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>原型</strong>：</p>
<ul>
<li><p>新增和修改原型：Object.setPrototypeOf()允许你修改任意指定对象的原型。它接受两个参数：需要被修改原型的对象，以及将会成为前者原型的对象, Object.getPrototypeOf() 方法从任意指定对象中获取其原型.</p>
</li>
<li><p>super调用原型的函数:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">getGreeting() &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"Hello"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> dog = &#123;</span><br><span class="line">getGreeting() &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"Woof"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> friend = &#123;</span><br><span class="line">getGreeting() &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">super</span>.getGreeting() + <span class="string">", hi!"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 将原型设置为 person</span></span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(friend, person);</span><br><span class="line"><span class="built_in">console</span>.log(friend.getGreeting()); <span class="comment">// "Hello, hi!"</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(friend) === person); <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 将原型设置为 dog</span></span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(friend, dog);</span><br><span class="line"><span class="built_in">console</span>.log(friend.getGreeting()); <span class="comment">// "Woof, hi!"</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(friend) === dog); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>有点类似于java对父类方法的重写,在有多重继承的情况下会比较好使一点</p>
</li>
</ul>
</li>
</ul>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><ul>
<li><p><strong>创建数组方法</strong>：</p>
<ul>
<li><p>Array.of():) 方法总会创建一个包含所有传入参数的数组，而不管参数的数量与类型</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> items = <span class="built_in">Array</span>.of(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(items.length); <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(items[<span class="number">0</span>]); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(items[<span class="number">1</span>]); <span class="comment">// 2</span></span><br><span class="line">items = <span class="built_in">Array</span>.of(<span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(items.length); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(items[<span class="number">0</span>]); <span class="comment">// 2</span></span><br><span class="line">items = <span class="built_in">Array</span>.of(<span class="string">"2"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(items.length); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(items[<span class="number">0</span>]);</span><br></pre></td></tr></table></figure>



</li>
</ul>
</li>
</ul>
<ul>
<li><p>Array.from():多用于类数组对象转化成为数组或者转化前进行额外操作时使用，接收三个参数</p>
<ol>
<li>参数对象(arguments)：传入要进行转化的初始对象</li>
<li>操作方法(function)：如需额外加工，传入加工具体步骤</li>
<li>映射(object):如果function已经被定义或者需要进入额外对象方法，在此传入方法所在对象，此时的this就会指向被传入的对象</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> helper = &#123;</span><br><span class="line">diff: <span class="number">1</span>,</span><br><span class="line">add(value) &#123;</span><br><span class="line"><span class="keyword">return</span> value + <span class="keyword">this</span>.diff;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">translate</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Array</span>.from(<span class="built_in">arguments</span>, helper.add, helper);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> numbers = translate(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"><span class="built_in">console</span>.log(numbers); <span class="comment">// 2,3,4</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<ul>
<li><p><strong>其他方法</strong>:</p>
<ul>
<li><p><strong>find()和findIndex()</strong>:这两俩函数非常像所以把他们放在一起讨论，</p>
<ul>
<li>相同点：<ol>
<li>都是在数组中查找符合要求的值</li>
<li>均接受两个参数：一个回调函数和一个可选值用于指定回调函数内部的 this 。该回调函数可接收三个参数：数组的某个元素、该元素对应的索引位置、以及该数组自身</li>
<li>均会在回调函数第一次返回 true 时停止查找</li>
</ol>
</li>
<li>区别<ol>
<li>find() 方法返回匹配的值</li>
<li>findIndex() 方法则会返回匹配位置的索引</li>
</ol>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> numbers = [<span class="number">25</span>, <span class="number">30</span>, <span class="number">35</span>, <span class="number">40</span>, <span class="number">45</span>];</span><br><span class="line"><span class="built_in">console</span>.log(numbers.find(<span class="function"><span class="params">n</span> =&gt;</span> n &gt; <span class="number">33</span>)); <span class="comment">// 35</span></span><br><span class="line"><span class="built_in">console</span>.log(numbers.findIndex(<span class="function"><span class="params">n</span> =&gt;</span> n &gt; <span class="number">33</span>));</span><br></pre></td></tr></table></figure>
</li>
<li><p>*<em>fill() *</em>:</p>
<ul>
<li>作用:用于填充数组中的一个或者多个参数</li>
<li>语法:fill(number,firstIndex,lastIndex)：<ol>
<li>number：进行替换操作的数据，</li>
<li>firstIndex，lastIndex:进行替换操作的初始位置和结束位置</li>
</ol>
</li>
<li>注:后两个参数是该数组的下标,当其为负是值为Array.length+firstIndex/lastIndex</li>
</ul>
</li>
<li><p><strong>copyWithin()</strong>:</p>
<ul>
<li>作用：和fill一样用于填充替换数组,但这个方法可以在数组内部复制自身元素</li>
<li>语法:copyWithin(target,start,end):<ol>
<li>start:粘贴的起始位置</li>
<li>target:从第几个位置作为粘贴项</li>
<li>end:被覆盖元素的个数</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="comment">// 从索引 2 的位置开始粘贴</span></span><br><span class="line"><span class="comment">// 从数组索引 0 的位置开始复制数据</span></span><br><span class="line"><span class="comment">// 在遇到索引 1 时停止复制</span></span><br><span class="line">numbers.copyWithin(<span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(numbers.toString()); <span class="comment">// 1,2,1,4</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2019/10/05/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>Hello Ships</title>
    <url>/2019/10/06/HelloShips/</url>
    <content><![CDATA[<h1 id="Hello-Ships"><a href="#Hello-Ships" class="headerlink" title="Hello Ships"></a>Hello Ships</h1><p>折腾了两天，终于把这个博客搭起来了，感谢过程中给我帮助的文字和人儿们</p>
<p>第一次输入完localhost:4000看到生成的页面，突然有种很复杂的恍惚，就像是在海上常年冲浪的人找到了一个小岛，然后得到了一个海螺</p>
<p>至此,</p>
<p>这个海边独居的人可以把自己的思绪写成旋律</p>
<p>吹进海螺里  </p>
<p>偶尔有路过的航船听到</p>
<p>鸣笛致意</p>
<p>大家相视一笑</p>
<p>挥挥手 </p>
<p>然后各自离开</p>
<p>奔赴下一场相遇</p>
<p>我很喜欢这种感觉</p>
<p>Hello Ships~</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
        <tag>Hello Ships</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6语法总结(三)</title>
    <url>/2020/01/05/ES6%E8%AF%AD%E6%B3%95%E6%80%BB%E7%BB%93%E4%B8%89(%E8%A7%A3%E6%9E%84%E3%80%81Set%E5%92%8CMap)/</url>
    <content><![CDATA[<h1 id="ES6语法总结"><a href="#ES6语法总结" class="headerlink" title="ES6语法总结"></a>ES6语法总结</h1><h2 id="解构"><a href="#解构" class="headerlink" title="解构"></a>解构</h2><h3 id="作用"><a href="#作用" class="headerlink" title="作用:"></a>作用:</h3><p>从对象或数组中获取信息、并将特定数据存入本地变量</p>
<h3 id="对象解构："><a href="#对象解构：" class="headerlink" title="对象解构："></a>对象解构：</h3><ul>
<li><p><strong>简单的解构</strong>:先从一段代码说起</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> man = &#123;</span><br><span class="line">age: <span class="string">"23"</span>,</span><br><span class="line">name: <span class="string">"zhoushuang"</span></span><br><span class="line">&#125;,</span><br><span class="line">age: <span class="string">"24"</span>,</span><br><span class="line">name = <span class="string">"zs"</span>;</span><br><span class="line"><span class="comment">// 使用解构来分配不同的值</span></span><br><span class="line">(&#123; age, name &#125; = man);<span class="comment">//解构表达式</span></span><br><span class="line"><span class="built_in">console</span>.log(age); <span class="comment">// "23"</span></span><br><span class="line"><span class="built_in">console</span>.log(name); <span class="comment">// "zhoushuang"</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>在这个例子中 age与 name 属性在声明时被初始化，而两个同名变量也被声明并初始化为不同的值。接下来一行使用了解构表达式，通过读取 man对象来更改这两个变量的值。在这里必须用<strong>圆括号包裹解构赋值语句</strong>，这是因为暴露的花括号会被解析为代码块语句，而块语句不允许在赋值操作符左侧出现。圆括号标示了里面的花括号并不是块语句、而应该被解释为表达式，从而允许完成赋值操作。                </p>
</li>
<li><p><strong>设置默认值</strong>:同上代码中的赋值语句改成</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(&#123; age, name,<span class="attr">type</span>:<span class="string">'handsome'</span> &#125; = man);<span class="comment">//解构表达式+默认值</span></span><br></pre></td></tr></table></figure>

<p>在赋值的时候由于man对象中并没有名为type的属性所以会使用默认值同时要注意的是凡是在解构赋值在声明构造器中查找不到同名属性时都会变成undefined</p>
</li>
<li><p><strong>赋值给本地变量名</strong>：依旧是第一段代码的赋值语句改成</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; <span class="attr">age</span>: manage, <span class="attr">name</span>: manname=<span class="string">'zs'</span> &#125; = man;<span class="comment">//解构表达式+默认值+赋值给本地变量</span></span><br></pre></td></tr></table></figure>

<p>这样的话man里面的age和name属性分别对自定义的manage,manname进行了赋值操作， 该语法实际上与传统对象字面量语法相反，传统语法将名称放在冒号左边、值放在冒号右边；而在本例中，<strong>名称在右边，需要进行值读取的位置被放在了左边。</strong></p>
</li>
<li><p><strong>解构嵌套对象</strong>:</p>
<ul>
<li><strong>简单用法</strong>：在日常开发中有时候会出现我们拿到的数据是一个多层嵌套的对象，而我们只需要获取其中的某些项的情况，这时自己写方法去遍历对象会比较麻烦，这个时候使用解构赋值会节省很多时间:</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> man = &#123;</span><br><span class="line">name: <span class="string">"zhoushuang"</span>,</span><br><span class="line">type: &#123;</span><br><span class="line">habit: &#123;</span><br><span class="line">sleep: <span class="literal">true</span>,</span><br><span class="line">eating: <span class="literal">true</span></span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">type</span>: &#123; habit &#125;&#125; = man;<span class="comment">//嵌套解构赋值</span></span><br><span class="line"><span class="built_in">console</span>.log(habit.sleep); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(habit.eating); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>在赋值结构中每当有一个冒号出现，就意味着冒号之前的标识符代表需要检查的位置，而冒号右侧则是赋值的目标。当冒号右侧存在花括号时，表示目标被嵌套在对象的更深一层中，因此<code>{ type: { habit }} = man</code>的运行顺序应该是:man-&gt;寻找type属性-&gt; type属性需找habit属性-&gt;进行操作，每一个{}都可以简单的理解成又进行了一次简单解构赋值而这次的数据源就来自于冒号左边</p>
<ul>
<li><p>赋值给本地变量名**:同上一行代码中的赋值语句改成</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; <span class="attr">type</span>: &#123; <span class="attr">habit</span>:manHabit &#125;&#125; = man;<span class="comment">//嵌套解构赋值+赋值给本地变量</span></span><br></pre></td></tr></table></figure>

<p>其实和简单赋值的形式一样把habit整个对象都赋值给了本地变量manHabit不赘述</p>
</li>
</ul>
</li>
</ul>
<h3 id="数组解构"><a href="#数组解构" class="headerlink" title="数组解构"></a>数组解构</h3><p>总体来说数组解构赋值和对象解构赋值非常的相似，因此在此也只介绍数组解构的不同之处,其他情况参考上文。</p>
<ul>
<li><p><strong>简单解构赋值</strong>:与对象相比语法不同’{}‘-&gt;’[]‘，并且在运行的时候不是查找同名属性而是直接按照参数的顺序进行赋值</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [ <span class="string">"red"</span>, <span class="string">"green"</span>, <span class="string">"blue"</span> ];</span><br><span class="line"><span class="keyword">let</span> [ first, second ] = colors;</span><br><span class="line"><span class="built_in">console</span>.log(first); <span class="comment">// "red"</span></span><br><span class="line"><span class="built_in">console</span>.log(second); <span class="comment">// "green"</span></span><br></pre></td></tr></table></figure>

<p>在以上代码中能看到first和second分别获取了colors数组中的第一和第二个而这是根据参数各自的位置决定的，所以我们也可以使用占位符<code>，</code>来给获取指定的数据</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [,second ] = colors;</span><br><span class="line"><span class="built_in">console</span>.log(second); <span class="comment">// "green"</span></span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>默认值:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">let [ first, second= <span class="string">"pink"</span> ] = colors;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数交换:在ES6中可以运用解构赋值进行参数交换而无需中间变量</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span>,</span><br><span class="line">b = <span class="number">2</span>;</span><br><span class="line">[ a, b ] = [ b, a ];</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>嵌套解构:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [ <span class="string">"red"</span>, [ <span class="string">"green"</span>, <span class="string">"lightgreen"</span> ], <span class="string">"blue"</span> ];</span><br><span class="line"><span class="comment">// 随后</span></span><br><span class="line"><span class="keyword">let</span> [ firstColor, [ secondColor ] ] = colors;</span><br><span class="line"><span class="built_in">console</span>.log(firstColor); <span class="comment">// "red"</span></span><br><span class="line"><span class="built_in">console</span>.log(secondColor); <span class="comment">// "green"</span></span><br></pre></td></tr></table></figure>

<p>和对象嵌套时的原理一样,只不过在数组中不是根据属性名来查找而是根据参数的位置查找的,所以<code>[ firstColor, [ secondColor ] ] = colors;</code>也相当于进行了两次解构赋值操作,第一次<code>firstColor=red；[ secondColor ]= [ &quot;green&quot;, &quot;lightgreen&quot; ]</code> ，第二次<code>secondColor =green</code></p>
</li>
</ul>
<p>需要注意的是在数组解构的时候如果有嵌套解构的情况但是对应的数据源只要不是可转成数组的值都会报错，如果可以转成数组会先将其转化成数组在进行赋值:</p>
<p><img src="C:%5CUsers%5CAdministrator%5CDesktop%5Cbolg%5CES6%5Cimage%5C%E6%95%B0%E7%BB%84%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC.png" alt=""></p>
<ul>
<li><p>剩余项赋值:因为数组中有arguments对象所以在数组解构中也可以使用</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [ <span class="string">"red"</span>, <span class="string">"green"</span>, <span class="string">"blue"</span> ];</span><br><span class="line"><span class="keyword">let</span> [ firstColor, ...restColors ] = colors;</span><br><span class="line"><span class="built_in">console</span>.log(firstColor); <span class="comment">// "red"</span></span><br><span class="line"><span class="built_in">console</span>.log(restColors.length); <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(restColors[<span class="number">0</span>]); <span class="comment">// "green"</span></span><br><span class="line"><span class="built_in">console</span>.log(restColors[<span class="number">1</span>]); <span class="comment">// "blue"</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="混合解构-对象-数组"><a href="#混合解构-对象-数组" class="headerlink" title="混合解构(对象+数组)"></a>混合解构(对象+数组)</h2><p>这里其实就是把数组解构和对象解构的语法组合起来，只要注意逻辑和语法就行了，混合结构对于JSON格式的数据获取很有帮助</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> node = &#123;</span><br><span class="line">type: <span class="string">"Identifier"</span>,</span><br><span class="line">name: <span class="string">"foo"</span>,</span><br><span class="line">loc: &#123;</span><br><span class="line">start: &#123;</span><br><span class="line">line: <span class="number">1</span>,</span><br><span class="line">column: <span class="number">1</span></span><br><span class="line">&#125;,</span><br><span class="line">end: &#123;</span><br><span class="line">line: <span class="number">1</span>,</span><br><span class="line">column: <span class="number">4</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line">range: [<span class="number">0</span>, <span class="number">3</span>]</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> &#123;</span><br><span class="line">loc: &#123; start &#125;,</span><br><span class="line">range: [ startIndex ]</span><br><span class="line">&#125; = node;</span><br><span class="line"><span class="built_in">console</span>.log(start.line); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(start.column); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(startIndex); <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>

<h2 id="Set和Map"><a href="#Set和Map" class="headerlink" title="Set和Map"></a>Set和Map</h2><h3 id="Set-无重复值的有序列表"><a href="#Set-无重复值的有序列表" class="headerlink" title="Set(无重复值的有序列表)"></a>Set(无重复值的有序列表)</h3><ul>
<li><p><strong>创建set并添加内容</strong>：</p>
<p>使用new来创建，add方法添加项目</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">set</span> = new Set();</span><br><span class="line"><span class="keyword">set</span>.add(5);</span><br><span class="line"><span class="keyword">set</span>.add("5");</span><br><span class="line">console.log(<span class="keyword">set</span>.size); // 2</span><br></pre></td></tr></table></figure>

<p>Set 不会使用强制类型转换来判断值是否重复。这意味着 Set 可以同时包含数值 5 与 字符串 “5” ，将它们都作为相对独立的项,因为这里使用的是Object.is() 方法，来判断两个值是否相等，唯一的例外是 +0 与 -0 在 Set 中被判断为是相等的）。你还可以向 Set 添加多个对象，它们也不会被合并为同一项</p>
</li>
<li><p><strong>Set.has()</strong>：用来搜索目标set中是否存在某一项，并返回结果(true/false)</p>
</li>
<li><p><strong>Set.delete()</strong>:用来删除目标set中的某一项，并返回结果(true/false)</p>
</li>
<li><p><strong>Set.clear()</strong>:用来删除目标set中的某一项，无返回</p>
</li>
<li><p><strong>Set 转换为数组</strong>：将数组转换为 Set 相当容易，因为可以将数组传递给 Set 构造器；而使用扩展运算符也能简<br>单地将 Set 转换回数组</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">set</span> = new Set([1, 2, 3, 3, 3, 4, 5]),</span><br><span class="line">array = [...<span class="keyword">set</span>];</span><br><span class="line">console.log(array); // [1,2,3,4,5]</span><br></pre></td></tr></table></figure>
</li>
<li><p>Weak Set：</p>
<p>在以上转化数组的时候仔细观察就能发现，使用set转换数组时只是将set中的内容复制给了一个array而已，原set的内容中依旧还存在，对象存储在 Set 的一个实例中时，实际上相当于把对象存储在变量中。只要对于 Set 实例的引用仍然存在，所存储的对象就无法被垃圾回收机制回收，从而无法释放内存，所以为了解决这个问题也就引入了Weak Set</p>
<ul>
<li><p>创建 Weak Set:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">set</span> = new WeakSet(),</span><br><span class="line">key = &#123;&#125;;</span><br><span class="line"><span class="comment">// 将对象加入 set</span></span><br><span class="line"><span class="keyword">set</span>.add(key);</span><br><span class="line">console.log(<span class="keyword">set</span>.has(key)); // true</span><br><span class="line"><span class="keyword">set</span>.delete(key);</span><br><span class="line">console.log(<span class="keyword">set</span>.has(key)); // false</span><br></pre></td></tr></table></figure>

<p>Weak Set 使用 WeakSet 构造器来创建，同时也包含了 add() 、 has()和 delete(),没有clear，该类型只允许存储对象弱引用，而不能存储基本类型的值。对象的弱引用在它自己成为该对象的唯一引用时，不会阻止垃圾回收，</p>
</li>
<li><p>Set 类型之间的关键差异：</p>
<ul>
<li>对于 WeakSet 的实例，若调用 add() 方法时传入了非对象的参数，就会抛出错误（has() 或 delete() 则会在传入了非对象的参数时返回 false ）；</li>
</ul>
<ol start="2">
<li>Weak Set 不可迭代，因此不能被用在 for-of 循环中；</li>
</ol>
<ul>
<li>Weak Set 无法暴露出任何迭代器（例如 keys() 与 values() 方法），因此没有任何编程手段可用于判断 Weak Set 的内容；</li>
</ul>
<ol start="4">
<li>Weak Set 没有 forEach() 方法；</li>
<li>Weak Set 没有 size 属性。</li>
</ol>
</li>
</ul>
</li>
</ul>
<h3 id="Map-键值对有序列表"><a href="#Map-键值对有序列表" class="headerlink" title="Map(键值对有序列表)"></a>Map(键值对有序列表)</h3><p>Map中的数据以键值对的形式存在,而键和值都可以是任意类型。键的比较使用的是Object.is() ，因此你能将 5 与 “5” 同时作为键，因为它们类型不同。这与使用对象属性作为键的方式（指的是用对象来模拟 Map ）截然不同，因为对象的属性会被强制转换为字符串。</p>
<ul>
<li><p><strong>Map方法</strong>：</p>
<ul>
<li>get(),set():调用 set() 方法并给它传递一个键与一个关联的值，来给 Map 添加项；此后使用键<br>名来调用 get() 方法便能提取对应的值</li>
<li>has(key) ：判断指定的键是否存在于 Map 中；</li>
<li>delete(key) ：移除 Map 中的键以及对应的值；</li>
<li>clear() ：移除 Map 中所有的键与值。</li>
</ul>
</li>
<li><p><strong>Weak Map</strong>:</p>
<p>WeakMap 类型是键值对的无序列表，其中键必须是非空的对象，值则允许是任意类型。 WeakMap 的接口与 Map 的非常相似，都使用 set() 与 get() 方法来分别添加与提取数据</p>
<ul>
<li><strong>Weak Map 的初始化</strong><br>为了初始化 Weak Map ，需要把一个由数组构成的数组传递给 WeakMap 构造器。就像正规Map 构造器那样，每个内部数组都应当有两个项，第一项是作为键的非空的对象，第二项则是对应的值（任意类型）</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> key1 = &#123;&#125;,</span><br><span class="line">key2 = &#123;&#125;,</span><br><span class="line">map = <span class="keyword">new</span> <span class="built_in">WeakMap</span>([[key1, <span class="string">"Hello"</span>], [key2, <span class="number">42</span>]]);</span><br><span class="line"><span class="built_in">console</span>.log(map.has(key1)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(map.get(key1)); <span class="comment">// "Hello"</span></span><br><span class="line"><span class="built_in">console</span>.log(map.has(key2)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(map.get(key2)); <span class="comment">// 42</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>Weak Map 的方法</p>
<p>has() 方法用于判断指定的键是否存在 delete() 方法则用于移除一个特定的键值对。</p>
</li>
</ul>
</li>
<li><p>Weak Map 的用法与局限性</p>
<p>如果你只想使用对象类型的键。最好的选择就是 Weak Map 。因为它能确保额外数据在不再可用后被销毁，从而能优化内存使用并规避内存泄漏。但是 Weak Map 只为它们的内容提供了很小的可见度，因此不能使用 forEach() 方法、size 属性或 clear() 方法来管理其中的项。而在除此之外的其他情况，正常 Map是更好的选择，只是要注意对内存的使用。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6语法总结(四)</title>
    <url>/2020/01/20/ES6%E8%AF%AD%E6%B3%95%E6%80%BB%E7%BB%93%E5%9B%9B(%E8%BF%AD%E4%BB%A3%E7%94%9F%E6%88%90%E5%99%A8%E3%80%81Promise%E5%92%8C%E5%BC%82%E6%AD%A5)/</url>
    <content><![CDATA[<h1 id="ES6语法总结"><a href="#ES6语法总结" class="headerlink" title="ES6语法总结"></a>ES6语法总结</h1><h2 id="Promise与异步"><a href="#Promise与异步" class="headerlink" title="Promise与异步"></a>Promise与异步</h2><h3 id="Promise诞生的原因"><a href="#Promise诞生的原因" class="headerlink" title="Promise诞生的原因"></a>Promise诞生的原因</h3><p>前端和后端各种多样化交互才使各种程序拥有了使用的实际价值，而前后端交互绝大部分都属于异步编程，所以了解异步是对于前端来说是异常重要的一步，接下来先看一下传统的异步</p>
<ul>
<li><p><strong>传统的异步</strong>：</p>
<ul>
<li>事件模型</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> button = <span class="built_in">document</span>.getElementById(<span class="string">"btn"</span>);</span><br><span class="line">    button.onclick = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Clicked"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>在这段代码中就是事件模型的一种，给id为<code>btn</code>的dom元素绑定了一个点击方法，但是它只会被编译而不会被执行，只有当该元素被点击之后才会js引擎才会把click的方法加入到作业队列的末尾，而所有类似这种绑定特定事件只有在特定条件下才会执行的模式叫做事件模式，这也是异步的一种。</p>
<ul>
<li>问题：对于这种模式来说当需要简单的交互时简单好用但是又两个问题<ul>
<li>每一个事件模型都需要追踪事件对象，有一百个点击事件就要监控一百个对象很麻烦</li>
<li>未必能够完成绑定因为也可能绑定事件的时候dom还不存在</li>
</ul>
</li>
<li>回调模式</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">readFile(<span class="string">"example.txt"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, contents</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">   		 <span class="keyword">throw</span> err;</span><br><span class="line">   	 &#125;</span><br><span class="line">   		<span class="built_in">console</span>.log(contents);</span><br><span class="line">   &#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"Hi!"</span>);</span><br></pre></td></tr></table></figure>

<p><code>readFile()</code> 函数用于读取磁盘中的文件（由第一个参数指定），并在读取完毕后执行回调函数（即第二个参数）。如果存在错误，回调函数的 err 参数会是一个错误对象；否则 contents 参数就会以字符串形式包含文件内容。使用回调函数模式， <code>readFile()</code> 会立即开始执行，并在开始读取磁盘时暂停。这意味着<code>console.log(&quot;Hi!&quot;)</code>会在 <code>readFile()</code> 被调用后立即进行输出，要早于<code>console.log(contents)</code>的打印操作。当 <code>readFile()</code>结束操作后，它会将回调函数以及相关参数作为一个新的作业添加到作业队列的尾部。在之前的作业全部结束后，该作业才会执行,在这种情况下如果要进行异步串联就容易得多，但是会出现<strong>回调地狱</strong>的情况</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">method1(<span class="function"><span class="keyword">function</span>(<span class="params">err, result</span>) </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (err) &#123;</span><br><span class="line">         <span class="keyword">throw</span> err</span><br><span class="line">       	 &#125;</span><br><span class="line">       method2(<span class="function"><span class="keyword">function</span>(<span class="params">err, result</span>) </span>&#123;</span><br><span class="line">         <span class="keyword">if</span> (err) &#123;</span><br><span class="line">           <span class="keyword">throw</span> err</span><br><span class="line">         &#125;</span><br><span class="line">         method3(<span class="function"><span class="keyword">function</span>(<span class="params">err, result</span>) </span>&#123;</span><br><span class="line">           <span class="keyword">if</span> (err) &#123;</span><br><span class="line">             <span class="keyword">throw</span> err</span><br><span class="line">           &#125;</span><br><span class="line">           method4(<span class="function"><span class="keyword">function</span>(<span class="params">err, result</span>) </span>&#123;</span><br><span class="line">             <span class="keyword">if</span> (err) &#123;</span><br><span class="line">               <span class="keyword">throw</span> err</span><br><span class="line">             &#125;</span><br><span class="line">             method5(result)</span><br><span class="line">           &#125;)</span><br><span class="line">         &#125;)</span><br><span class="line">       &#125;)</span><br><span class="line">     &#125;)</span><br></pre></td></tr></table></figure>

<p>​    是不是看了就很想死…不但代码复杂高度耦合而且当你需要两个异步并行操作或者想同时开始两个异步的时候就    特别麻烦了，所以才有了Promise</p>
<ul>
<li><h3 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h3><h4 id="Promise-生命周期"><a href="#Promise-生命周期" class="headerlink" title="Promise 生命周期"></a>Promise 生命周期</h4><p><img src="ES6%5Cimage%5CPromise%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" alt="1585030576405"></p>
<p>在这里把几个意思都解释一下：</p>
<ol>
<li>程序整体状态：<ul>
<li>unsettled(未决):就是挂起状态，但是这个状态是用来描述程序的整体状况</li>
<li>settled(已决):程序已经执行完成</li>
<li>resolve(决议):推进为程序执行状态为已决</li>
</ul>
</li>
<li>程序具体状态:<ul>
<li>pending(挂起):异步程序尚未结束，等待结果中</li>
<li>fulfilled(完成):异步程序结束，操作完成</li>
<li>rejected(拒绝):异步程序结束，操作失败</li>
</ul>
</li>
<li>推进状态操作函数<ul>
<li>resolve():调用resolve()更改程序状态为已完成</li>
<li>reject():调用resolve()更改程序状态为已失败</li>
</ul>
</li>
<li>状态完成函数<ul>
<li>fulfillment handler:成功决议之后调用的函数</li>
<li>rejection handler :失败之后调用的函数</li>
</ul>
</li>
</ol>
<p>在以上描述中描述程序具体状态的值会被设置在Promise对象的<code>PromiseState</code>属性中但是这个属性没有暴露所以不能访问，因此才需要<code>.then()</code>方法来对Promise的不同情况进行想要的操作</p>
<p><strong>then()方法</strong>：</p>
<p>​    在Promise状态为settled的时候会被调用，接收两个可选参数（都是回调函数的形式）,第一个是成功的回调函数，第二个是失败的回调函数，在失败的时候会默认传递一个包含有错误信息的对象进去。</p>
<p><strong>catch()方法</strong>:</p>
<p>​     在这里的<code>promise.catch(function...)</code>&lt;=&gt;<code>promise.then(null,function..)</code>,默认传递rejection handler</p>
</li>
</ul>
<p>​            <strong>当没有写入都有的错误都会静默发生所以最好给promise都写一个默认的日志</strong></p>
<h4 id="创建Promise"><a href="#创建Promise" class="headerlink" title="创建Promise"></a>创建Promise</h4><h5 id="创建未决Promise"><a href="#创建未决Promise" class="headerlink" title="创建未决Promise"></a>创建未决Promise</h5><p>​    使用 Promise 构造器来创建。此构造器接受单个参数：执行器(executor)函数，包含初始化 Promise 的代码。该执行器会被传递两个名为 resolve()与 reject() 的函数作为参数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"啊啊啊"</span>);</span><br><span class="line">    resolve();</span><br><span class="line">    <span class="keyword">if</span>(err)&#123;</span><br><span class="line">       reject();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"哦哦哦"</span>);</span><br><span class="line"><span class="comment">//啊啊啊</span></span><br><span class="line"><span class="comment">//哦哦哦</span></span><br></pre></td></tr></table></figure>

<p>​    构造器会在promise实例化的时候立刻执行。然后才会发生而里面 resolve() 或 reject() 在执行器内部被调用          时，一个作业被添加到作业队列中，以便决议（ resolve ）这个 Promise 。这也称为作业调度( job scheduling )，要注意一下被调度的作业会被放到队列的末尾最后执行</p>
<h5 id="创建已决Promise"><a href="#创建已决Promise" class="headerlink" title="创建已决Promise"></a>创建已决Promise</h5><p>​    Promise.resolve()和Promise.reject()的使用方式一样的所以只列举一个，另外一个照搬就行了</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = <span class="built_in">Promise</span>.resolve(<span class="number">42</span>);</span><br><span class="line">    promise.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value); <span class="comment">// 42</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>​    接受单个参数并返回一个处于完成态的 Promise 。没有任何作业调度会发生，并且需要向 Promise 添加一个或更多的完成处理函数来提取这个参数值。</p>
<h5 id="执行器错误"><a href="#执行器错误" class="headerlink" title="执行器错误"></a>执行器错误</h5><p>​    如果在执行器内部抛出了错误， Promise 的拒绝处理函数就会被调用，如果没有错误就会静默</p>
<p>#####全局的 Promise 拒绝处理</p>
<p>​    Promise有一个问题就是报错静默：当没有指定报错处理时发生的所有错误都不会被暴露和抛出而且你没有什么直观的办法去判断Promise的处理结果，而且你也不知道一个Promise对象什么时候会被处理</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> rejected = <span class="built_in">Promise</span>.reject(<span class="number">42</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一段时间后……</span></span><br><span class="line">	rejected.catch(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line"><span class="comment">// rejected 被处理</span></span><br><span class="line">	<span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>​    但是不用担心浏览器已经有了解决方案：</p>
<p>​    <strong>浏览器的拒绝处理</strong>：</p>
<p>当有有未处理的拒绝 时window 对象会触发两个事件：            </p>
<blockquote>
<p><code>unhandledrejection</code> ：当一个 Promise 被拒绝、而在事件循环的一个轮次中没有任何拒绝处理函数被调用，该事件就会被触发；<br><code>rejectionHandled</code> ：若一个 Promise 被拒绝、并在事件循环的一个轮次之后再有拒绝处理函数被调用，该事件就会被触发。</p>
</blockquote>
<p>以上两个浏览器事件的处理函数会接收到含下列属性的一个对象：</p>
<blockquote>
<p>type ： 事件的名称（ “unhandledrejection” 或 “rejectionhandled” ）；<br>promise ：被拒绝的 Promise 对象；<br>reason ： Promise 中的拒绝值（拒绝原因）。</p>
</blockquote>
<h4 id="串联-Promise-Promise链"><a href="#串联-Promise-Promise链" class="headerlink" title="串联 Promise(Promise链)"></a>串联 Promise(Promise链)</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">	resolve(<span class="number">42</span>);</span><br><span class="line">&#125;);</span><br><span class="line">p1.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(value);</span><br><span class="line">	&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">"Finished"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>对 p1.then() 的调用返回了第二个 Promise ，又在这之上调用了 then() 。仅当第一个Promise 已被决议后，第二个 then() 的完成处理函数才会被调用,每一次的加入作业队列时都会新生成一个promise</p>
<ul>
<li><p><strong>捕获错误</strong></p>
<ul>
<li>Promise 链允许捕获上一个 Promise 的完成或拒绝处理函数中发生的错误</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">	resolve(<span class="number">42</span>);</span><br><span class="line">&#125;);</span><br><span class="line">p1.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"Boom!"</span>);</span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(error.message); <span class="comment">// "Boom!"</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>在以上代码中， p1 的完成处理函数抛出了一个错误，链式调用指向了第二个 Promise 上的catch() 方法，能通过此拒绝处理函数接收前面的错误，前面如果是拒绝函数的话也是一样的。</p>
</li>
<li><p>在 Promise 链中返回值</p>
<p>Promise 链的另一重要方面是能从一个 Promise 传递数据给下一个 Promise 的能力。传递给<br>执行器中的 resolve() 处理函数的参数，会被传递给对应 Promise 的完成处理函数，</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">	resolve(<span class="number">42</span>);</span><br><span class="line">&#125;);</span><br><span class="line">p1.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(value); <span class="comment">// "42"</span></span><br><span class="line">		<span class="keyword">return</span> value + <span class="number">1</span>;</span><br><span class="line">	&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(value); <span class="comment">// "43"</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>p1 的完成处理函数在被执行时返回了 value + 1 。由于 value 的值为 42 （来自执行<br>器），此完成处理函数就返回了 43 。这个值随后被传递给第二个 Promise 的完成处理函数，</p>
</li>
<li><p>在 Promise 链中返回 Promise</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">	resolve(<span class="number">42</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">	resolve(<span class="number">43</span>);</span><br><span class="line">&#125;);</span><br><span class="line">p1.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">		<span class="comment">// 第一个完成处理函数</span></span><br><span class="line">        <span class="built_in">console</span>.log(value); <span class="comment">// 42</span></span><br><span class="line">        <span class="keyword">return</span> p2;</span><br><span class="line">	&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">	<span class="comment">// 第二个完成处理函数</span></span><br><span class="line">	<span class="built_in">console</span>.log(value); <span class="comment">// 43</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>在以上例子中如果p2执行出错的话会导致第二个完成处理函数永不被调用，这是因为在promise链中每当一个promise完成后下一个promise才会被加入作业队列，并且同时会很创建一个新的promise对象获取上一个对象的数据，  因此这以上代码中存在四个promise对象也就是</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">resolve(<span class="number">42</span>);<span class="comment">//第一个</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">resolve(<span class="number">43</span>);<span class="comment">//第二个</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">let</span> p3 = p1.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line"><span class="comment">// 第一个完成处理函数</span></span><br><span class="line"><span class="built_in">console</span>.log(value); <span class="comment">// 42</span></span><br><span class="line"><span class="keyword">return</span> p2;</span><br><span class="line">&#125;);<span class="comment">//第三个</span></span><br><span class="line">	p3.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line"><span class="comment">// 第二个完成处理函数</span></span><br><span class="line"><span class="built_in">console</span>.log(value); <span class="comment">// 43</span></span><br><span class="line">&#125;);<span class="comment">//第四个对象</span></span><br></pre></td></tr></table></figure>

<p>所以当p2报错时p3应当调用的是then()方法的第二个参数也就是拒绝函数而永不调用成功函数</p>
</li>
</ul>
<h4 id="响应多个-Promise"><a href="#响应多个-Promise" class="headerlink" title="响应多个 Promise"></a>响应多个 Promise</h4><ul>
<li><strong>Promise.all()</strong>：</li>
<li><strong>Promise.race() 方法</strong>：</li>
</ul>
]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈SVG</title>
    <url>/2019/12/07/%E6%B5%85%E8%B0%88SVG/</url>
    <content><![CDATA[<h1 id="浅谈SVG"><a href="#浅谈SVG" class="headerlink" title="浅谈SVG"></a>浅谈SVG</h1><h2 id="一、SVG相关概念"><a href="#一、SVG相关概念" class="headerlink" title="一、SVG相关概念"></a>一、SVG相关概念</h2><ul>
<li><p>什么是SVG</p>
<p>svg(Scalable Vector Graphic)，是一种可缩放的矢量图形，现在就针对定义来聊聊。</p>
<ul>
<li><p>矢量图形和栅格图形</p>
<ul>
<li><p>栅格图形</p>
<p>在这种系统中，图像由一个像素数组组成，这个数组里面的每一个像素都会用图形对应位置的RGB值表示，可以认为在一个图像上划分出N个正方形小方块，每一个小方块的值都等于图像在该位置的颜色，且改颜色用RBG的形式表示</p>
</li>
<li><p>矢量图形</p>
<p>在这种系统中，图像由一组几何图形的指令组成，矢量阅读器会按照指令在对应的指标集上绘制出一系列对应的图形。可以把图像切割成了N个几何图形，每一个图形都会记录相关的坐标，坐标间的连接顺序，方法等要素从而生成完成这个图形的指令，阅读器就会根据这些指令画出一个个几何图形最后形成完整的图像</p>
<a id="more"></a></li>
</ul>
</li>
<li><p>可缩放</p>
<p>其实在上面一点我们就能很清楚的知道矢量图实际上是拿到了画图的指令所以当我们方法缩小的时候其实只是改变了背景画布的大小并不会改变指令，所以阅读器依旧能根据指令绘制出完整的图像</p>
</li>
</ul>
</li>
</ul>
<h2 id="二、SVG基本属性"><a href="#二、SVG基本属性" class="headerlink" title="二、SVG基本属性"></a>二、SVG基本属性</h2><ul>
<li><h3 id="坐标系统"><a href="#坐标系统" class="headerlink" title="坐标系统"></a>坐标系统</h3><p>坐标系统是svg的基础，只有连接坐标我们才能确定各种图形的定位和属性的值，并通过操作各类标签和坐标实现我们想要的效果</p>
<ol>
<li>视口:也就是画布的区域，默认单位为px，可选的单位有：em,ex,px,cm,mm等</li>
<li>用户默认坐标系：原点(0,0)在视口坐上角，水平坐标轴(x轴)向右递增，垂直坐标轴(y轴)向下递增</li>
<li>为视口指定坐标系(viewbox):在视口中所有单位都默认为px且使用默认坐标系统，但如果需要从新修改坐标系统的话就需要用到viewbox属性，该属性有4个值(最小x坐标，最小y坐标，宽度，高度)</li>
</ol>
</li>
<li><h3 id="图形"><a href="#图形" class="headerlink" title="图形"></a>图形</h3><ul>
<li><p>图形标签</p>
<ul>
<li>线段(line):使用<code>&lt;line&gt;</code>标签，需要制定起止点的x,y坐标，默认单位为坐标系坐标</li>
<li>矩形(rect):使用<code>&lt;revt&gt;</code>标签，需要制定左上角起始点的x,y坐标，宽度(width)和高度(height)</li>
<li>圆(circle)和椭圆(ellipse):使用<code>&lt;circle&gt;</code>标签，需要制定圆心坐标cx,cy，半径(r),若是椭圆还要制定xy的半轴长度rx,ry</li>
<li>多边形(polygon):使用<code>&lt;polygon&gt;</code>标签，这个标签可以组成任意封闭图形只要在points属性制定一系列的点的坐标并用逗号或空格分隔，会根据points各点依次连接并在最后自动重回起点</li>
<li>折线(polyline):使用<code>&lt;polyline&gt;</code>标签，这个标签基本上等同于多边形标签，但有一点不同的是它在画完最后一点时不会重回起点，所以一般用来画不封闭的图形</li>
</ul>
</li>
<li><p>图形属性：</p>
<ul>
<li><p>画笔类</p>
<ol>
<li>stroke:画笔颜色，默认none</li>
<li>stroke-width:画笔宽度，默认1</li>
<li>stroke-opacity:画笔透明度，默认1.0</li>
<li>stroke-dasharry:用一组的数字制定虚线和间隙的长度，默认none</li>
<li>stroke-linejoin:图形连接处的形状，默认miter(尖),round(圆滑),bevel(平的)</li>
</ol>
</li>
<li><p>填充类</p>
<ol>
<li>fill:制定填充颜色，默认blcak</li>
<li>fill-opacity:填充透明度，默认1.0</li>
<li>fill-rule:是否在图形内，当线段有交叉时才有效。默认nonezero</li>
</ol>
</li>
<li><p>样式类(简单来说SVG标签和HTML的样式使用方法是一样的，只是属性不同而已)</p>
<ol>
<li><p>结构:和HTML标签应用CSS类似</p>
<p><code>stroke:blue;fill:red;</code></p>
</li>
<li><p>内联样式(Style):给标签应用style属性</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;circle cx='10',cy='50',r='10' style="fill:red; stroke:blue"&gt;</span><br><span class="line">&lt;rect x='10',y='50',width='30' height='40'style="fill:red;stroke:blue" &gt;</span><br></pre></td></tr></table></figure>



</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code>3. 样式类(Class):给标签应用calss属性，所有带有同名类的标签都会应用同一样式

   <figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.special</span>&#123;</span><br><span class="line">    fill:red;</span><br><span class="line">    stroke:blue</span><br><span class="line">&#125;</span><br><span class="line">&lt;circle cx=<span class="string">'10'</span>,cy=<span class="string">'50'</span>,r=<span class="string">'10'</span> class=<span class="string">'special'</span>&gt;</span><br><span class="line">&lt;rect x=<span class="string">'10'</span>,y=<span class="string">'50'</span>,width=<span class="string">'30'</span> height=<span class="string">'40'</span> class=<span class="string">'special'</span>&gt;</span><br></pre></td></tr></table></figure></code></pre><h2 id="三、-组合与复用"><a href="#三、-组合与复用" class="headerlink" title="三、 组合与复用"></a>三、 组合与复用</h2><h4 id="lt-g-gt-标签"><a href="#lt-g-gt-标签" class="headerlink" title="&lt;g&gt;标签"></a>&lt;g&gt;标签</h4><p>​    <code>&lt;g&gt;</code>标签会把它所有的子元素都当成一个组合，每个组合都可以有自己的id，title，类似于自定义的标签，这样我们就能够很方便的复用组合好的复杂图形</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">g</span> <span class="attr">id</span>=<span class="string">'demo1'</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">circle</span> <span class="attr">cx</span>=<span class="string">'100'</span> <span class="attr">cy</span>=<span class="string">'50'</span> <span class="attr">r</span>=<span class="string">'10'</span>&gt;</span><span class="tag">&lt;/<span class="name">circle</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">polyline</span> <span class="attr">points</span>=<span class="string">'100 60,100 70,100 80,110 80,100 70'</span>&gt;</span><span class="tag">&lt;/<span class="name">polyline</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">g</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h4 id="lt-use-gt-标签"><a href="#lt-use-gt-标签" class="headerlink" title="&lt;use&gt;标签"></a>&lt;use&gt;标签</h4><p><code>&lt;use&gt;</code>元素在指定对应的值（<code>xline:href=&#39;xx&#39;</code>）后能够实现类似于复制粘贴的功能,并且需要指定定赋值的样本原点需要移动到的位置，一般和<code>&lt;g&gt;</code>组合使用</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">g</span> <span class="attr">id</span>=<span class="string">'house'</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">desc</span>&gt;</span>周家堡<span class="tag">&lt;/<span class="name">desc</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rect</span> <span class="attr">x</span>=<span class="string">"0"</span> <span class="attr">y</span>=<span class="string">"40"</span> <span class="attr">width</span>=<span class="string">"60"</span> <span class="attr">height</span>=<span class="string">"60"</span>&gt;</span><span class="tag">&lt;/<span class="name">rect</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">polyline</span> <span class="attr">points</span>=<span class="string">'0 40,30 0,60 40'</span>&gt;</span><span class="tag">&lt;/<span class="name">polyline</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">polyline</span> <span class="attr">points</span>=<span class="string">'30 100,30 70,44 70,44 100'</span>&gt;</span><span class="tag">&lt;/<span class="name">polyline</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">g</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">use</span> <span class="attr">xline:href</span>=<span class="string">'#house'</span> <span class="attr">x</span>=<span class="string">"100"</span> <span class="attr">y</span>=<span class="string">"100"</span>&gt;</span><span class="tag">&lt;/<span class="name">use</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">use</span> <span class="attr">xline:href</span>=<span class="string">'#house'</span> <span class="attr">x</span>=<span class="string">"-50"</span> <span class="attr">y</span>=<span class="string">"-50"</span>&gt;</span><span class="tag">&lt;/<span class="name">use</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="lt-defs-gt-标签"><a href="#lt-defs-gt-标签" class="headerlink" title="&lt;defs&gt;标签"></a>&lt;defs&gt;标签</h4><p>在我们使用<code>&lt;g&gt;</code>标签的时候会有一个问题就是只要定义了组合就马上会被创建,而且我们没有办法去对组合的样式进行修改，因此这样一来复用性其实不是很好，这个时候就需要使用<code>&lt;defs&gt;</code>标签，我们可以预先在该标签内写好我们想要复用的组合或者图形，他们会被定义但并不会被创建出来，只有当我们使用<code>&lt;use&gt;</code>引用时才会被创建，并且能够对模板使用样式</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">defs</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">g</span> <span class="attr">id</span>=<span class="string">'house'</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">desc</span>&gt;</span>周家堡<span class="tag">&lt;/<span class="name">desc</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rect</span> <span class="attr">x</span>=<span class="string">"0"</span> <span class="attr">y</span>=<span class="string">"40"</span> <span class="attr">width</span>=<span class="string">"60"</span> <span class="attr">height</span>=<span class="string">"60"</span>&gt;</span><span class="tag">&lt;/<span class="name">rect</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">polyline</span> <span class="attr">points</span>=<span class="string">'0 40,30 0,60 40'</span>&gt;</span><span class="tag">&lt;/<span class="name">polyline</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">polyline</span> <span class="attr">points</span>=<span class="string">'30 100,30 70,44 70,44 100'</span>&gt;</span><span class="tag">&lt;/<span class="name">polyline</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">g</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">defs</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">use</span> <span class="attr">xline:href</span>=<span class="string">'#house'</span> <span class="attr">x</span>=<span class="string">"100"</span> <span class="attr">y</span>=<span class="string">"100"</span> <span class="attr">style</span>=<span class="string">"fill:pink;"</span>&gt;</span><span class="tag">&lt;/<span class="name">use</span>&gt;</span>//粉色房子</span><br><span class="line"><span class="tag">&lt;<span class="name">use</span> <span class="attr">xline:href</span>=<span class="string">'#house'</span> <span class="attr">x</span>=<span class="string">"-50"</span> <span class="attr">y</span>=<span class="string">"-50"</span> <span class="attr">style</span>=<span class="string">"fill:blue;"</span>&gt;</span><span class="tag">&lt;/<span class="name">use</span>&gt;</span>//蓝色房子</span><br></pre></td></tr></table></figure>

<h3 id="四、路径-lt-Path-gt"><a href="#四、路径-lt-Path-gt" class="headerlink" title="四、路径&lt;Path&gt;"></a>四、路径&lt;Path&gt;</h3><p><code>&lt;path&gt;</code>标签可以绘制出任意图形，只需要指定一系列的坐标，所有描述属性坐标的数据都放在d属性(data)里面</p>
<blockquote>
<p>一段path可以有多个绘制组合，也就是说在一个path标签里面可以画出N个任意中断或者连接的的图形，</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">path</span> <span class="attr">d</span>=<span class="string">"M 10,20 L10,60 40,45 M60,60 L90,90 60,45"</span>&gt;</span><span class="tag">&lt;/<span class="name">path</span>&gt;</span>//绘制出了两个角度</span><br></pre></td></tr></table></figure>
</blockquote>
<h5 id="d-data-属性"><a href="#d-data-属性" class="headerlink" title="d(data)属性"></a>d(data)属性</h5><p><strong>指令</strong>:</p>
<p><strong>M(moveto)</strong>：d属性必须以此开头,代表的是画笔起始的位置，后面紧接着一个使用逗号或者空格分    隔符的x,y坐标，M表示绝对位置，m表示相对位置，但是由于m没有参照系所以第一个m也会变成    绝对位置</p>
<p><strong>L(Lineto)</strong>:L属性后面也是跟着坐标以逗号或者空格分隔，表示的是画笔移动的目的地坐标，L绝对，l相对(参考的是前一个M的位置，下同不赘述)</p>
<p><strong>Z(closepath)</strong>:用来关闭当前路径同时开启一个子路径，Z后面不跟坐标且他的大小写效果一模一样，同时Z标签会连接起始点从而形成封闭的图形</p>
<p><strong>V，H</strong>:用来绘制水平方向(H)和垂直方向(V)的路径，后面只要跟一个目标点的x或y坐标，因为另一个坐标是定死的，大小写情况和其他标签相同</p>
<p><strong>A(elliptical Arc)</strong>:用来绘制一条到目标点的椭圆弧，有以下参数</p>
<ol>
<li>起始点坐标，x,y</li>
<li>x轴旋转角度</li>
<li>圆弧角度是否大于180,0是小于1是大于</li>
<li>圆弧正负角度0是负角度，1是正角度也就是画笔以逆时针还是顺时针画弧</li>
<li>终点x,y坐标</li>
</ol>
<p><strong>Q、T、C、S</strong>：贝塞尔曲线相关不建议使用（因为太难了我搞不懂…）</p>
<h3 id="五、文本"><a href="#五、文本" class="headerlink" title="五、文本"></a>五、文本</h3><p>文本标签用来绘制svg图形中的文字</p>
<h4 id="lt-text-gt-标签"><a href="#lt-text-gt-标签" class="headerlink" title="&lt;text&gt;标签"></a>&lt;text&gt;标签</h4><p><code>&lt;text&gt;</code>需要制定x,y坐标来作为第一个文字的位置其样式基本属性和css中文字有关的属性基本一样，</p>
<p>属性：</p>
<blockquote>
<p>font-size:字体大小</p>
<p>font-style:字体是否倾斜italic(倾斜)，normal</p>
<p>text-decoration:是否有下划线none,underline,overline,line-through</p>
</blockquote>
<h4 id="lt-tspan-gt-标签"><a href="#lt-tspan-gt-标签" class="headerlink" title="&lt;tspan&gt;标签"></a>&lt;tspan&gt;标签</h4><p>我们可以简单的把该标签理解成span，他们都可以嵌入到文本中，在这个标签你可以为它单独定制样式等属性，而且由于是内嵌元素所以也不需要指定坐标</p>
<p><strong>改变位置的属性</strong>：</p>
<p>​    dx,dy(水平和垂直方向偏移量):dx,dy的值都是你想偏移的具体数值，且都是相对于原本位置来说    的，类似于position里面的relative</p>
<p>​    x,y(绝对定位):这里的xy都是当前文本的绝对位置，类似于<code>&lt;text&gt;</code>的xy</p>
<blockquote>
<p>x，y，dx，dy都可以单独或者组合使用，单独使用时其他为指明的值为默认值</p>
</blockquote>
<h4 id="文本路径-lt-textPath-gt"><a href="#文本路径-lt-textPath-gt" class="headerlink" title="文本路径&lt;textPath&gt;"></a>文本路径&lt;textPath&gt;</h4><p>这个也是以后可能使用频率很高的属性，这个属性类似于<code>&lt;path&gt;</code>标签，让文字按照指定路径排列，</p>
<blockquote>
<p>使用步骤</p>
<p>1：将文字的显示路径用path预先定义我们想要的path路径一般放在<code>&lt;defs&gt;</code>里面</p>
<p>2：定义好&lt;text&gt;文本域，在文本里面加入&lt;textPath&gt;标签，并且使用<code>xline:href=xxx</code>来引用</p>
<p>3.在&lt;textPath&gt;标签中定义我们的文字</p>
</blockquote>
]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>SVG</tag>
      </tags>
  </entry>
</search>
