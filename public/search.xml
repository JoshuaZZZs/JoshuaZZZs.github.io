<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>ES6语法总结(二)</title>
    <url>/2019/11/21/ES6%E6%80%BB%E7%BB%93%E4%BA%8C(%E5%AF%B9%E8%B1%A1%E5%92%8C%E6%95%B0%E7%BB%84)/</url>
    <content><![CDATA[<h1 id="ES6语法总结"><a href="#ES6语法总结" class="headerlink" title="ES6语法总结"></a>ES6语法总结</h1><h2 id="对象-Object"><a href="#对象-Object" class="headerlink" title="对象(Object)"></a>对象(Object)</h2><ul>
<li><p><strong>属性初始化器速记</strong>：在ES6中当对象字面量中的属性只有名称时， JS 引擎会在周边作用域查找同名变量。若找到，该变量的值将会被赋给对象字面量的同名属性。所以当属性和值相同时可以只写一个名称例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        name,</span><br><span class="line">        age</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a></li>
<li><p><strong>方法简写</strong>:在ES6为字面量定义函数时必须指定一个名称并用完整的函数定义来为对象添加方法，在ES6中也将其做了优化</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">name: <span class="string">"zhoushaung"</span>,</span><br><span class="line">sayName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="comment">//es5 </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">sayName()&#123;<span class="comment">//es6 </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>可计算的属性名</strong>:对象实例能使用“需计算的属性名”，只要用方括号表示法来代替小数点表示法即可,在ES6中的计算属性名是对象字面量语法的一部分所以可以直接用变量或字符串字作为属性名，同时在[]也可以使用表达式</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> suffix = <span class="string">" man"</span>;</span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">[suffix+<span class="string">"name"</span>]: <span class="string">"zhoushuang"</span>,</span><br><span class="line">[suffix+<span class="string">"gender"</span>]: <span class="string">"male"</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(person[<span class="string">"man name"</span>]); <span class="comment">// "zhoushuang"</span></span><br><span class="line"><span class="built_in">console</span>.log(person[<span class="string">"mane gender"</span>]); <span class="comment">//male</span></span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p><strong>新增方法(Object.is(),Object.assign())</strong>：</p>
<ul>
<li><p>Object.is:用来弥补相等运算符的不足(<code>==</code>和<code>===</code>)，在一般相等运算符无法判定值相同类型不同的情况，在严格相等运算符中无法判定为 +0 与 -0 相等， NaN === NaN 等情况，而Object.is会判定两个数据的类型和值是否相等例</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(+<span class="number">0</span> == <span class="number">-0</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(+<span class="number">0</span> === <span class="number">-0</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.is(+<span class="number">0</span>, <span class="number">-0</span>)); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">NaN</span> == <span class="literal">NaN</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">NaN</span> === <span class="literal">NaN</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.is(<span class="literal">NaN</span>, <span class="literal">NaN</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span> == <span class="number">1</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span> == <span class="string">"1"</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span> === <span class="number">1</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span> === <span class="string">"1"</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.is(<span class="number">5</span>, <span class="number">5</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.is(<span class="number">5</span>, <span class="string">"5"</span>)); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>



</li>
</ul>
</li>
</ul>
<ul>
<li><p>Object.assign:用来对两个对象进行混入操作，该方法接受任意数量的参数并且会按照参数列表中的顺序来依次接收它们的属性，也就是说当有同名属性时可能会出现后来的参数覆盖前面的情况</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj1 = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.assign(obj1,</span><br><span class="line">&#123;</span><br><span class="line">type: <span class="string">"shuaib"</span>,</span><br><span class="line">name: <span class="string">"zhoushuang"</span></span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">type: <span class="string">"handsome"</span></span><br><span class="line">&#125;</span><br><span class="line">);</span><br><span class="line"><span class="built_in">console</span>.log(obj1.type); <span class="comment">// "handsome"</span></span><br><span class="line"><span class="built_in">console</span>.log(obj1.name); <span class="comment">// "zhoushuang"</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<ul>
<li><p><strong>重复的对象字面量属性</strong>:当同一对象存在重复属性时，排在后面的属性的值会成为该属性的实际值而不会报错</p>
</li>
<li><p><strong>可枚举属性的顺序(Object.getOwnPropertyNames())</strong>：该方法会根据以下规则返回对象的属性：</p>
<ol>
<li>所有的数字类型键，按升序排列。</li>
<li>所有的字符串类型键，按被添加到对象的顺序排列。</li>
<li>所有的符号类型（详见第六章）键，也按添加顺序排列。</li>
</ol>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">a</span>: <span class="number">1</span>,<span class="number">0</span>: <span class="number">1</span>,<span class="attr">c</span>: <span class="number">1</span>,<span class="number">2</span>: <span class="number">1</span>,<span class="attr">b</span>: <span class="number">1</span>,<span class="number">1</span>: <span class="number">1</span>&#125;;</span><br><span class="line">obj.d = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyNames(obj).join(<span class="string">""</span>)); <span class="comment">// "012acbd"</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>原型</strong>：</p>
<ul>
<li><p>新增和修改原型：Object.setPrototypeOf()允许你修改任意指定对象的原型。它接受两个参数：需要被修改原型的对象，以及将会成为前者原型的对象, Object.getPrototypeOf() 方法从任意指定对象中获取其原型.</p>
</li>
<li><p>super调用原型的函数:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">getGreeting() &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"Hello"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> dog = &#123;</span><br><span class="line">getGreeting() &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"Woof"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> friend = &#123;</span><br><span class="line">getGreeting() &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">super</span>.getGreeting() + <span class="string">", hi!"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 将原型设置为 person</span></span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(friend, person);</span><br><span class="line"><span class="built_in">console</span>.log(friend.getGreeting()); <span class="comment">// "Hello, hi!"</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(friend) === person); <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 将原型设置为 dog</span></span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(friend, dog);</span><br><span class="line"><span class="built_in">console</span>.log(friend.getGreeting()); <span class="comment">// "Woof, hi!"</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(friend) === dog); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>有点类似于java对父类方法的重写,在有多重继承的情况下会比较好使一点</p>
</li>
</ul>
</li>
</ul>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><ul>
<li><p><strong>创建数组方法</strong>：</p>
<ul>
<li><p>Array.of():) 方法总会创建一个包含所有传入参数的数组，而不管参数的数量与类型</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> items = <span class="built_in">Array</span>.of(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(items.length); <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(items[<span class="number">0</span>]); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(items[<span class="number">1</span>]); <span class="comment">// 2</span></span><br><span class="line">items = <span class="built_in">Array</span>.of(<span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(items.length); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(items[<span class="number">0</span>]); <span class="comment">// 2</span></span><br><span class="line">items = <span class="built_in">Array</span>.of(<span class="string">"2"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(items.length); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(items[<span class="number">0</span>]);</span><br></pre></td></tr></table></figure>



</li>
</ul>
</li>
</ul>
<ul>
<li><p>Array.from():多用于类数组对象转化成为数组或者转化前进行额外操作时使用，接收三个参数</p>
<ol>
<li>参数对象(arguments)：传入要进行转化的初始对象</li>
<li>操作方法(function)：如需额外加工，传入加工具体步骤</li>
<li>映射(object):如果function已经被定义或者需要进入额外对象方法，在此传入方法所在对象，此时的this就会指向被传入的对象</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> helper = &#123;</span><br><span class="line">diff: <span class="number">1</span>,</span><br><span class="line">add(value) &#123;</span><br><span class="line"><span class="keyword">return</span> value + <span class="keyword">this</span>.diff;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">translate</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Array</span>.from(<span class="built_in">arguments</span>, helper.add, helper);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> numbers = translate(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"><span class="built_in">console</span>.log(numbers); <span class="comment">// 2,3,4</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<ul>
<li><p><strong>其他方法</strong>:</p>
<ul>
<li><p><strong>find()和findIndex()</strong>:这两俩函数非常像所以把他们放在一起讨论，</p>
<ul>
<li>相同点：<ol>
<li>都是在数组中查找符合要求的值</li>
<li>均接受两个参数：一个回调函数和一个可选值用于指定回调函数内部的 this 。该回调函数可接收三个参数：数组的某个元素、该元素对应的索引位置、以及该数组自身</li>
<li>均会在回调函数第一次返回 true 时停止查找</li>
</ol>
</li>
<li>区别<ol>
<li>find() 方法返回匹配的值</li>
<li>findIndex() 方法则会返回匹配位置的索引</li>
</ol>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> numbers = [<span class="number">25</span>, <span class="number">30</span>, <span class="number">35</span>, <span class="number">40</span>, <span class="number">45</span>];</span><br><span class="line"><span class="built_in">console</span>.log(numbers.find(<span class="function"><span class="params">n</span> =&gt;</span> n &gt; <span class="number">33</span>)); <span class="comment">// 35</span></span><br><span class="line"><span class="built_in">console</span>.log(numbers.findIndex(<span class="function"><span class="params">n</span> =&gt;</span> n &gt; <span class="number">33</span>));</span><br></pre></td></tr></table></figure>
</li>
<li><p>*<em>fill() *</em>:</p>
<ul>
<li>作用:用于填充数组中的一个或者多个参数</li>
<li>语法:fill(number,firstIndex,lastIndex)：<ol>
<li>number：进行替换操作的数据，</li>
<li>firstIndex，lastIndex:进行替换操作的初始位置和结束位置</li>
</ol>
</li>
<li>注:后两个参数是该数组的下标,当其为负是值为Array.length+firstIndex/lastIndex</li>
</ul>
</li>
<li><p><strong>copyWithin()</strong>:</p>
<ul>
<li>作用：和fill一样用于填充替换数组,但这个方法可以在数组内部复制自身元素</li>
<li>语法:copyWithin(target,start,end):<ol>
<li>start:粘贴的起始位置</li>
<li>target:从第几个位置作为粘贴项</li>
<li>end:被覆盖元素的个数</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="comment">// 从索引 2 的位置开始粘贴</span></span><br><span class="line"><span class="comment">// 从数组索引 0 的位置开始复制数据</span></span><br><span class="line"><span class="comment">// 在遇到索引 1 时停止复制</span></span><br><span class="line">numbers.copyWithin(<span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(numbers.toString()); <span class="comment">// 1,2,1,4</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6语法总结(一)</title>
    <url>/2019/10/11/ES6%E6%80%BB%E7%BB%93%E4%B8%80(%E5%8F%98%E9%87%8F%E4%B8%8E%E5%87%BD%E6%95%B0)/</url>
    <content><![CDATA[<h1 id="ES6语法总结"><a href="#ES6语法总结" class="headerlink" title="ES6语法总结"></a>ES6语法总结</h1><h2 id="块级绑定（let-，var，const）"><a href="#块级绑定（let-，var，const）" class="headerlink" title="块级绑定（let ，var，const）"></a>块级绑定（<em>let ，var，const</em>）</h2><h3 id="传统var的问题（变量提升，块级作用域）"><a href="#传统var的问题（变量提升，块级作用域）" class="headerlink" title="传统var的问题（变量提升，块级作用域）"></a>传统var的问题（<em>变量提升，块级作用域</em>）</h3><p>var是用来声明各类型变量的关键字，但存在一个问题–<strong>变量提升</strong>（<em>在当前作用域内使用var关键词声明的变量都会提升到当前作用域的顶部</em>）例:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getValue</span>(<span class="params">condition</span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (condition) &#123;</span><br><span class="line"><span class="keyword">var</span> value = <span class="string">"blue"</span>;</span><br><span class="line"><span class="comment">// 其他代码</span></span><br><span class="line"><span class="keyword">return</span> value;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// value 在此处可访问，值为 undefined</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// value 在此处可访问，值为 undefined</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<a id="more"></a>
<p>在这里可以很明显的知道value虽然定义在了if为真后的语句块中但事实上在整个函数内部都能访问的到，这段代码实际上相当于</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getValue</span>(<span class="params">condition</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> value;</span><br><span class="line"><span class="keyword">if</span> (condition) &#123;</span><br><span class="line">value = <span class="string">"blue"</span></span><br></pre></td></tr></table></figure>

<p>这就可能会产生一些意想不到的问题了，因此ES6中增加了一个<strong>块级作用域</strong>的概念（<em>就是让所声明的变量在指定块的作用域外无法被访问。块级作用域（词法作用域）在如下情况被创建：</em></p>
<ol>
<li><em>在一个函数内部</em></li>
<li><em>在一个代码块（由一对花括号{}包裹）内部）</em> </li>
</ol>
<h3 id="let与const"><a href="#let与const" class="headerlink" title="let与const"></a>let与const</h3><h4 id="共同特性："><a href="#共同特性：" class="headerlink" title="共同特性："></a>共同特性：</h4><ul>
<li><p>块级声明：两者均为块级声明即仅在当前定义语句行开始生效，以let为例：</p>
</li>
<li><pre><code class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">getValue</span>(<span class="params">condition</span>) </span>{
<span class="keyword">if</span> (condition) {
<span class="comment">//console.log(value)报错</span>

 <span class="keyword">let</span> value = <span class="string">"blue"</span>;

<span class="comment">//console.log(value) blue</span>
eturn value;
} <span class="keyword">else</span> {

<span class="keyword">return</span> <span class="literal">null</span>;
}

}
&lt;!--￼<span class="number">2</span>--&gt;

在这个函数中我们用||运算符给timeout，timeout都赋予了默认值，但是当timeout为<span class="number">0</span>时由于<span class="number">0</span>的布尔值为<span class="literal">false</span>所以会被设为<span class="number">2000</span>但有时候其实是需要赋值为<span class="number">0</span>的，所以在我们为函数赋默认值时有时候会有出现传<span class="number">0</span>或‘’参数被覆盖的情况，解决这种情况可以用<span class="keyword">typeof</span>===‘<span class="literal">undefined</span>’解决但是增加了很多代码量，所以es6中对这种情况进行了改进</code></pre>
</li>
<li><p>ES6中参数对象–(<strong>具名对象</strong>)</p>
<ul>
<li><strong>语法</strong>:<code>function makeRequest(url, timeout = 2000, callback = function() {}) }</code>ES6中一般在参数列表声明时赋与默认值，在这种情况下只有两种函数才会有默认值</li>
</ul>
</li>
</ul>
<ol>
<li><p>​        未传入第二三个对象</p>
</li>
<li><p>传入undfined(这里的null是一个数据类型，因此传入null不会赋予默认值)</p>
<ul>
<li><p><strong>消除对arguments对象的影响</strong>：在ES5中在函数对与参数的任意操作都会影响到arguments对象里面的值，只有在ES5严格模式下才会消除影响而只要被启用了ES6规则都可以消除影响</p>
</li>
<li><p><strong>传递默认表达式</strong>：在设置具名参数默认值的时候不仅可以使用基本参数类型还可以使用表达式，即</p>
</li>
<li><pre><code class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">getValue</span>(<span class="params"></span>) </span>{
<span class="keyword">return</span> <span class="number">5</span>;
}
<span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">first=<span class="number">1</span>, second = getValue(</span>)) </span>{
<span class="keyword">return</span> first + second;
}
<span class="built_in">console</span>.log(add(<span class="number">1</span>, <span class="number">1</span>)); <span class="comment">// 2</span>
<span class="built_in">console</span>.log(add(<span class="number">1</span>)); <span class="comment">// 6</span>
<span class="built_in">console</span>.log(add(<span class="number">1</span>)); <span class="comment">// 7</span>
&lt;!--￼<span class="number">3</span>--&gt;

 keys就是一个剩余参数对象，他会包含object之后的所有参数对象

- 使用的时候要注意两个点<span class="number">1.</span>不能再剩余参数之后再声明参数，<span class="number">2.</span>不能再settr字面量属性中使用</code></pre>
</li>
</ul>
</li>
</ol>
<ul>
<li><p>拓展运算符(…)</p>
</li>
<li><p>拓展运算符会便利参数对象所有可枚举的属性，拷贝到当前对象中，对象，数组。字符串等均可使用</p>
</li>
<li><p>箭头函数(=&gt;)</p>
<ul>
<li>语法：<code>（）=&gt;{函数体}</code>,当只有一个参数或者之有一条执行语句时可以省略括号，当有多个参数，无参数，函数体有多条语句时必须用<code>（）=&gt;{}</code>的格式</li>
<li>特点：<ul>
<li><strong>没有this绑定</strong>:箭头函数体内部的this与调用它的父级指向一致</li>
<li><strong>没有arguments绑定</strong>：函数体内无法使用arguments访问它本身的参数对象，但是可以访问父级的arguments对象</li>
<li><strong>具名参数和不具名参数</strong>:在箭头函数中都能正常使用</li>
</ul>
</li>
</ul>
</li>
<li><p>尾调用优化：</p>
<ul>
<li><p>语法：在函数的最后一句调用某函数的第一句(也可以是自己)例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Something</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> SomethingElse(); <span class="comment">// 尾调用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>作用：会清除当前函数的栈帧并重复使用以此提高性能在ES6严格模式中有以下情况会启用尾调用：</p>
<ol>
<li>尾调用不能引用当前栈帧中的变量（意味着该函数不能是闭包）；</li>
<li>进行尾调用的函数在尾调用返回结果后不能做额外操作；</li>
<li>尾调用的结果作为当前函数的返回值。</li>
</ol>
</li>
<li><p>应用：一般是应用在递归函数，或者有复杂计算过程的函数时效果明显，</p>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>日系风格拍摄思路</title>
    <url>/2020/04/09/%E6%97%A5%E7%B3%BB%E9%A3%8E%E6%A0%BC%E8%B0%83%E8%89%B2%E6%80%9D%E8%B7%AF/</url>
    <content><![CDATA[<p><img src="/2020/04/09/%E6%97%A5%E7%B3%BB%E9%A3%8E%E6%A0%BC%E8%B0%83%E8%89%B2%E6%80%9D%E8%B7%AF/photograph.jpg" alt></p>
<h1 id="日系风格拍摄思路"><a href="#日系风格拍摄思路" class="headerlink" title="日系风格拍摄思路"></a>日系风格拍摄思路</h1><p>最近开始尝试拍摄日系风格，看了网上很多文章，之后在拍摄和后期的过程中自己也在不断的改进慢慢的有了一些浅薄的理解，但基于每个人摄影的风格，采用的手法，照片的构图等等都不一样。具体操作参数并没有普遍意义，所以我只写总体思路，这样应用场景能广泛些。</p>
<h2 id="什么是日系风格"><a href="#什么是日系风格" class="headerlink" title="什么是日系风格"></a>什么是日系风格</h2><p>我所理解的日系风格简单来说就是从小到大接触的日本的动漫，电影，插画等等这里选取几部我很喜欢的日系电影《海街日记》《小森林》来说明</p>
<p>先看看不同手法的剧照和巨巨巨想去的镰仓</p>
<p><img src="/2020/04/09/%E6%97%A5%E7%B3%BB%E9%A3%8E%E6%A0%BC%E8%B0%83%E8%89%B2%E6%80%9D%E8%B7%AF/%E6%B5%B7%E8%A1%97%E6%97%A5%E8%AE%B01.jpg" alt></p>
<center><font color="#ccc"><em>《海街日记》</em></font></center>
<a id="more"></a>

<p><img src="/2020/04/09/%E6%97%A5%E7%B3%BB%E9%A3%8E%E6%A0%BC%E8%B0%83%E8%89%B2%E6%80%9D%E8%B7%AF/%E5%B0%8F%E6%A3%AE%E6%9E%97%C2%B7%E5%86%AC%E6%98%A5.jpg" alt></p>
<center><font color="#ccc"><em>《小森林·冬春》</em></font></center>

<p><img src="/2020/04/09/%E6%97%A5%E7%B3%BB%E9%A3%8E%E6%A0%BC%E8%B0%83%E8%89%B2%E6%80%9D%E8%B7%AF/%E6%B5%B7%E8%A1%97%E6%97%A5%E8%AE%B03.jpg" alt></p>
<center><font color="#ccc"><em>《海街日记》--樱花</em></font></center>
![](日系风格调色思路/海街日记2.jpg)

<center><font color="#ccc"><em>《海街日记》--小家</em></font></center>
日系风格的电影和照片总是给人一种治愈，温暖，简单的情绪，而这种来自于**真实和谐的照片内容结构+整体相似的色彩渲染的氛围**

<h4 id="内容结构"><a href="#内容结构" class="headerlink" title="内容结构"></a>内容结构</h4><p>在以上的例子中有冷暖色调和高低色温,但他们的场景都有一个共通点——简单，不管是街景，樱花，树林还是院落都是我们生活中常见的景象，不需要特殊的构图，线条，力求真实，看起来就像是我们生活中不经意的瞬间</p>
<h4 id="色彩"><a href="#色彩" class="headerlink" title="色彩"></a>色彩</h4><p>真实简单的场景仅能够有代入感但这远不足够，还需要色彩来调整照片的重点和加强氛围借此来表达出情绪,个人认为这一类清新的日系所追求的目标应该是照片所有内容共同构建出来的氛围，所以我们应当让整体和谐，削弱突出的细节，把看者注意力转移整体的情景中。在大部分情况下降低对比度都是一个必要的选择。</p>
<h2 id="日系风格的取景"><a href="#日系风格的取景" class="headerlink" title="日系风格的取景"></a>日系风格的取景</h2><p>这一类的日系取景的整体思路,就是雨露均沾。在拍摄前最好在脑海中先构建出你需要拍摄的大概情景或者想要的效果，再根据效果和实际场景去取景。这部分除了丰富的想象力之外我觉着多看这一类的电(强推是枝裕和，总是在看似无趣的日常里面表达出轻微但是稠密且绵长的情感。非常nice~)或者多看类似的图片会好一些，画面主体内容上结构比例和谐即可但最好不要出现过于突出的主体.</p>
<p>如果是有人像参与，最好让人像成为景中的一部分，穿着上也尽量素一些，太过花哨的着装会浪费多余的注意力，破坏整体的情境，着装的色调也最好和整体环境的色调贴近，不好选的话中性色调是个不错的选择。</p>
<h2 id="日系风格的后期调色"><a href="#日系风格的后期调色" class="headerlink" title="日系风格的后期调色"></a>日系风格的后期调色</h2><p>原片完成之后，后期调色也是渲染氛围的重要一步，在整体色调上尽量以主体环境颜色以基准或者以你提前想好的效果为准(但是一定要偏色)，照片整体的色温贴近而色调需要取决于画面的主体和颜色的通透情况而定，在大多数情况下需要降低对比度，提高曝光。</p>
<h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><p>下面也选了两张我自己拍摄的，第二章由于原片被我删了所以只讲一下我第一张的调色思路，以下是原图</p>
<p><img src="/2020/04/09/%E6%97%A5%E7%B3%BB%E9%A3%8E%E6%A0%BC%E8%B0%83%E8%89%B2%E6%80%9D%E8%B7%AF/%E5%8E%9F%E5%9B%BE1.jpg" alt></p>
<p>这一张拍摄前我提前想好了想要一种夏日林间少女感觉，所以采用的是逆光手法+大光圈拍摄，当时拍摄的时间是四五点的公园树林里，照片主体偏黄，所以整体风格选都尽量靠近暖色上面靠近，且能观察到画面上除余阳光直射的部分外其他部分都偏暗。</p>
<p>小清新类的日系照片通透性都非常好，而我们首先要做的就是让画面看起来干净，整体性强一些。先降低对比度增强整体性，其次增加曝光和亮度来进一步削弱带来的影响消除影响，增加通透性。</p>
<p>画面干净之后我们需要做的就是调整色温和色调，制造偏色来营造我们想要的效果，已经说过我们主体选用的是暖色调，所以我们需要画面看起来干净温暖，调高色温降低色调让整体画面去贴近暖色，同时也要适当调整饱和度，让画面整体颜色结构合理。</p>
<p>再后就是做一些微小的细节处理，增加阴影亮度，黑白色阶，高光，降低清晰度等等去贴近我们想要的效果。</p>
<p><img src="/2020/04/09/%E6%97%A5%E7%B3%BB%E9%A3%8E%E6%A0%BC%E8%B0%83%E8%89%B2%E6%80%9D%E8%B7%AF/%E6%97%A5%E7%B3%BB2.jpg" alt></p>
<p>第二掌拍摄的时候并没有想好，只是拍摄第一张的过程中偶然拍摄的，所以整体效果是后期自己决定的，主题颜色是绿色，所以整体颜色也向中性偏冷靠近，这张拍摄的时候就很亮了，取景布局也很好，不需要改动结果只需要简单的增加绿色明度，纯度去增强画面主体(由于是近景所以画面整体性和谐就略等于主体+背景)，略微增加高光阴影，降低黑色色阶，增加背景和主体的对比。最后略微降低色温和色调，制造偏色即可。</p>
<p><img src="/2020/04/09/%E6%97%A5%E7%B3%BB%E9%A3%8E%E6%A0%BC%E8%B0%83%E8%89%B2%E6%80%9D%E8%B7%AF/%E6%97%A5%E7%B3%BB3.jpg" alt></p>
]]></content>
      <categories>
        <category>摄影</category>
      </categories>
      <tags>
        <tag>后期</tag>
        <tag>随笔</tag>
        <tag>调色</tag>
        <tag>摄影</tag>
      </tags>
  </entry>
  <entry>
    <title>青春向左</title>
    <url>/2019/11/03/%E9%9D%92%E6%98%A5%E5%90%91%E5%B7%A6/</url>
    <content><![CDATA[<h2 id="青春向左"><a href="#青春向左" class="headerlink" title="青春向左"></a>青春向左</h2><p align="right"><font color="#ccc" size="4"><em>——记五月天上海演唱会和零碎的情绪</em></font>

</p><h4 id="一次久别重逢"><a href="#一次久别重逢" class="headerlink" title="一次久别重逢"></a>一次久别重逢</h4><p><img src="/2019/11/03/%E9%9D%92%E6%98%A5%E5%90%91%E5%B7%A6/%E6%BC%94%E5%94%B1%E4%BC%9A.jpg" alt></p>
<p>2019年11月1日 ，上海虹桥体育场。</p>
<p>18：40</p>
<p>演唱会七点开始,我坐在座位上一边听着告五人的热场一边和有事没来的朋友发着消息，时不时听到周围略显兴奋的谈论和打闹，大家都在共同的期待着什么。</p>
<p>19：00</p>
<p>吵闹中灯光突然暗了下来，两秒中的停顿之后，耳边响起了熟悉的音乐，大家都兴奋的叫了起来。看着期待中的身影渐渐出现，我心里突然有些复杂的情绪交错在一起，既有看到他们的兴奋，也有对演唱会的期待，还有一种难以言说的感慨，就像是久别的老友，大家经历着各自的人生，有着不同的际遇，但在一个阳光昏黄温暖的傍晚，在一个临街的咖啡厅里大家又坐在了一起，相视一笑</p>
<p>嘿，你们…</p>
<p>好久不见</p>
<p>22：00</p>
<p>随着最后的鞠躬和致谢，演唱会还是结束了，我站起身不紧不慢的走向出口，看着三三两两走过的身影想着他们中或千里迢迢或省吃俭用都只为了加入一场三四个小时的聚会，和周围的人一起，听着五月天的歌声然后回忆着各自的故事。临到出口的时候，我转过头再看了一眼舞台，想起阿信最后疲惫的样子和有些沙哑的声音，有些心疼</p>
<p>原来</p>
<p>五月天也二十岁了</p>
<h4 id="五月天的故事"><a href="#五月天的故事" class="headerlink" title="五月天的故事"></a>五月天的故事</h4><p><img src="/2019/11/03/%E9%9D%92%E6%98%A5%E5%90%91%E5%B7%A6/%E4%B8%83%E5%8F%B7%E5%85%AC%E5%9B%AD.jpg" alt></p>
<p><strong>我们是！五月天</strong></p>
<p>1997年，破蛋的五月天和二十岁的团员们像所有的年轻人一样，有无数多的困惑，迷茫和悲伤</p>
<p>嘴上说着爱情万岁但歌词里面尽是一夜欢愉</p>
<p>想要对你温柔但最后还是决定还你自由</p>
<p>以为爱情纯真但怎么故事三个人</p>
<p>也像所有的年轻人一样，哭完了丧完了再起来战斗，去干翻这个操蛋的世界</p>
<p>不知道明天在哪未来何去，反正人生海海，潮落之后一定有潮起</p>
<p>故事落尽孤独一人，就别埋头吃饭让我们一起终结孤单</p>
<p>在世界尽头无人记得但感动永远在，再吃一颗苹果吧</p>
<p><img src="/2019/11/03/%E9%9D%92%E6%98%A5%E5%90%91%E5%B7%A6/%E4%BA%BA%E7%94%9F%E6%B5%B7%E6%B5%B7.jpg" alt></p>
<p>他们是五月天，也是五个不知所措，迷茫又满是憧憬的年轻人，如果能坐着时光机去二十岁的他们的话，我想，会得到和我们一样回答……</p>
<p>未来怎样？</p>
<p>不知道呢</p>
<p>所以，然后呢？</p>
<p>一起走吧</p>
<p><strong>苍狗白云</strong></p>
<p>2017年，这一年五月天二十岁了，团员们也年过四十。一年前出了第九章专辑——《自传》，听完专辑之后有人说五月天变了少了活力，青春和梦想，不如蓝三，你们的热血呢？不甘呢？奋斗呢？你们可是五月天啊！</p>
<p>如果二十年前的五月天听到小九的时候可能也会是这种感觉吧，这张专辑里面充满了回忆，释然和告别。好像和我们记忆中的五月天背道而驰，他们变了吗？</p>
<p>我想是的。但我很喜欢，因为一首歌曲一张专辑本就是他们自己人生的剪影和思绪的结晶，二十年了，他们经历过为梦想奔走的疲惫和迷茫，因为服役带来的离散和不安，获奖但是不被认可的苦涩和委屈，也有鸟巢的十万人演唱会，妻女家人的温馨，终于获得的最佳作词人。</p>
<p><img src="/2019/11/03/%E9%9D%92%E6%98%A5%E5%90%91%E5%B7%A6/%E8%87%AA%E4%BC%A0.png" alt></p>
<p>人生海海，白云苍狗，他们写了顽固，去感谢那个从不曾放弃的自己。写了转眼去安静释然的回忆过去，准备未来的离别。写了少年他的奇幻漂流描绘人心善恶。写了任意门和兄弟去回忆和感谢二十年一直陪伴的团员。也写了派对动物，人生有限公司对生活的喧闹和反抗。他们其实从不曾放弃朝气和梦想，只是多了对生活的温柔和释然。这是五月天的二十岁，团员们的四十岁，如果这也是我的四十岁，那很让我心向往之。</p>
<p>这是他们的自传</p>
<p>也是我们</p>
<p>后青春期的诗</p>
<h4 id="生活向右"><a href="#生活向右" class="headerlink" title="生活向右"></a>生活向右</h4><p>不知道为什么看完演唱会之后时常会多一些无端的情绪，会想起以前经历过的事，曾经并肩的人，那些遗憾和后悔，也会想到现在不安的生活，要到来的离别，一些迷茫和无助。或者是未来的计划，想要去的地方和可能遇见的人，淡淡的憧憬和希望。有时候觉得自己矫情，又有时候自己像个小老头，可能这就是二十岁的我们吧，绝望着迷茫着悲伤有彷徨，但也努力的快乐和憧憬。</p>
<p><img src="/2019/11/03/%E9%9D%92%E6%98%A5%E5%90%91%E5%B7%A6/logo.png" alt></p>
<p>整理完所有东西之后，我走到阳台透了一口气。这个时候的小区一片漆黑，看着不远处街边昏黄的路灯，时不时驶过的汽车，还有耳边时不时传来的虫鸣和空气中的淡淡花香。突然有种淡淡的幸福感，我很喜欢这一刻，静谧，美好而永恒。过了一会，一阵凉风吹过。看看手表，凌晨一点了。我走回了房间，把思绪都一一封存起来。因为第二天，要开始了。</p>
<p>青春向左</p>
<p>但</p>
<p>生活向右</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>五月天</tag>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello Ships</title>
    <url>/2019/10/06/HelloShips/</url>
    <content><![CDATA[<h1 id="Hello-Ships"><a href="#Hello-Ships" class="headerlink" title="Hello Ships"></a>Hello Ships</h1><p>折腾了两天，终于把这个博客搭起来了，感谢过程中给我帮助的文字和人儿们</p>
<p>第一次输入完localhost:4000看到生成的页面，突然有种很复杂的恍惚，就像是在海上常年冲浪的人找到了一个小岛，然后得到了一个海螺</p>
<p>至此,</p>
<p>这个海边独居的人可以把自己的思绪写成旋律</p>
<p>吹进海螺里  </p>
<p>偶尔有路过的航船听到</p>
<p>鸣笛致意</p>
<p>大家相视一笑</p>
<p>挥挥手 </p>
<p>然后各自离开</p>
<p>奔赴下一场相遇</p>
<p>我很喜欢这种感觉</p>
<p>Hello Ships~</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
        <tag>Hello Ships</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6语法总结(三)</title>
    <url>/2020/01/05/ES6%E8%AF%AD%E6%B3%95%E6%80%BB%E7%BB%93%E4%B8%89(%E8%A7%A3%E6%9E%84%E3%80%81Set%E5%92%8CMap)/</url>
    <content><![CDATA[<h1 id="ES6语法总结"><a href="#ES6语法总结" class="headerlink" title="ES6语法总结"></a>ES6语法总结</h1><h2 id="解构"><a href="#解构" class="headerlink" title="解构"></a>解构</h2><h3 id="作用"><a href="#作用" class="headerlink" title="作用:"></a>作用:</h3><p>从对象或数组中获取信息、并将特定数据存入本地变量</p>
<h3 id="对象解构："><a href="#对象解构：" class="headerlink" title="对象解构："></a>对象解构：</h3><ul>
<li><p><strong>简单的解构</strong>:先从一段代码说起</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> man = &#123;</span><br><span class="line">age: <span class="string">"23"</span>,</span><br><span class="line">name: <span class="string">"zhoushuang"</span></span><br><span class="line">&#125;,</span><br><span class="line">age: <span class="string">"24"</span>,</span><br><span class="line">name = <span class="string">"zs"</span>;</span><br><span class="line"><span class="comment">// 使用解构来分配不同的值</span></span><br><span class="line">(&#123; age, name &#125; = man);<span class="comment">//解构表达式</span></span><br><span class="line"><span class="built_in">console</span>.log(age); <span class="comment">// "23"</span></span><br><span class="line"><span class="built_in">console</span>.log(name); <span class="comment">// "zhoushuang"</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>在这个例子中 age与 name 属性在声明时被初始化，而两个同名变量也被声明并初始化为不同的值。接下来一行使用了解构表达式，通过读取 man对象来更改这两个变量的值。在这里必须用<strong>圆括号包裹解构赋值语句</strong>，这是因为暴露的花括号会被解析为代码块语句，而块语句不允许在赋值操作符左侧出现。圆括号标示了里面的花括号并不是块语句、而应该被解释为表达式，从而允许完成赋值操作。                </p>
</li>
<li><p><strong>设置默认值</strong>:同上代码中的赋值语句改成</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(&#123; age, name,<span class="attr">type</span>:<span class="string">'handsome'</span> &#125; = man);<span class="comment">//解构表达式+默认值</span></span><br></pre></td></tr></table></figure>

<p>在赋值的时候由于man对象中并没有名为type的属性所以会使用默认值同时要注意的是凡是在解构赋值在声明构造器中查找不到同名属性时都会变成undefined</p>
</li>
<li><p><strong>赋值给本地变量名</strong>：依旧是第一段代码的赋值语句改成</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; <span class="attr">age</span>: manage, <span class="attr">name</span>: manname=<span class="string">'zs'</span> &#125; = man;<span class="comment">//解构表达式+默认值+赋值给本地变量</span></span><br></pre></td></tr></table></figure>

<p>这样的话man里面的age和name属性分别对自定义的manage,manname进行了赋值操作， 该语法实际上与传统对象字面量语法相反，传统语法将名称放在冒号左边、值放在冒号右边；而在本例中，<strong>名称在右边，需要进行值读取的位置被放在了左边。</strong></p>
</li>
<li><p><strong>解构嵌套对象</strong>:</p>
<ul>
<li><strong>简单用法</strong>：在日常开发中有时候会出现我们拿到的数据是一个多层嵌套的对象，而我们只需要获取其中的某些项的情况，这时自己写方法去遍历对象会比较麻烦，这个时候使用解构赋值会节省很多时间:</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> man = &#123;</span><br><span class="line">name: <span class="string">"zhoushuang"</span>,</span><br><span class="line">type: &#123;</span><br><span class="line">habit: &#123;</span><br><span class="line">sleep: <span class="literal">true</span>,</span><br><span class="line">eating: <span class="literal">true</span></span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">type</span>: &#123; habit &#125;&#125; = man;<span class="comment">//嵌套解构赋值</span></span><br><span class="line"><span class="built_in">console</span>.log(habit.sleep); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(habit.eating); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>在赋值结构中每当有一个冒号出现，就意味着冒号之前的标识符代表需要检查的位置，而冒号右侧则是赋值的目标。当冒号右侧存在花括号时，表示目标被嵌套在对象的更深一层中，因此<code>{ type: { habit }} = man</code>的运行顺序应该是:man-&gt;寻找type属性-&gt; type属性需找habit属性-&gt;进行操作，每一个{}都可以简单的理解成又进行了一次简单解构赋值而这次的数据源就来自于冒号左边</p>
<ul>
<li><p>赋值给本地变量名**:同上一行代码中的赋值语句改成</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; <span class="attr">type</span>: &#123; <span class="attr">habit</span>:manHabit &#125;&#125; = man;<span class="comment">//嵌套解构赋值+赋值给本地变量</span></span><br></pre></td></tr></table></figure>

<p>其实和简单赋值的形式一样把habit整个对象都赋值给了本地变量manHabit不赘述</p>
</li>
</ul>
</li>
</ul>
<h3 id="数组解构"><a href="#数组解构" class="headerlink" title="数组解构"></a>数组解构</h3><p>总体来说数组解构赋值和对象解构赋值非常的相似，因此在此也只介绍数组解构的不同之处,其他情况参考上文。</p>
<ul>
<li><p><strong>简单解构赋值</strong>:与对象相比语法不同’{}‘-&gt;’[]‘，并且在运行的时候不是查找同名属性而是直接按照参数的顺序进行赋值</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [ <span class="string">"red"</span>, <span class="string">"green"</span>, <span class="string">"blue"</span> ];</span><br><span class="line"><span class="keyword">let</span> [ first, second ] = colors;</span><br><span class="line"><span class="built_in">console</span>.log(first); <span class="comment">// "red"</span></span><br><span class="line"><span class="built_in">console</span>.log(second); <span class="comment">// "green"</span></span><br></pre></td></tr></table></figure>

<p>在以上代码中能看到first和second分别获取了colors数组中的第一和第二个而这是根据参数各自的位置决定的，所以我们也可以使用占位符<code>，</code>来给获取指定的数据</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [,second ] = colors;</span><br><span class="line"><span class="built_in">console</span>.log(second); <span class="comment">// "green"</span></span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>默认值:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">let [ first, second= <span class="string">"pink"</span> ] = colors;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数交换:在ES6中可以运用解构赋值进行参数交换而无需中间变量</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span>,</span><br><span class="line">b = <span class="number">2</span>;</span><br><span class="line">[ a, b ] = [ b, a ];</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>嵌套解构:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [ <span class="string">"red"</span>, [ <span class="string">"green"</span>, <span class="string">"lightgreen"</span> ], <span class="string">"blue"</span> ];</span><br><span class="line"><span class="comment">// 随后</span></span><br><span class="line"><span class="keyword">let</span> [ firstColor, [ secondColor ] ] = colors;</span><br><span class="line"><span class="built_in">console</span>.log(firstColor); <span class="comment">// "red"</span></span><br><span class="line"><span class="built_in">console</span>.log(secondColor); <span class="comment">// "green"</span></span><br></pre></td></tr></table></figure>

<p>和对象嵌套时的原理一样,只不过在数组中不是根据属性名来查找而是根据参数的位置查找的,所以<code>[ firstColor, [ secondColor ] ] = colors;</code>也相当于进行了两次解构赋值操作,第一次<code>firstColor=red；[ secondColor ]= [ &quot;green&quot;, &quot;lightgreen&quot; ]</code> ，第二次<code>secondColor =green</code></p>
</li>
</ul>
<p>需要注意的是在数组解构的时候如果有嵌套解构的情况但是对应的数据源只要不是可转成数组的值都会报错，如果可以转成数组会先将其转化成数组在进行赋值:</p>
<p><img src="/2020/01/05/ES6%E8%AF%AD%E6%B3%95%E6%80%BB%E7%BB%93%E4%B8%89(%E8%A7%A3%E6%9E%84%E3%80%81Set%E5%92%8CMap)/%E6%95%B0%E7%BB%84%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC.png" alt></p>
<ul>
<li><p>剩余项赋值:因为数组中有arguments对象所以在数组解构中也可以使用</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [ <span class="string">"red"</span>, <span class="string">"green"</span>, <span class="string">"blue"</span> ];</span><br><span class="line"><span class="keyword">let</span> [ firstColor, ...restColors ] = colors;</span><br><span class="line"><span class="built_in">console</span>.log(firstColor); <span class="comment">// "red"</span></span><br><span class="line"><span class="built_in">console</span>.log(restColors.length); <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(restColors[<span class="number">0</span>]); <span class="comment">// "green"</span></span><br><span class="line"><span class="built_in">console</span>.log(restColors[<span class="number">1</span>]); <span class="comment">// "blue"</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="混合解构-对象-数组"><a href="#混合解构-对象-数组" class="headerlink" title="混合解构(对象+数组)"></a>混合解构(对象+数组)</h2><p>这里其实就是把数组解构和对象解构的语法组合起来，只要注意逻辑和语法就行了，混合结构对于JSON格式的数据获取很有帮助</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> node = &#123;</span><br><span class="line">type: <span class="string">"Identifier"</span>,</span><br><span class="line">name: <span class="string">"foo"</span>,</span><br><span class="line">loc: &#123;</span><br><span class="line">start: &#123;</span><br><span class="line">line: <span class="number">1</span>,</span><br><span class="line">column: <span class="number">1</span></span><br><span class="line">&#125;,</span><br><span class="line">end: &#123;</span><br><span class="line">line: <span class="number">1</span>,</span><br><span class="line">column: <span class="number">4</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line">range: [<span class="number">0</span>, <span class="number">3</span>]</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> &#123;</span><br><span class="line">loc: &#123; start &#125;,</span><br><span class="line">range: [ startIndex ]</span><br><span class="line">&#125; = node;</span><br><span class="line"><span class="built_in">console</span>.log(start.line); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(start.column); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(startIndex); <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>

<h2 id="Set和Map"><a href="#Set和Map" class="headerlink" title="Set和Map"></a>Set和Map</h2><h3 id="Set-无重复值的有序列表"><a href="#Set-无重复值的有序列表" class="headerlink" title="Set(无重复值的有序列表)"></a>Set(无重复值的有序列表)</h3><ul>
<li><p><strong>创建set并添加内容</strong>：</p>
<p>使用new来创建，add方法添加项目</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">set</span> = new Set();</span><br><span class="line"><span class="keyword">set</span>.add(5);</span><br><span class="line"><span class="keyword">set</span>.add("5");</span><br><span class="line">console.log(<span class="keyword">set</span>.size); // 2</span><br></pre></td></tr></table></figure>

<p>Set 不会使用强制类型转换来判断值是否重复。这意味着 Set 可以同时包含数值 5 与 字符串 “5” ，将它们都作为相对独立的项,因为这里使用的是Object.is() 方法，来判断两个值是否相等，唯一的例外是 +0 与 -0 在 Set 中被判断为是相等的）。你还可以向 Set 添加多个对象，它们也不会被合并为同一项</p>
</li>
<li><p><strong>Set.has()</strong>：用来搜索目标set中是否存在某一项，并返回结果(true/false)</p>
</li>
<li><p><strong>Set.delete()</strong>:用来删除目标set中的某一项，并返回结果(true/false)</p>
</li>
<li><p><strong>Set.clear()</strong>:用来删除目标set中的某一项，无返回</p>
</li>
<li><p><strong>Set 转换为数组</strong>：将数组转换为 Set 相当容易，因为可以将数组传递给 Set 构造器；而使用扩展运算符也能简<br>单地将 Set 转换回数组</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">set</span> = new Set([1, 2, 3, 3, 3, 4, 5]),</span><br><span class="line">array = [...<span class="keyword">set</span>];</span><br><span class="line">console.log(array); // [1,2,3,4,5]</span><br></pre></td></tr></table></figure>
</li>
<li><p>Weak Set：</p>
<p>在以上转化数组的时候仔细观察就能发现，使用set转换数组时只是将set中的内容复制给了一个array而已，原set的内容中依旧还存在，对象存储在 Set 的一个实例中时，实际上相当于把对象存储在变量中。只要对于 Set 实例的引用仍然存在，所存储的对象就无法被垃圾回收机制回收，从而无法释放内存，所以为了解决这个问题也就引入了Weak Set</p>
<ul>
<li><p>创建 Weak Set:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">set</span> = new WeakSet(),</span><br><span class="line">key = &#123;&#125;;</span><br><span class="line"><span class="comment">// 将对象加入 set</span></span><br><span class="line"><span class="keyword">set</span>.add(key);</span><br><span class="line">console.log(<span class="keyword">set</span>.has(key)); // true</span><br><span class="line"><span class="keyword">set</span>.delete(key);</span><br><span class="line">console.log(<span class="keyword">set</span>.has(key)); // false</span><br></pre></td></tr></table></figure>

<p>Weak Set 使用 WeakSet 构造器来创建，同时也包含了 add() 、 has()和 delete(),没有clear，该类型只允许存储对象弱引用，而不能存储基本类型的值。对象的弱引用在它自己成为该对象的唯一引用时，不会阻止垃圾回收，</p>
</li>
<li><p>Set 类型之间的关键差异：</p>
<ul>
<li>对于 WeakSet 的实例，若调用 add() 方法时传入了非对象的参数，就会抛出错误（has() 或 delete() 则会在传入了非对象的参数时返回 false ）；</li>
</ul>
<ol start="2">
<li>Weak Set 不可迭代，因此不能被用在 for-of 循环中；</li>
</ol>
<ul>
<li>Weak Set 无法暴露出任何迭代器（例如 keys() 与 values() 方法），因此没有任何编程手段可用于判断 Weak Set 的内容；</li>
</ul>
<ol start="4">
<li>Weak Set 没有 forEach() 方法；</li>
<li>Weak Set 没有 size 属性。</li>
</ol>
</li>
</ul>
</li>
</ul>
<h3 id="Map-键值对有序列表"><a href="#Map-键值对有序列表" class="headerlink" title="Map(键值对有序列表)"></a>Map(键值对有序列表)</h3><p>Map中的数据以键值对的形式存在,而键和值都可以是任意类型。键的比较使用的是Object.is() ，因此你能将 5 与 “5” 同时作为键，因为它们类型不同。这与使用对象属性作为键的方式（指的是用对象来模拟 Map ）截然不同，因为对象的属性会被强制转换为字符串。</p>
<ul>
<li><p><strong>Map方法</strong>：</p>
<ul>
<li>get(),set():调用 set() 方法并给它传递一个键与一个关联的值，来给 Map 添加项；此后使用键<br>名来调用 get() 方法便能提取对应的值</li>
<li>has(key) ：判断指定的键是否存在于 Map 中；</li>
<li>delete(key) ：移除 Map 中的键以及对应的值；</li>
<li>clear() ：移除 Map 中所有的键与值。</li>
</ul>
</li>
<li><p><strong>Weak Map</strong>:</p>
<p>WeakMap 类型是键值对的无序列表，其中键必须是非空的对象，值则允许是任意类型。 WeakMap 的接口与 Map 的非常相似，都使用 set() 与 get() 方法来分别添加与提取数据</p>
<ul>
<li><strong>Weak Map 的初始化</strong><br>为了初始化 Weak Map ，需要把一个由数组构成的数组传递给 WeakMap 构造器。就像正规Map 构造器那样，每个内部数组都应当有两个项，第一项是作为键的非空的对象，第二项则是对应的值（任意类型）</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> key1 = &#123;&#125;,</span><br><span class="line">key2 = &#123;&#125;,</span><br><span class="line">map = <span class="keyword">new</span> <span class="built_in">WeakMap</span>([[key1, <span class="string">"Hello"</span>], [key2, <span class="number">42</span>]]);</span><br><span class="line"><span class="built_in">console</span>.log(map.has(key1)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(map.get(key1)); <span class="comment">// "Hello"</span></span><br><span class="line"><span class="built_in">console</span>.log(map.has(key2)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(map.get(key2)); <span class="comment">// 42</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>Weak Map 的方法</p>
<p>has() 方法用于判断指定的键是否存在 delete() 方法则用于移除一个特定的键值对。</p>
</li>
</ul>
</li>
<li><p>Weak Map 的用法与局限性</p>
<p>如果你只想使用对象类型的键。最好的选择就是 Weak Map 。因为它能确保额外数据在不再可用后被销毁，从而能优化内存使用并规避内存泄漏。但是 Weak Map 只为它们的内容提供了很小的可见度，因此不能使用 forEach() 方法、size 属性或 clear() 方法来管理其中的项。而在除此之外的其他情况，正常 Map是更好的选择，只是要注意对内存的使用。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6语法总结(四)</title>
    <url>/2020/01/20/ES6%E8%AF%AD%E6%B3%95%E6%80%BB%E7%BB%93%E5%9B%9B(%E8%BF%AD%E4%BB%A3%E7%94%9F%E6%88%90%E5%99%A8%E3%80%81Promise%E5%92%8C%E5%BC%82%E6%AD%A5)/</url>
    <content><![CDATA[<h1 id="ES6语法总结"><a href="#ES6语法总结" class="headerlink" title="ES6语法总结"></a>ES6语法总结</h1><h2 id="Promise与异步"><a href="#Promise与异步" class="headerlink" title="Promise与异步"></a>Promise与异步</h2><h3 id="Promise诞生的原因"><a href="#Promise诞生的原因" class="headerlink" title="Promise诞生的原因"></a>Promise诞生的原因</h3><p>前端和后端各种多样化交互才使各种程序拥有了使用的实际价值，而前后端交互绝大部分都属于异步编程，所以了解异步是对于前端来说是异常重要的一步，接下来先看一下传统的异步</p>
<ul>
<li><p><strong>传统的异步</strong>：</p>
<ul>
<li>事件模型</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> button = <span class="built_in">document</span>.getElementById(<span class="string">"btn"</span>);</span><br><span class="line">    button.onclick = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Clicked"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>在这段代码中就是事件模型的一种，给id为<code>btn</code>的dom元素绑定了一个点击方法，但是它只会被编译而不会被执行，只有当该元素被点击之后才会js引擎才会把click的方法加入到作业队列的末尾，而所有类似这种绑定特定事件只有在特定条件下才会执行的模式叫做事件模式，这也是异步的一种。</p>
<ul>
<li>问题：对于这种模式来说当需要简单的交互时简单好用但是又两个问题<ul>
<li>每一个事件模型都需要追踪事件对象，有一百个点击事件就要监控一百个对象很麻烦</li>
<li>未必能够完成绑定因为也可能绑定事件的时候dom还不存在</li>
</ul>
</li>
<li>回调模式</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">readFile(<span class="string">"example.txt"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, contents</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">   		 <span class="keyword">throw</span> err;</span><br><span class="line">   	 &#125;</span><br><span class="line">   		<span class="built_in">console</span>.log(contents);</span><br><span class="line">   &#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"Hi!"</span>);</span><br></pre></td></tr></table></figure>

<p><code>readFile()</code> 函数用于读取磁盘中的文件（由第一个参数指定），并在读取完毕后执行回调函数（即第二个参数）。如果存在错误，回调函数的 err 参数会是一个错误对象；否则 contents 参数就会以字符串形式包含文件内容。使用回调函数模式， <code>readFile()</code> 会立即开始执行，并在开始读取磁盘时暂停。这意味着<code>console.log(&quot;Hi!&quot;)</code>会在 <code>readFile()</code> 被调用后立即进行输出，要早于<code>console.log(contents)</code>的打印操作。当 <code>readFile()</code>结束操作后，它会将回调函数以及相关参数作为一个新的作业添加到作业队列的尾部。在之前的作业全部结束后，该作业才会执行,在这种情况下如果要进行异步串联就容易得多，但是会出现<strong>回调地狱</strong>的情况</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">method1(<span class="function"><span class="keyword">function</span>(<span class="params">err, result</span>) </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (err) &#123;</span><br><span class="line">         <span class="keyword">throw</span> err</span><br><span class="line">       	 &#125;</span><br><span class="line">       method2(<span class="function"><span class="keyword">function</span>(<span class="params">err, result</span>) </span>&#123;</span><br><span class="line">         <span class="keyword">if</span> (err) &#123;</span><br><span class="line">           <span class="keyword">throw</span> err</span><br><span class="line">         &#125;</span><br><span class="line">         method3(<span class="function"><span class="keyword">function</span>(<span class="params">err, result</span>) </span>&#123;</span><br><span class="line">           <span class="keyword">if</span> (err) &#123;</span><br><span class="line">             <span class="keyword">throw</span> err</span><br><span class="line">           &#125;</span><br><span class="line">           method4(<span class="function"><span class="keyword">function</span>(<span class="params">err, result</span>) </span>&#123;</span><br><span class="line">             <span class="keyword">if</span> (err) &#123;</span><br><span class="line">               <span class="keyword">throw</span> err</span><br><span class="line">             &#125;</span><br><span class="line">             method5(result)</span><br><span class="line">           &#125;)</span><br><span class="line">         &#125;)</span><br><span class="line">       &#125;)</span><br><span class="line">     &#125;)</span><br></pre></td></tr></table></figure>

<p>​    是不是看了就很想死…不但代码复杂高度耦合而且当你需要两个异步并行操作或者想同时开始两个异步的时候就    特别麻烦了，所以才有了Promise</p>
<ul>
<li><h3 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h3><h4 id="Promise-生命周期"><a href="#Promise-生命周期" class="headerlink" title="Promise 生命周期"></a>Promise 生命周期</h4><p><img src="/2020/01/20/ES6%E8%AF%AD%E6%B3%95%E6%80%BB%E7%BB%93%E5%9B%9B(%E8%BF%AD%E4%BB%A3%E7%94%9F%E6%88%90%E5%99%A8%E3%80%81Promise%E5%92%8C%E5%BC%82%E6%AD%A5)/Promise%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" alt="1585030576405"></p>
<p>在这里把几个意思都解释一下：</p>
<ol>
<li>程序整体状态：<ul>
<li>unsettled(未决):就是挂起状态，但是这个状态是用来描述程序的整体状况</li>
<li>settled(已决):程序已经执行完成</li>
<li>resolve(决议):推进为程序执行状态为已决</li>
</ul>
</li>
<li>程序具体状态:<ul>
<li>pending(挂起):异步程序尚未结束，等待结果中</li>
<li>fulfilled(完成):异步程序结束，操作完成</li>
<li>rejected(拒绝):异步程序结束，操作失败</li>
</ul>
</li>
<li>推进状态操作函数<ul>
<li>resolve():调用resolve()更改程序状态为已完成</li>
<li>reject():调用resolve()更改程序状态为已失败</li>
</ul>
</li>
<li>状态完成函数<ul>
<li>fulfillment handler:成功决议之后调用的函数</li>
<li>rejection handler :失败之后调用的函数</li>
</ul>
</li>
</ol>
<p>在以上描述中描述程序具体状态的值会被设置在Promise对象的<code>PromiseState</code>属性中但是这个属性没有暴露所以不能访问，因此才需要<code>.then()</code>方法来对Promise的不同情况进行想要的操作</p>
<p><strong>then()方法</strong>：</p>
<p>​    在Promise状态为settled的时候会被调用，接收两个可选参数（都是回调函数的形式）,第一个是成功的回调函数，第二个是失败的回调函数，在失败的时候会默认传递一个包含有错误信息的对象进去。</p>
<p><strong>catch()方法</strong>:</p>
<p>​     在这里的<code>promise.catch(function...)</code>&lt;=&gt;<code>promise.then(null,function..)</code>,默认传递rejection handler</p>
</li>
</ul>
<p>​            <strong>当没有写入都有的错误都会静默发生所以最好给promise都写一个默认的日志</strong></p>
<h4 id="创建Promise"><a href="#创建Promise" class="headerlink" title="创建Promise"></a>创建Promise</h4><h5 id="创建未决Promise"><a href="#创建未决Promise" class="headerlink" title="创建未决Promise"></a>创建未决Promise</h5><p>​    使用 Promise 构造器来创建。此构造器接受单个参数：执行器(executor)函数，包含初始化 Promise 的代码。该执行器会被传递两个名为 resolve()与 reject() 的函数作为参数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"啊啊啊"</span>);</span><br><span class="line">    resolve();</span><br><span class="line">    <span class="keyword">if</span>(err)&#123;</span><br><span class="line">       reject();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"哦哦哦"</span>);</span><br><span class="line"><span class="comment">//啊啊啊</span></span><br><span class="line"><span class="comment">//哦哦哦</span></span><br></pre></td></tr></table></figure>

<p>​    构造器会在promise实例化的时候立刻执行。然后才会发生而里面 resolve() 或 reject() 在执行器内部被调用          时，一个作业被添加到作业队列中，以便决议（ resolve ）这个 Promise 。这也称为作业调度( job scheduling )，要注意一下被调度的作业会被放到队列的末尾最后执行</p>
<h5 id="创建已决Promise"><a href="#创建已决Promise" class="headerlink" title="创建已决Promise"></a>创建已决Promise</h5><p>​    Promise.resolve()和Promise.reject()的使用方式一样的所以只列举一个，另外一个照搬就行了</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = <span class="built_in">Promise</span>.resolve(<span class="number">42</span>);</span><br><span class="line">    promise.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value); <span class="comment">// 42</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>​    接受单个参数并返回一个处于完成态的 Promise 。没有任何作业调度会发生，并且需要向 Promise 添加一个或更多的完成处理函数来提取这个参数值。</p>
<h5 id="执行器错误"><a href="#执行器错误" class="headerlink" title="执行器错误"></a>执行器错误</h5><p>​    如果在执行器内部抛出了错误， Promise 的拒绝处理函数就会被调用，如果没有错误就会静默</p>
<p>#####全局的 Promise 拒绝处理</p>
<p>​    Promise有一个问题就是报错静默：当没有指定报错处理时发生的所有错误都不会被暴露和抛出而且你没有什么直观的办法去判断Promise的处理结果，而且你也不知道一个Promise对象什么时候会被处理</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> rejected = <span class="built_in">Promise</span>.reject(<span class="number">42</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一段时间后……</span></span><br><span class="line">	rejected.catch(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line"><span class="comment">// rejected 被处理</span></span><br><span class="line">	<span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>​    但是不用担心浏览器已经有了解决方案：</p>
<p>​    <strong>浏览器的拒绝处理</strong>：</p>
<p>当有有未处理的拒绝 时window 对象会触发两个事件：            </p>
<blockquote>
<p><code>unhandledrejection</code> ：当一个 Promise 被拒绝、而在事件循环的一个轮次中没有任何拒绝处理函数被调用，该事件就会被触发；<br><code>rejectionHandled</code> ：若一个 Promise 被拒绝、并在事件循环的一个轮次之后再有拒绝处理函数被调用，该事件就会被触发。</p>
</blockquote>
<p>以上两个浏览器事件的处理函数会接收到含下列属性的一个对象：</p>
<blockquote>
<p>type ： 事件的名称（ “unhandledrejection” 或 “rejectionhandled” ）；<br>promise ：被拒绝的 Promise 对象；<br>reason ： Promise 中的拒绝值（拒绝原因）。</p>
</blockquote>
<h4 id="串联-Promise-Promise链"><a href="#串联-Promise-Promise链" class="headerlink" title="串联 Promise(Promise链)"></a>串联 Promise(Promise链)</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">	resolve(<span class="number">42</span>);</span><br><span class="line">&#125;);</span><br><span class="line">p1.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(value);</span><br><span class="line">	&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">"Finished"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>对 p1.then() 的调用返回了第二个 Promise ，又在这之上调用了 then() 。仅当第一个Promise 已被决议后，第二个 then() 的完成处理函数才会被调用,每一次的加入作业队列时都会新生成一个promise</p>
<ul>
<li><p><strong>捕获错误</strong></p>
<ul>
<li>Promise 链允许捕获上一个 Promise 的完成或拒绝处理函数中发生的错误</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">	resolve(<span class="number">42</span>);</span><br><span class="line">&#125;);</span><br><span class="line">p1.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"Boom!"</span>);</span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(error.message); <span class="comment">// "Boom!"</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>在以上代码中， p1 的完成处理函数抛出了一个错误，链式调用指向了第二个 Promise 上的catch() 方法，能通过此拒绝处理函数接收前面的错误，前面如果是拒绝函数的话也是一样的。</p>
</li>
<li><p>在 Promise 链中返回值</p>
<p>Promise 链的另一重要方面是能从一个 Promise 传递数据给下一个 Promise 的能力。传递给<br>执行器中的 resolve() 处理函数的参数，会被传递给对应 Promise 的完成处理函数，</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">	resolve(<span class="number">42</span>);</span><br><span class="line">&#125;);</span><br><span class="line">p1.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(value); <span class="comment">// "42"</span></span><br><span class="line">		<span class="keyword">return</span> value + <span class="number">1</span>;</span><br><span class="line">	&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(value); <span class="comment">// "43"</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>p1 的完成处理函数在被执行时返回了 value + 1 。由于 value 的值为 42 （来自执行<br>器），此完成处理函数就返回了 43 。这个值随后被传递给第二个 Promise 的完成处理函数，</p>
</li>
<li><p>在 Promise 链中返回 Promise</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">	resolve(<span class="number">42</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">	resolve(<span class="number">43</span>);</span><br><span class="line">&#125;);</span><br><span class="line">p1.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">		<span class="comment">// 第一个完成处理函数</span></span><br><span class="line">        <span class="built_in">console</span>.log(value); <span class="comment">// 42</span></span><br><span class="line">        <span class="keyword">return</span> p2;</span><br><span class="line">	&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">	<span class="comment">// 第二个完成处理函数</span></span><br><span class="line">	<span class="built_in">console</span>.log(value); <span class="comment">// 43</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>在以上例子中如果p2执行出错的话会导致第二个完成处理函数永不被调用，这是因为在promise链中每当一个promise完成后下一个promise才会被加入作业队列，并且同时会很创建一个新的promise对象获取上一个对象的数据，  因此这以上代码中存在四个promise对象也就是</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">resolve(<span class="number">42</span>);<span class="comment">//第一个</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">resolve(<span class="number">43</span>);<span class="comment">//第二个</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">let</span> p3 = p1.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line"><span class="comment">// 第一个完成处理函数</span></span><br><span class="line"><span class="built_in">console</span>.log(value); <span class="comment">// 42</span></span><br><span class="line"><span class="keyword">return</span> p2;</span><br><span class="line">&#125;);<span class="comment">//第三个</span></span><br><span class="line">	p3.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line"><span class="comment">// 第二个完成处理函数</span></span><br><span class="line"><span class="built_in">console</span>.log(value); <span class="comment">// 43</span></span><br><span class="line">&#125;);<span class="comment">//第四个对象</span></span><br></pre></td></tr></table></figure>

<p>所以当p2报错时p3应当调用的是then()方法的第二个参数也就是拒绝函数而永不调用成功函数</p>
</li>
</ul>
<h4 id="响应多个-Promise"><a href="#响应多个-Promise" class="headerlink" title="响应多个 Promise"></a>响应多个 Promise</h4><ul>
<li><strong>Promise.all()</strong>：</li>
<li><strong>Promise.race() 方法</strong>：</li>
</ul>
]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈SVG</title>
    <url>/2019/12/07/%E6%B5%85%E8%B0%88SVG/</url>
    <content><![CDATA[<h1 id="浅谈SVG"><a href="#浅谈SVG" class="headerlink" title="浅谈SVG"></a>浅谈SVG</h1><h2 id="一、SVG相关概念"><a href="#一、SVG相关概念" class="headerlink" title="一、SVG相关概念"></a>一、SVG相关概念</h2><ul>
<li><p>什么是SVG</p>
<p>svg(Scalable Vector Graphic)，是一种可缩放的矢量图形，现在就针对定义来聊聊。</p>
<ul>
<li><p>矢量图形和栅格图形</p>
<ul>
<li><p>栅格图形</p>
<p>在这种系统中，图像由一个像素数组组成，这个数组里面的每一个像素都会用图形对应位置的RGB值表示，可以认为在一个图像上划分出N个正方形小方块，每一个小方块的值都等于图像在该位置的颜色，且改颜色用RBG的形式表示</p>
</li>
<li><p>矢量图形</p>
<p>在这种系统中，图像由一组几何图形的指令组成，矢量阅读器会按照指令在对应的指标集上绘制出一系列对应的图形。可以把图像切割成了N个几何图形，每一个图形都会记录相关的坐标，坐标间的连接顺序，方法等要素从而生成完成这个图形的指令，阅读器就会根据这些指令画出一个个几何图形最后形成完整的图像</p>
<a id="more"></a></li>
</ul>
</li>
<li><p>可缩放</p>
<p>其实在上面一点我们就能很清楚的知道矢量图实际上是拿到了画图的指令所以当我们方法缩小的时候其实只是改变了背景画布的大小并不会改变指令，所以阅读器依旧能根据指令绘制出完整的图像</p>
</li>
</ul>
</li>
</ul>
<h2 id="二、SVG基本属性"><a href="#二、SVG基本属性" class="headerlink" title="二、SVG基本属性"></a>二、SVG基本属性</h2><ul>
<li><h3 id="坐标系统"><a href="#坐标系统" class="headerlink" title="坐标系统"></a>坐标系统</h3><p>坐标系统是svg的基础，只有连接坐标我们才能确定各种图形的定位和属性的值，并通过操作各类标签和坐标实现我们想要的效果</p>
<ol>
<li>视口:也就是画布的区域，默认单位为px，可选的单位有：em,ex,px,cm,mm等</li>
<li>用户默认坐标系：原点(0,0)在视口坐上角，水平坐标轴(x轴)向右递增，垂直坐标轴(y轴)向下递增</li>
<li>为视口指定坐标系(viewbox):在视口中所有单位都默认为px且使用默认坐标系统，但如果需要从新修改坐标系统的话就需要用到viewbox属性，该属性有4个值(最小x坐标，最小y坐标，宽度，高度)</li>
</ol>
</li>
<li><h3 id="图形"><a href="#图形" class="headerlink" title="图形"></a>图形</h3><ul>
<li><p>图形标签</p>
<ul>
<li>线段(line):使用<code>&lt;line&gt;</code>标签，需要制定起止点的x,y坐标，默认单位为坐标系坐标</li>
<li>矩形(rect):使用<code>&lt;revt&gt;</code>标签，需要制定左上角起始点的x,y坐标，宽度(width)和高度(height)</li>
<li>圆(circle)和椭圆(ellipse):使用<code>&lt;circle&gt;</code>标签，需要制定圆心坐标cx,cy，半径(r),若是椭圆还要制定xy的半轴长度rx,ry</li>
<li>多边形(polygon):使用<code>&lt;polygon&gt;</code>标签，这个标签可以组成任意封闭图形只要在points属性制定一系列的点的坐标并用逗号或空格分隔，会根据points各点依次连接并在最后自动重回起点</li>
<li>折线(polyline):使用<code>&lt;polyline&gt;</code>标签，这个标签基本上等同于多边形标签，但有一点不同的是它在画完最后一点时不会重回起点，所以一般用来画不封闭的图形</li>
</ul>
</li>
<li><p>图形属性：</p>
<ul>
<li><p>画笔类</p>
<ol>
<li>stroke:画笔颜色，默认none</li>
<li>stroke-width:画笔宽度，默认1</li>
<li>stroke-opacity:画笔透明度，默认1.0</li>
<li>stroke-dasharry:用一组的数字制定虚线和间隙的长度，默认none</li>
<li>stroke-linejoin:图形连接处的形状，默认miter(尖),round(圆滑),bevel(平的)</li>
</ol>
</li>
<li><p>填充类</p>
<ol>
<li>fill:制定填充颜色，默认blcak</li>
<li>fill-opacity:填充透明度，默认1.0</li>
<li>fill-rule:是否在图形内，当线段有交叉时才有效。默认nonezero</li>
</ol>
</li>
<li><p>样式类(简单来说SVG标签和HTML的样式使用方法是一样的，只是属性不同而已)</p>
<ol>
<li><p>结构:和HTML标签应用CSS类似</p>
<p><code>stroke:blue;fill:red;</code></p>
</li>
<li><p>内联样式(Style):给标签应用style属性</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;circle cx='10',cy='50',r='10' style="fill:red; stroke:blue"&gt;</span><br><span class="line">&lt;rect x='10',y='50',width='30' height='40'style="fill:red;stroke:blue" &gt;</span><br></pre></td></tr></table></figure>



</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code>3. 样式类(Class):给标签应用calss属性，所有带有同名类的标签都会应用同一样式

   <figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.special</span>&#123;</span><br><span class="line">    fill:red;</span><br><span class="line">    stroke:blue</span><br><span class="line">&#125;</span><br><span class="line">&lt;circle cx=<span class="string">'10'</span>,cy=<span class="string">'50'</span>,r=<span class="string">'10'</span> class=<span class="string">'special'</span>&gt;</span><br><span class="line">&lt;rect x=<span class="string">'10'</span>,y=<span class="string">'50'</span>,width=<span class="string">'30'</span> height=<span class="string">'40'</span> class=<span class="string">'special'</span>&gt;</span><br></pre></td></tr></table></figure></code></pre><h2 id="三、-组合与复用"><a href="#三、-组合与复用" class="headerlink" title="三、 组合与复用"></a>三、 组合与复用</h2><h4 id="lt-g-gt-标签"><a href="#lt-g-gt-标签" class="headerlink" title="&lt;g&gt;标签"></a>&lt;g&gt;标签</h4><p>​    <code>&lt;g&gt;</code>标签会把它所有的子元素都当成一个组合，每个组合都可以有自己的id，title，类似于自定义的标签，这样我们就能够很方便的复用组合好的复杂图形</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">g</span> <span class="attr">id</span>=<span class="string">'demo1'</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">circle</span> <span class="attr">cx</span>=<span class="string">'100'</span> <span class="attr">cy</span>=<span class="string">'50'</span> <span class="attr">r</span>=<span class="string">'10'</span>&gt;</span><span class="tag">&lt;/<span class="name">circle</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">polyline</span> <span class="attr">points</span>=<span class="string">'100 60,100 70,100 80,110 80,100 70'</span>&gt;</span><span class="tag">&lt;/<span class="name">polyline</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">g</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h4 id="lt-use-gt-标签"><a href="#lt-use-gt-标签" class="headerlink" title="&lt;use&gt;标签"></a>&lt;use&gt;标签</h4><p><code>&lt;use&gt;</code>元素在指定对应的值（<code>xline:href=&#39;xx&#39;</code>）后能够实现类似于复制粘贴的功能,并且需要指定定赋值的样本原点需要移动到的位置，一般和<code>&lt;g&gt;</code>组合使用</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">g</span> <span class="attr">id</span>=<span class="string">'house'</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">desc</span>&gt;</span>周家堡<span class="tag">&lt;/<span class="name">desc</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rect</span> <span class="attr">x</span>=<span class="string">"0"</span> <span class="attr">y</span>=<span class="string">"40"</span> <span class="attr">width</span>=<span class="string">"60"</span> <span class="attr">height</span>=<span class="string">"60"</span>&gt;</span><span class="tag">&lt;/<span class="name">rect</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">polyline</span> <span class="attr">points</span>=<span class="string">'0 40,30 0,60 40'</span>&gt;</span><span class="tag">&lt;/<span class="name">polyline</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">polyline</span> <span class="attr">points</span>=<span class="string">'30 100,30 70,44 70,44 100'</span>&gt;</span><span class="tag">&lt;/<span class="name">polyline</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">g</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">use</span> <span class="attr">xline:href</span>=<span class="string">'#house'</span> <span class="attr">x</span>=<span class="string">"100"</span> <span class="attr">y</span>=<span class="string">"100"</span>&gt;</span><span class="tag">&lt;/<span class="name">use</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">use</span> <span class="attr">xline:href</span>=<span class="string">'#house'</span> <span class="attr">x</span>=<span class="string">"-50"</span> <span class="attr">y</span>=<span class="string">"-50"</span>&gt;</span><span class="tag">&lt;/<span class="name">use</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="lt-defs-gt-标签"><a href="#lt-defs-gt-标签" class="headerlink" title="&lt;defs&gt;标签"></a>&lt;defs&gt;标签</h4><p>在我们使用<code>&lt;g&gt;</code>标签的时候会有一个问题就是只要定义了组合就马上会被创建,而且我们没有办法去对组合的样式进行修改，因此这样一来复用性其实不是很好，这个时候就需要使用<code>&lt;defs&gt;</code>标签，我们可以预先在该标签内写好我们想要复用的组合或者图形，他们会被定义但并不会被创建出来，只有当我们使用<code>&lt;use&gt;</code>引用时才会被创建，并且能够对模板使用样式</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">defs</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">g</span> <span class="attr">id</span>=<span class="string">'house'</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">desc</span>&gt;</span>周家堡<span class="tag">&lt;/<span class="name">desc</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rect</span> <span class="attr">x</span>=<span class="string">"0"</span> <span class="attr">y</span>=<span class="string">"40"</span> <span class="attr">width</span>=<span class="string">"60"</span> <span class="attr">height</span>=<span class="string">"60"</span>&gt;</span><span class="tag">&lt;/<span class="name">rect</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">polyline</span> <span class="attr">points</span>=<span class="string">'0 40,30 0,60 40'</span>&gt;</span><span class="tag">&lt;/<span class="name">polyline</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">polyline</span> <span class="attr">points</span>=<span class="string">'30 100,30 70,44 70,44 100'</span>&gt;</span><span class="tag">&lt;/<span class="name">polyline</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">g</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">defs</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">use</span> <span class="attr">xline:href</span>=<span class="string">'#house'</span> <span class="attr">x</span>=<span class="string">"100"</span> <span class="attr">y</span>=<span class="string">"100"</span> <span class="attr">style</span>=<span class="string">"fill:pink;"</span>&gt;</span><span class="tag">&lt;/<span class="name">use</span>&gt;</span>//粉色房子</span><br><span class="line"><span class="tag">&lt;<span class="name">use</span> <span class="attr">xline:href</span>=<span class="string">'#house'</span> <span class="attr">x</span>=<span class="string">"-50"</span> <span class="attr">y</span>=<span class="string">"-50"</span> <span class="attr">style</span>=<span class="string">"fill:blue;"</span>&gt;</span><span class="tag">&lt;/<span class="name">use</span>&gt;</span>//蓝色房子</span><br></pre></td></tr></table></figure>

<h3 id="四、路径-lt-Path-gt"><a href="#四、路径-lt-Path-gt" class="headerlink" title="四、路径&lt;Path&gt;"></a>四、路径&lt;Path&gt;</h3><p><code>&lt;path&gt;</code>标签可以绘制出任意图形，只需要指定一系列的坐标，所有描述属性坐标的数据都放在d属性(data)里面</p>
<blockquote>
<p>一段path可以有多个绘制组合，也就是说在一个path标签里面可以画出N个任意中断或者连接的的图形，</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">path</span> <span class="attr">d</span>=<span class="string">"M 10,20 L10,60 40,45 M60,60 L90,90 60,45"</span>&gt;</span><span class="tag">&lt;/<span class="name">path</span>&gt;</span>//绘制出了两个角度</span><br></pre></td></tr></table></figure>
</blockquote>
<h5 id="d-data-属性"><a href="#d-data-属性" class="headerlink" title="d(data)属性"></a>d(data)属性</h5><p><strong>指令</strong>:</p>
<p><strong>M(moveto)</strong>：d属性必须以此开头,代表的是画笔起始的位置，后面紧接着一个使用逗号或者空格分    隔符的x,y坐标，M表示绝对位置，m表示相对位置，但是由于m没有参照系所以第一个m也会变成    绝对位置</p>
<p><strong>L(Lineto)</strong>:L属性后面也是跟着坐标以逗号或者空格分隔，表示的是画笔移动的目的地坐标，L绝对，l相对(参考的是前一个M的位置，下同不赘述)</p>
<p><strong>Z(closepath)</strong>:用来关闭当前路径同时开启一个子路径，Z后面不跟坐标且他的大小写效果一模一样，同时Z标签会连接起始点从而形成封闭的图形</p>
<p><strong>V，H</strong>:用来绘制水平方向(H)和垂直方向(V)的路径，后面只要跟一个目标点的x或y坐标，因为另一个坐标是定死的，大小写情况和其他标签相同</p>
<p><strong>A(elliptical Arc)</strong>:用来绘制一条到目标点的椭圆弧，有以下参数</p>
<ol>
<li>起始点坐标，x,y</li>
<li>x轴旋转角度</li>
<li>圆弧角度是否大于180,0是小于1是大于</li>
<li>圆弧正负角度0是负角度，1是正角度也就是画笔以逆时针还是顺时针画弧</li>
<li>终点x,y坐标</li>
</ol>
<p><strong>Q、T、C、S</strong>：贝塞尔曲线相关不建议使用（因为太难了我搞不懂…）</p>
<h3 id="五、文本"><a href="#五、文本" class="headerlink" title="五、文本"></a>五、文本</h3><p>文本标签用来绘制svg图形中的文字</p>
<h4 id="lt-text-gt-标签"><a href="#lt-text-gt-标签" class="headerlink" title="&lt;text&gt;标签"></a>&lt;text&gt;标签</h4><p><code>&lt;text&gt;</code>需要制定x,y坐标来作为第一个文字的位置其样式基本属性和css中文字有关的属性基本一样，</p>
<p>属性：</p>
<blockquote>
<p>font-size:字体大小</p>
<p>font-style:字体是否倾斜italic(倾斜)，normal</p>
<p>text-decoration:是否有下划线none,underline,overline,line-through</p>
</blockquote>
<h4 id="lt-tspan-gt-标签"><a href="#lt-tspan-gt-标签" class="headerlink" title="&lt;tspan&gt;标签"></a>&lt;tspan&gt;标签</h4><p>我们可以简单的把该标签理解成span，他们都可以嵌入到文本中，在这个标签你可以为它单独定制样式等属性，而且由于是内嵌元素所以也不需要指定坐标</p>
<p><strong>改变位置的属性</strong>：</p>
<p>​    dx,dy(水平和垂直方向偏移量):dx,dy的值都是你想偏移的具体数值，且都是相对于原本位置来说    的，类似于position里面的relative</p>
<p>​    x,y(绝对定位):这里的xy都是当前文本的绝对位置，类似于<code>&lt;text&gt;</code>的xy</p>
<blockquote>
<p>x，y，dx，dy都可以单独或者组合使用，单独使用时其他为指明的值为默认值</p>
</blockquote>
<h4 id="文本路径-lt-textPath-gt"><a href="#文本路径-lt-textPath-gt" class="headerlink" title="文本路径&lt;textPath&gt;"></a>文本路径&lt;textPath&gt;</h4><p>这个也是以后可能使用频率很高的属性，这个属性类似于<code>&lt;path&gt;</code>标签，让文字按照指定路径排列，</p>
<blockquote>
<p>使用步骤</p>
<p>1：将文字的显示路径用path预先定义我们想要的path路径一般放在<code>&lt;defs&gt;</code>里面</p>
<p>2：定义好&lt;text&gt;文本域，在文本里面加入&lt;textPath&gt;标签，并且使用<code>xline:href=xxx</code>来引用</p>
<p>3.在&lt;textPath&gt;标签中定义我们的文字</p>
</blockquote>
]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>SVG</tag>
      </tags>
  </entry>
  <entry>
    <title>VueX</title>
    <url>/2020/01/21/VueX/</url>
    <content><![CDATA[<h1 id="VueX-详解-理论部分"><a href="#VueX-详解-理论部分" class="headerlink" title="VueX 详解(理论部分)"></a>VueX 详解(理论部分)</h1><h2 id="一、VueX-的概念"><a href="#一、VueX-的概念" class="headerlink" title="一、VueX 的概念"></a>一、VueX 的概念</h2><h3 id="1-参考官方文档：-Vuex-是一个专门为-Vue-js-设计的应用程序状态管理模式。采用集中存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。简单来说这段话有以下几个关键点："><a href="#1-参考官方文档：-Vuex-是一个专门为-Vue-js-设计的应用程序状态管理模式。采用集中存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。简单来说这段话有以下几个关键点：" class="headerlink" title="1.参考官方文档： Vuex 是一个专门为 Vue.js 设计的应用程序状态管理模式。采用集中存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。简单来说这段话有以下几个关键点："></a>1.参考官方文档： Vuex 是一个专门为 Vue.js 设计的应用程序状态管理模式。采用集中存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。简单来说这段话有以下几个关键点：</h3><pre><code>1.状态管理模式
2.相应的规则和可预测的方式</code></pre><p>下面一一来介绍一下：</p>
<h4 id="1-状态管理模式"><a href="#1-状态管理模式" class="headerlink" title="1.状态管理模式"></a>1.状态管理模式</h4><p>对此 vuex 的提供了一个官方案例来说明：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">new Vue(&#123;</span><br><span class="line"> &#x2F;&#x2F; state</span><br><span class="line"> data () &#123;</span><br><span class="line">   return &#123;</span><br><span class="line">     count: 0</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;,</span><br><span class="line"> &#x2F;&#x2F; view</span><br><span class="line"> template: &#96;</span><br><span class="line">   &lt;div&gt;&#123;&#123; count &#125;&#125;&lt;&#x2F;div&gt;</span><br><span class="line"> &#96;,</span><br><span class="line"> &#x2F;&#x2F; actions</span><br><span class="line"> methods: &#123;</span><br><span class="line">   increment () &#123;</span><br><span class="line">     this.count++</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<pre><code>分析上例能看到事实上构成vuex总共有三个大部分：
1.`data部分存放数据也就是驱动程序的数据源`-state
2.`template部分存放的是html标签也就是视图`-view
3.`methods部分存放相关的函数也就是驱动数据改变方式`-actions</code></pre><p>这三个部分组合共同构成了一个状态自管理应用并以单向数据流的方式运行，用以保证数据的简洁即：<br><img src="/2020/01/21/VueX/flow.png" alt="单向数据流" title="单向数据流"></p>
<h4 id="2-相应的规则和可预测的方式"><a href="#2-相应的规则和可预测的方式" class="headerlink" title="2.相应的规则和可预测的方式"></a>2.相应的规则和可预测的方式</h4><p>明白了以上概念后这个也很好理解，状态管理模式下的数据的简洁行可能在某些应用场景中被破坏：<br><code>1.多个视图依赖同一状态</code><br><code>2.多个不同的视图行为都需要更改同一状态</code></p>
<ul>
<li>对于问题 1.一般都是各组件多层嵌套，问题 2.一般都是父子组件传值或 bus 事件监听但是以上解决办法不但会导致代码冗长难以维护还有不必要的性能消耗问题。</li>
<li>此时有一个新思路来解决这个问题：把所有共享的状态单独抽离出来这样任意位置的视图都可以获取和更改对应状态，通过定义与隔离状态管理的概念并通过强制的规则来保证视图和状态的独立性，这样就比较完美的解决了这个问题，而这种以一个全局单例管理模式来管理的方式也是 v 时 uex 的基本设计思路<br>基于此 vuex 制定出了相关的强制方法，以便让所有更改共享状态的行为简洁明了同时维护方便</li>
</ul>
<h2 id="二、VueX-的使用场景"><a href="#二、VueX-的使用场景" class="headerlink" title="二、VueX 的使用场景"></a>二、VueX 的使用场景</h2><p>vuex 是用来统一管理状态的但是我们该什么时候使用呢？一般来我们普遍意义上来说仅在中大型项目中会考虑使用，但是我觉着不太准确，在我的理解中是否使用 vuex 应当解决与项目中是否会遇到 vuex 方便解决的问题，它被设计出来解决什么就用它来解决什么，所以根据我不多的经验简单的罗列了一下使用场景：<br><code>1.组件结构复杂多种交互：购物车，列表操作...</code><br><code>2.组件重复销毁与生成但需要留存数据：弹窗，...</code><br><code>3.多个触发方法，多个依赖视图：全局风格...</code></p>
<h2 id="三、vueX-核心概念-先看看官方文档中的图例"><a href="#三、vueX-核心概念-先看看官方文档中的图例" class="headerlink" title="三、vueX 核心概念 ###先看看官方文档中的图例"></a>三、vueX 核心概念 ###先看看官方文档中的图例</h2><p><img src="/2020/01/21/VueX/vuex.png" alt="流程" title="VueX"><br>有 3 个概念<code>State</code>，<code>Action</code>，<code>Mutaiton</code>再加上<code>Getter</code>和<code>Moudule</code>总计有 5 个,一一来看一下</p>
<h4 id="1-State"><a href="#1-State" class="headerlink" title="1.State"></a>1.State</h4><ul>
<li><code>概念：</code>State 作为单例模式管理下的概念，以全局且唯一的对象方式而存在，作为唯一的数据源里仅能够存放需要共享的状态</li>
<li><code>在Vuex中的定义和使用：</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const Counter &#x3D; &#123;</span><br><span class="line"> template: &#96;&lt;div&gt;&#123;&#123; count &#125;&#125;&lt;&#x2F;div&gt;&#96;,</span><br><span class="line"> computed: &#123;</span><br><span class="line">   count () &#123;</span><br><span class="line">     return this.$store.state.count</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>辅助函数mapState：</code>一般来说在 computed 中使用对象展开运算符将多个状态生成对应的计算属性</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">localComputed () &#123; &#x2F;* ... *&#x2F; &#125;,</span><br><span class="line">&#x2F;&#x2F; 使用对象展开运算符将此对象混入到外部对象中</span><br><span class="line">...mapState(&#123;</span><br><span class="line">  &#x2F;&#x2F; ...</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-Mutation"><a href="#2-Mutation" class="headerlink" title="2.Mutation"></a>2.Mutation</h4><ul>
<li><p><code>概念：</code>Mutation 在 Vuex 中是唯一能对 State 状态进行操作的属性，里面存放着各种对 State 中状态的各种操作，和 vue 中的 methods 很类似，可以对比着理解。</p>
</li>
<li><p><code>在Vuex中的定义与使用：</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const store &#x3D; new Vuex.Store(&#123;</span><br><span class="line">state: &#123;</span><br><span class="line">count: 1</span><br><span class="line">&#125;,</span><br><span class="line">mutations: &#123;</span><br><span class="line">increment (state) &#123;</span><br><span class="line">  &#x2F;&#x2F; 变更状态</span><br><span class="line">  state.count++</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><code>1.声明</code>:由此也能看到的是 mutation 中的各种方法都由事件类型(type)+回调函数(handler)组成，类似于方法名+函数体<br><code>2.调用</code>:store.commit(Type 名)来调用</p>
<ul>
<li><code>提交载荷(PayLoad)</code>:在我们调用 Mutation 对应函数时除了输入 Type 名称还可以在后面传入其他参数，可以使对象也可以是其他类型，类似于函数中的参数列表</li>
<li><code>对象风格提交</code>：在 commit 时直接把 Type 和荷载写在同一个对象中</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">store.commit(&#123;</span><br><span class="line"> type: &#39;increment&#39;,</span><br><span class="line"> amount: 10</span><br><span class="line"> &#125;)</span><br></pre></td></tr></table></figure>

<p><code>3.同步性：</code>在 Mutation 中的操作必须是同步的，为了保证对 state 状态的确定性修改<br><code>4.辅助函数MapMutation:</code>一般来说对应在 Methods 中使用对象展开符将 Mutation 中的对应方法映射到局部组件中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123; mapMutations &#125; from &#39;vuex&#39;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line"> &#x2F;&#x2F; ...</span><br><span class="line"> methods: &#123;</span><br><span class="line">   ...mapMutations([</span><br><span class="line">     &#39;increment&#39;, &#x2F;&#x2F; 将 &#96;this.increment()&#96; 映射为 &#96;this.$store.commit(&#39;increment&#39;)&#96;</span><br><span class="line"></span><br><span class="line">     &#x2F;&#x2F; &#96;mapMutations&#96; 也支持载荷：</span><br><span class="line">     &#39;incrementBy&#39; &#x2F;&#x2F; 将 &#96;this.incrementBy(amount)&#96; 映射为 &#96;this.$store.commit(&#39;incrementBy&#39;, amount)&#96;</span><br><span class="line">   ]),</span><br><span class="line">   ...mapMutations(&#123;</span><br><span class="line">     add: &#39;increment&#39; &#x2F;&#x2F; 将 &#96;this.add()&#96; 映射为 &#96;this.$store.commit(&#39;increment&#39;)&#96;</span><br><span class="line">   &#125;)</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-Action"><a href="#3-Action" class="headerlink" title="3.Action"></a>3.Action</h4><ul>
<li><p><code>概念</code>:Action 的性质和 Mutation 几乎一样，但区别在于 Action 中可以包含同，异步方法。同时 Action 并不能直接对 State 进行操作需要提交的到 Mutation，在由 Mutation 中的方法对 State 进行操作</p>
</li>
<li><p><code>在VueX中的定义与使用</code></p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const store &#x3D; new Vuex.Store(&#123;</span><br><span class="line"> state: &#123;</span><br><span class="line">   count: 0</span><br><span class="line"> &#125;,</span><br><span class="line"> mutations: &#123;</span><br><span class="line">   increment (state) &#123;</span><br><span class="line">     state.count++</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;,</span><br><span class="line"> actions: &#123;</span><br><span class="line">   increment (context) &#123;</span><br><span class="line">     context.commit(&#39;increment&#39;)</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><code>1.声明：</code>与 Mutation 相同<br><code>2.调用(分发)：</code>context.dispatch(Type 名)<br><code>3.提交荷载：</code>与 Mutation 相同<br><code>4.对象风格提交：</code>与 Mutation 相同</p>
<ul>
<li><code>异步性</code>：在 Action 的异步方法完成后返回的是一个 Promise 对象，若要实现对 State 的操作必须在其中加入 commit 同步方法</li>
<li><code>辅助函数MapAction：</code>与 Mutation 相同<br>####4.Getter</li>
<li><code>概念：</code>当需要对 Store 对象中 state 的部分属性进行某些操作之后生成的排成属性存放在 getter 里面，类似于 Computed。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">   computed: &#123;</span><br><span class="line">  doneTodosCount () &#123;</span><br><span class="line">    return this.$store.state.todos.filter(todo &#x3D;&gt; todo.done).length</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>在Vuex中的定义与使用</code><br><code>1.声明:</code>名称+提交荷载+回调函数<br><code>2.调用：</code><br><code>1通过属性访问</code>：Getter 会暴露一个 store.getters 对象通过该对象.对应属性的形式访问<br><code>store.getters.doneTodos</code><br><code>2.通过方法访问：</code>让 getters 返回一个函数并在调用时传入相应参数通过 getters 中对应的属性间接的对 store 中的某些属性进行操作</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">     getters: &#123;</span><br><span class="line">  &#x2F;&#x2F; ...</span><br><span class="line">  getTodoById: (state) &#x3D;&gt; (id) &#x3D;&gt; &#123;</span><br><span class="line">    return state.todos.find(todo &#x3D;&gt; todo.id &#x3D;&#x3D;&#x3D; id)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>MapperGetter辅助函数：</code>用对象展开符将 computed 属性进行映射，此时若要重命名需要用对象的形式重新接收</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123; mapGetters &#125; from &#39;vuex&#39;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line"> &#x2F;&#x2F; ...</span><br><span class="line"> computed: &#123;</span><br><span class="line"> &#x2F;&#x2F; 使用对象展开运算符将 getter 混入 computed 对象中</span><br><span class="line">   ...mapGetters([</span><br><span class="line">     &#39;doneTodosCount&#39;,</span><br><span class="line">     &#39;anotherGetter&#39;,</span><br><span class="line">     &#x2F;&#x2F; ...</span><br><span class="line">   ])</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-Moudule"><a href="#5-Moudule" class="headerlink" title="5.Moudule"></a>5.Moudule</h4><ul>
<li><code>概念：</code>当应用过于复杂时 store 对象会变得异常的臃肿，为了解决这个问题就需要使用到 Vuex 中的 Moudule 属性(模块)，用于对复杂的 store 进行切割，使之分割成一个独立的模块，每个模块拥有独立的 state,Mutation,等同时模块内部也能够相互嵌套，类似于 vue 中的组件 components 的概念</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> const moduleA &#x3D; &#123;</span><br><span class="line">  state: &#123; ... &#125;,</span><br><span class="line">  mutations: &#123; ... &#125;,</span><br><span class="line">  actions: &#123; ... &#125;,</span><br><span class="line">  getters: &#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const moduleB &#x3D; &#123;</span><br><span class="line">  state: &#123; ... &#125;,</span><br><span class="line">  mutations: &#123; ... &#125;,</span><br><span class="line">  actions: &#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const store &#x3D; new Vuex.Store(&#123;</span><br><span class="line">  modules: &#123;</span><br><span class="line">    a: moduleA,</span><br><span class="line">    b: moduleB</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">store.state.a &#x2F;&#x2F; -&gt; moduleA 的状态</span><br><span class="line">store.state.b &#x2F;&#x2F; -&gt; moduleB 的状态</span><br></pre></td></tr></table></figure>

<ul>
<li><code>Moudule内的局部状态：</code>在不同某块中获取的默认对象作用域也仅限于模块内部，类似于不同组件的 this<br><code>1.局部状态下的Mutation和state:</code>使用方式和全局下没有区别，<br><code>2.局部状态下的action和getters：</code>在局部状态下接收的参数中的第三个是局部状态的根节点</li>
<li><code>Module命名空间：</code><br><code>内容：</code>通过在 moudule 中添加 namespace:true 来生成对应名称的模块，当模块被注册后模块内的所有内容都会调整命名（vue 拆分出组件后加入 name:’xx’会让对应所有内容路径改变）</li>
<li><code>带命名空间的Module与内外的访问</code><br><code>1.Module访问全局内容</code><br><code>1.1.</code>使用全局的 state 与 getter，在局部状态中接收第三第四个参数分别代表全局状态，全局 getters，也会通过对应 context 或 store 传入方法<br><code>1.2</code>使用全局的 mutation 和 action，在局部方法中将其作为第三个参数并传入对应的 dispatch 或 commit<br><code>1.3</code>局部注册全局 action:将 root:true 作为定义放在 handler 中</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> modules: &#123;</span><br><span class="line">  foo: &#123;</span><br><span class="line">   namespaced: true,</span><br><span class="line">   getters: &#123;</span><br><span class="line">     &#x2F;&#x2F; 在这个模块的 getter 中，&#96;getters&#96; 被局部化了</span><br><span class="line">     &#x2F;&#x2F; 你可以使用 getter 的第四个参数来调用 &#96;rootGetters&#96;</span><br><span class="line">     someGetter (state, getters, rootState, rootGetters) &#123;</span><br><span class="line">       getters.someOtherGetter &#x2F;&#x2F; -&gt; &#39;foo&#x2F;someOtherGetter&#39;</span><br><span class="line">       rootGetters.someOtherGetter &#x2F;&#x2F; -&gt; &#39;someOtherGetter&#39;</span><br><span class="line">     &#125;,</span><br><span class="line">     someOtherGetter: state &#x3D;&gt; &#123; ... &#125;</span><br><span class="line">   &#125;,</span><br><span class="line"></span><br><span class="line">   actions: &#123;</span><br><span class="line">     &#x2F;&#x2F; 在这个模块中， dispatch 和 commit 也被局部化了</span><br><span class="line">     &#x2F;&#x2F; 他们可以接受 &#96;root&#96; 属性以访问根 dispatch 或 commit</span><br><span class="line">     someAction (&#123; dispatch, commit, getters, rootGetters &#125;) &#123;</span><br><span class="line">       getters.someGetter &#x2F;&#x2F; -&gt; &#39;foo&#x2F;someGetter&#39;</span><br><span class="line">       rootGetters.someGetter &#x2F;&#x2F; -&gt; &#39;someGetter&#39;</span><br><span class="line"></span><br><span class="line">       dispatch(&#39;someOtherAction&#39;) &#x2F;&#x2F; -&gt; &#39;foo&#x2F;someOtherAction&#39;</span><br><span class="line">       dispatch(&#39;someOtherAction&#39;, null, &#123; root: true &#125;) &#x2F;&#x2F; -&gt; &#39;someOtherAction&#39;</span><br><span class="line"></span><br><span class="line">       commit(&#39;someMutation&#39;) &#x2F;&#x2F; -&gt; &#39;foo&#x2F;someMutation&#39;</span><br><span class="line">       commit(&#39;someMutation&#39;, null, &#123; root: true &#125;) &#x2F;&#x2F; -&gt; &#39;someMutation&#39;</span><br><span class="line">     &#125;,</span><br><span class="line">     someOtherAction (ctx, payload) &#123; ... &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>2.外部访问Moudule局部内容：</code><br><code>1.通过辅助函数访问：</code><br><code>2.通过createNamespacedHelpers访问：</code>通过引入 vue 中的 createNamespacedHelpers，返回的是一个对象其中会包含给定明明看见的辅助函数类似于组件应用后获取引入组件的内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123; createNamespacedHelpers &#125; from &#39;vuex&#39;</span><br><span class="line"></span><br><span class="line">const &#123; mapState, mapActions &#125; &#x3D; createNamespacedHelpers(&#39;some&#x2F;nested&#x2F;module&#39;)</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line"> computed: &#123;</span><br><span class="line">   &#x2F;&#x2F; 在 &#96;some&#x2F;nested&#x2F;module&#96; 中查找</span><br><span class="line">   ...mapState(&#123;</span><br><span class="line">     a: state &#x3D;&gt; state.a,</span><br><span class="line">     b: state &#x3D;&gt; state.b</span><br><span class="line">   &#125;)</span><br><span class="line"> &#125;,</span><br><span class="line"> methods: &#123;</span><br><span class="line">   &#x2F;&#x2F; 在 &#96;some&#x2F;nested&#x2F;module&#96; 中查找</span><br><span class="line">   ...mapActions([</span><br><span class="line">     &#39;foo&#39;,</span><br><span class="line">     &#39;bar&#39;</span><br><span class="line">   ])</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="VueX-引申内容"><a href="#VueX-引申内容" class="headerlink" title="VueX 引申内容"></a>VueX 引申内容</h2><h3 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h3><ul>
<li><code>概念：</code>在严格模式下会深度监测所有状态，凡是引起状态改变的动作不是来自于 mutation 都会报错</li>
<li><code>启用：</code>在 store 创建时传入`strict：true</li>
<li><code>注意事项：</code><br><code>严格模式下的表单处理：</code>当用 input 去绑定 vuex 中的状态时由于改变不是有 mutation 处理的所以会报错，要解决此这个问题一般来说 给 input 绑定 change 事件，在对应函数中使用 commit 提交<br>或者绑定一个计算属性使用 get 方法获取状态使用 set 方法更改状态`</li>
</ul>
<h4 id="在理解了-VueX-相应的概念后，接下来就应该加入实战了，后面有时间的话还会补充一篇关于-VueX-的使用详情，敬请期待"><a href="#在理解了-VueX-相应的概念后，接下来就应该加入实战了，后面有时间的话还会补充一篇关于-VueX-的使用详情，敬请期待" class="headerlink" title="在理解了 VueX 相应的概念后，接下来就应该加入实战了，后面有时间的话还会补充一篇关于 VueX 的使用详情，敬请期待"></a>在理解了 VueX 相应的概念后，接下来就应该加入实战了，后面有时间的话还会补充一篇关于 VueX 的使用详情，敬请期待</h4>]]></content>
      <categories>
        <category>Web前端</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>VueX</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript全解:JavaScript部分(一)数据类型、运算符、作用域、预解析</title>
    <url>/2020/03/20/JavaScript%E5%85%A8%E8%A7%A3JavaScript%E9%83%A8%E5%88%86(%E4%B8%80)%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E3%80%81%E8%BF%90%E7%AE%97%E7%AC%A6%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E3%80%81%E9%A2%84%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<p><img src="/2020/03/20/JavaScript%E5%85%A8%E8%A7%A3JavaScript%E9%83%A8%E5%88%86(%E4%B8%80)%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E3%80%81%E8%BF%90%E7%AE%97%E7%AC%A6%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E3%80%81%E9%A2%84%E8%A7%A3%E6%9E%90/web.png" alt></p>
<h1 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h1><h1 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h1><blockquote>
<p>前言：学习任何新东西前都最好对其有一个系统化的了解，以便构建合理完整的知识体系，学习JS也一样对它有一个整体的认知之后学习起来才能事半功倍</p>
</blockquote>
<p><strong>JavaScript结构</strong></p>
<p><img src="/2020/03/20/JavaScript%E5%85%A8%E8%A7%A3JavaScript%E9%83%A8%E5%88%86(%E4%B8%80)%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E3%80%81%E8%BF%90%E7%AE%97%E7%AC%A6%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E3%80%81%E9%A2%84%E8%A7%A3%E6%9E%90/js%E7%BB%84%E6%88%90.jpg" alt></p>
<p>参考上面结构能很明显的知道有三部分组成(也可以认为是两部分，Dom可以认为被包含在Bom内)：</p>
<a id="more"></a>

<ol>
<li><p><strong>ECMAScript</strong></p>
<p>这是JavaScript的核心，不过它仅仅是一个概念，它定义了该脚本语言的所有属性，方法和对象，比如语法、类型、语句、关键字、保留字、运算符、对象等内容，每一个浏览器厂商都有各自的 ECMAScript 接口实现，然后这个实现又被扩展，也包含了 DOM 和 BOM。</p>
</li>
<li><p><strong>DOM</strong></p>
<p>DOM（<em>Document Object Model 文档对象模型</em>）是 HTML 和 XML 的应用程序接口（API）。DOM 将把整个页面规划成由节点层级构成的文档。HTML 或 XML 页面的每个部分都是一个节点的衍生物。DOM 通过创建树来表示文档，浏览器 动过DOM树来解释和执行对应的操作，也就是我们说的渲染节点，同时也提供了一系列的API让我们去操作节点。</p>
</li>
<li><p><strong>BOM</strong></p>
<p>BOM(<em>Browser Object Model浏览器对象模型</em> )可以对浏览器窗口进行访问和操作，使用 BOM提供的API开发者可以对浏览器进行操作实现类似于：移动窗口、改变状态栏中的文本以及执行其他与页面内容不直接相关的动作。但是由于没有相关的 BOM 标准，每个浏览器厂商对于其实现也会有部分不一样。</p>
</li>
</ol>
<p>该篇只介绍第一部分也就是JavaScript的基础语法</p>
<h1 id="JavaScript-1"><a href="#JavaScript-1" class="headerlink" title="JavaScript"></a>JavaScript</h1><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><ol>
<li><p>简单数据类型性：</p>
<blockquote>
<p>也叫值类型，对应的数据会直接存放在栈里面，赋值的时候直接把对应的值复制过去</p>
</blockquote>
<ul>
<li><p>Number(数字类型):放的是一切数字整数，浮点型等</p>
<blockquote>
<p>数字类型会存在三个特殊值</p>
<ol>
<li>infinity：无穷大，大于任何一个数</li>
<li>-infinity：无穷小，小于任何一个数</li>
<li>NaN：Not a Number 不是一个数字(在运算时可能出现)可以用isNaN判断</li>
</ol>
</blockquote>
</li>
<li><p>String(字符串类型)：单个字符或者字符串，在<code>‘’或者“”</code>内的所有内容都被认为是字符串</p>
<blockquote>
<p><code>\</code>这个是转义符用来将某些特殊字符转义成字符串</p>
<p><code>&#39;\n&#39;</code>:换行</p>
<p><code>&#39;\t&#39;</code>z制表符…</p>
</blockquote>
</li>
<li><p>Boolean(布尔值):只有true和false两种，表示是或非</p>
<blockquote>
<p>Boolean值存在能够和其他类型相互转换的情况eg：</p>
<p>Boolean(0):false;Boolean(5):true;Boolean(‘’):false;Boolean(‘a’):true;Boolean(null):false</p>
</blockquote>
</li>
<li><p>Undefined(定义未赋值):变量被声明但未被赋值的时候，此时该声明获得的一个默认数据类型</p>
<blockquote>
<p>undefined+1(NAN),undefined+’a’(undefineda)undefined+true(NAN)</p>
</blockquote>
</li>
<li><p>null(空)：变量被声明且被赋值，只是赋值为空</p>
<blockquote>
<p>null+1(1),null+’a’(nulla),null+true(1)</p>
</blockquote>
</li>
</ul>
</li>
<li><p>复杂类型：</p>
<blockquote>
<p>也叫做引用类型，引用类型的值存在堆内存当中，在使用时栈里面存放的是一个对真实地址的引用一般用16进制表示。所以简单赋值(浅拷贝)的时候仅仅只是新建了一个对于同一块内容的引用而已</p>
</blockquote>
<ul>
<li><p>Object(对象)</p>
<p>实际上只有这一个类型，其他的一切复杂类型(Array,Set,Map…)都是对Object的实例或者拓展而已</p>
</li>
</ul>
</li>
</ol>
<h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><ol>
<li><p>算数运算符：+，-，*，/，%</p>
</li>
<li><p>前、后置预算符：</p>
<ul>
<li><code>++a</code>前置预算:先自增1后返回<code>var a=1 console.log(++a)//2 a=2</code></li>
<li><code>a++</code>后置预算:先自增1后返回<code>var a=1 console.log(a++)//1 a=2</code></li>
</ul>
</li>
<li><p>比较运算符：判断符号两边表达式是否符合预算的语义，返回true或false<code>&gt;,&lt;,&lt;=,&gt;=,==</code></p>
<blockquote>
<p>===,!==：全等因为js会有隐式转换，该运算符会比较两边的值和类型是否相同</p>
<p>Object.is():ES6新增方法，弥补===的问题+0===-0//true等</p>
</blockquote>
</li>
<li><p>逻辑运算符：构建判断表达式返回true或false</p>
<ol>
<li><p>&amp;&amp;(与)：两侧都符合返回true</p>
</li>
<li><p>||(或)：两侧有一侧符合返回true</p>
</li>
<li><p>！(非)：返回表达式布尔值的相反值</p>
<blockquote>
<p>短路逻辑运算参与运算(两边都是值)：</p>
<p>a&amp;&amp;b：当a为真返回b,当a为假返回a <code>console.log(1&amp;&amp;2)//2 console.log(0&amp;&amp;2)//0</code></p>
<p>a||b：当a为真返回a,当a为假返回b <code>console.log(1||2)//1 console.log(0||2)//2</code></p>
</blockquote>
</li>
</ol>
</li>
</ol>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h3><ol>
<li>关键字命名：<code>function name(){}</code></li>
<li>表达式命名(匿名函数):<code>var fn=function(){}</code></li>
</ol>
<h3 id="参数对象"><a href="#参数对象" class="headerlink" title="参数对象"></a>参数对象</h3><p> arguments是所有函数默认的内置对象，里面存放了调用函数时接收的所有对象</p>
<h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><blockquote>
<p>是一块独立的区域，该区域内的所有变量，函数等都只能在该区域内使用，外部无法访问。两个作用域互不影响，也无法联通</p>
</blockquote>
<ul>
<li><p>全局作用域：    整个<code>&lt;script/&gt;</code>标签内或者一个单个js文件内</p>
</li>
<li><p>局部作用域(函数作用域)：在一个特殊范围内起效果，如函数内部</p>
</li>
</ul>
<h3 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h3><ul>
<li><p>全部变量:全局作用域内声明的变量，浏览器关闭时被销毁</p>
</li>
<li><p>局部变量:局部作用域内声明的变量，函数调用结束时被销毁</p>
</li>
<li><p>自由变量:局部作用域内未声明的变量，直接未被赋值时会被视为全局作用域内的变量</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> num1=<span class="number">10</span></span><br><span class="line">    num2=<span class="number">20</span><span class="comment">//自由变量</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(num1)<span class="comment">//10</span></span><br><span class="line"><span class="built_in">console</span>.log(num2)<span class="comment">//20</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h3><ul>
<li><p>概念：在js 中有一个最大的全局作用域，在该作用域下的会有若干单个或嵌套的局部作用域，在某一个局部作用域可以访问其父级作用域内的所有内容，而父级作用域又可以访问包含它的父级作用域内的所有内容，一直到全局作用域。这种层层传递的层级关系叫做作用域链</p>
</li>
<li><p>作用域取值：(就近原则)在函数执行需要使用某个变量时会先从内部作用域开始查找，若有就使用。若没有往父级作用域查找一直到查找到全局作用域</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a=<span class="number">1</span></span><br><span class="line">    <span class="keyword">var</span> b=<span class="number">2</span></span><br><span class="line">    fn2();</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">fn2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> a=<span class="number">3</span></span><br><span class="line">        fn3()</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">fn3</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">var</span> a=<span class="number">4</span></span><br><span class="line">            <span class="built_in">console</span>.log(a)</span><br><span class="line">            <span class="built_in">console</span>.log(b)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">fn1();<span class="comment">//a=4,b=2</span></span><br></pre></td></tr></table></figure>

<h2 id="预解析"><a href="#预解析" class="headerlink" title="预解析"></a>预解析</h2><p>js是一门解释型语言，js引擎在执行时会有两个过程：预解析和执行代码</p>
<h3 id="变量提升和函数提升"><a href="#变量提升和函数提升" class="headerlink" title="变量提升和函数提升"></a>变量提升和函数提升</h3><p>在js预解析时会把作用域内的所有变量声明放到该作用域最前面,但是不会提升赋值操作</p>
<blockquote>
<p>下例以变量为例，函数类似</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num1=<span class="number">1</span>           </span><br><span class="line"><span class="built_in">console</span>.log(num1)<span class="comment">//1</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">var num1,num1=1,</span></span><br><span class="line"><span class="comment">console.log(num1)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">console</span>.log(num2)<span class="comment">//undefined</span></span><br><span class="line"><span class="keyword">var</span> num2=<span class="number">2</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">var num2</span></span><br><span class="line"><span class="comment">console.log(num1)</span></span><br><span class="line"><span class="comment">num2=2</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">fn1()<span class="comment">//报错</span></span><br><span class="line"><span class="keyword">var</span> fn1=<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="number">3</span>)&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">var fn1</span></span><br><span class="line"><span class="comment">console.log(fn1)</span></span><br><span class="line"><span class="comment">fn1=function ()&#123;console.log(3)&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript全解</tag>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript全解:JavaScript部分(二)对象、原型、继承</title>
    <url>/2020/05/15/JavaScript%E5%85%A8%E8%A7%A3JavaScript%E9%83%A8%E5%88%86(%E4%BA%8C)%E5%AF%B9%E8%B1%A1%E3%80%81%E5%8E%9F%E5%9E%8B%E3%80%81%E7%BB%A7%E6%89%BF/</url>
    <content><![CDATA[<p><img src="/2020/05/15/JavaScript%E5%85%A8%E8%A7%A3JavaScript%E9%83%A8%E5%88%86(%E4%BA%8C)%E5%AF%B9%E8%B1%A1%E3%80%81%E5%8E%9F%E5%9E%8B%E3%80%81%E7%BB%A7%E6%89%BF/web.png" alt></p>
<h1 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h1><blockquote>
<p>用来描述一系列的特征(属性)和方法(行为)的无序集合称为对象</p>
</blockquote>
<h2 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h2><h3 id="字面量创建对象"><a href="#字面量创建对象" class="headerlink" title="字面量创建对象"></a>字面量创建对象</h3><ul>
<li>创建：<code>let obj={name:&#39;a&#39;,eat(){console.log(&#39;eat&#39;)}}</code>在<code>{}</code>之间的所有内容都属于obj这个对象，存放变量，函数等以键值对的形式存在</li>
<li>调用：<ul>
<li>属性调用：1.<code>obj.xxx</code>2.<code>obj[xxx]</code></li>
<li>方法调用<code>obj.xxx</code></li>
</ul>
</li>
</ul>
<h3 id="new关键字创建对象"><a href="#new关键字创建对象" class="headerlink" title="new关键字创建对象"></a>new关键字创建对象</h3><ul>
<li>创建 <code>let obj=new Object(),obj.name=&#39;1&#39;</code></li>
<li>调用：同字面量</li>
</ul>
<a id="more"></a>

<h3 id="构造函数创建对象"><a href="#构造函数创建对象" class="headerlink" title="构造函数创建对象"></a>构造函数创建对象</h3><blockquote>
<p>将多个对象公共的属性和方法抽象出来并封装到一个特殊的函数中，这个函数就叫做构造函数</p>
</blockquote>
<ul>
<li><p>创建：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Object</span>(<span class="params">arguments</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.属性=属性值</span><br><span class="line">    <span class="keyword">this</span>.方法=方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>调用</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name=name</span><br><span class="line">    <span class="keyword">this</span>.age=age</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.eat=funnction ()&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'eat'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p1=<span class="keyword">new</span> Person(<span class="string">'a'</span>,<span class="number">10</span>)</span><br><span class="line"><span class="comment">//创建了一个名为p1的对象，创建时将特定的参数化传递到构造函数通过new关键词即可创建一个特殊对象</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>构造函数和对象区别</p>
<ul>
<li>构造函数：一个概念，只存放了一系列的抽象的属性和行为的结合</li>
<li>对象：一个具体的事务，有具体的属性和行为，是构造函数的一个实例</li>
</ul>
</li>
</ul>
<h3 id="class创建对象"><a href="#class创建对象" class="headerlink" title="class创建对象"></a>class创建对象</h3><blockquote>
<p>用class创建对象 实际上就是构造函数创建，以往构造函数的赋值操作变成了constructor里面，挂载在其原型上的方法可以直接写在构造函数外面，所以class只是一个让构造函数更加清晰，可读性更强的语法糖而已</p>
</blockquote>
<ul>
<li><p>创建</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name,age)&#123;</span><br><span class="line">        <span class="keyword">this</span>.name=name</span><br><span class="line">        <span class="keyword">this</span>.age=age</span><br><span class="line">    &#125;</span><br><span class="line">    eat()&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'eat'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>调用(和构造函数使用类似)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p1=<span class="keyword">new</span> Person(<span class="string">'a'</span>,<span class="number">12</span>)</span><br><span class="line">p1.name<span class="comment">///a</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="new-如何创建了一个新对象"><a href="#new-如何创建了一个新对象" class="headerlink" title="new 如何创建了一个新对象"></a>new 如何创建了一个新对象</h3><ol>
<li><p>开辟出一个新的内存空间(创建一个空对象)</p>
</li>
<li><p>将构造函数的显式原型赋值到实例对象的隐式原型中</p>
</li>
<li><p>将构造函数的this指向到新对象</p>
</li>
<li><p>执行构造函数完成对应操作</p>
</li>
<li><p>返回新对象</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p1=<span class="keyword">new</span> Person(<span class="string">'a'</span>)<span class="comment">//相当于</span></span><br><span class="line"><span class="comment">//let p1 //创建一个</span></span><br><span class="line"><span class="keyword">let</span> p1=(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> newP1=&#123;&#125;</span><br><span class="line">    newP1._proto_=Person.prototype<span class="comment">//获取原型</span></span><br><span class="line">   Person.call(newP1,<span class="string">'a'</span>)<span class="comment">//把当前this传入，并执行构造函数</span></span><br><span class="line">    <span class="keyword">return</span> newP1 <span class="comment">//返回新对象</span></span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="原型和原型链"><a href="#原型和原型链" class="headerlink" title="原型和原型链"></a>原型和原型链</h2><h3 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h3><h4 id="什么是原型"><a href="#什么是原型" class="headerlink" title="什么是原型"></a>什么是原型</h4><p>在创建每一个构造函数时我们会定义一系列的公共属性和方法，一个构造函数可以创建N个具有不同内容的对象(实例),但每所有的实例都会具有构造函数所定义的公共属性和方法，这些共有的属性和方法就称之为原型</p>
<h4 id="显式原型和隐式原型"><a href="#显式原型和隐式原型" class="headerlink" title="显式原型和隐式原型"></a>显式原型和隐式原型</h4><p>先看以下例子</p>
<img src="/2020/05/15/JavaScript%E5%85%A8%E8%A7%A3JavaScript%E9%83%A8%E5%88%86(%E4%BA%8C)%E5%AF%B9%E8%B1%A1%E3%80%81%E5%8E%9F%E5%9E%8B%E3%80%81%E7%BB%A7%E6%89%BF/显、隐式原型.PNG">

<p>在Person类中存在<code>prototype</code>属性该属性就是Person的原型，存放了它自己特有的属性和方法。在Person的实例p1中存在<code>_proto_</code>属性，该属性指向了p1的构造函数也就是Person的原型<code>prototype</code>，一般的我们将构造函数中的原型<code>prototype</code>称之为显式原型，将实例中的<code>_proto_</code>称之为隐式原型</p>
<h4 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h4><p>由上述我们可以知道一下三点</p>
<ol>
<li>每一个class(构造函数)都有显式原型<code>prototype</code></li>
<li>每一个实例对象都有隐式原型<code>_proto_</code></li>
<li>实例中的隐式原型指向其构造函数的显示原型</li>
</ol>
<p>再看以下例子</p>
<p><img src="/2020/05/15/JavaScript%E5%85%A8%E8%A7%A3JavaScript%E9%83%A8%E5%88%86(%E4%BA%8C)%E5%AF%B9%E8%B1%A1%E3%80%81%E5%8E%9F%E5%9E%8B%E3%80%81%E7%BB%A7%E6%89%BF/%E5%8E%9F%E5%9E%8B%E9%93%BE.PNG" alt></p>
<blockquote>
<p>我们调用p1的toString方法，但实例当中没有，去构造函数中查找也没有，再去Person的构造函数Object查找找到了该方法于是调用Object.toString方法。</p>
</blockquote>
<p>一般的当我们调用某一个属性或者方法的时候，js会先从当前实例当中查找方法找到调用，找不到通过<code>_proto_</code>查找其构造函数的方法和属性(因为实例的<code>_proto_</code>指向其构造函数的<code>prototype</code>)，若找不到则通过<code>_proto_</code>查找再构造函数的构造函数的方法和属性一直到最外一层位置(Object) 这种层层传递的这种链式结构就叫做原型链</p>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><blockquote>
<p>在外面创建实例时，会需要创建属性和实例，而某些属性和实例可能已经被自己或者前人实现过，如果能通过每种方式将那些前人写好的东西继承过来的话会让我们的程序简洁很多。</p>
</blockquote>
<h3 id="类式继承"><a href="#类式继承" class="headerlink" title="类式继承"></a>类式继承</h3><ul>
<li><p>方法：直接将子类原型指向父类</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name=name;</span><br><span class="line">    <span class="keyword">this</span>.list=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">&#125;</span><br><span class="line">A.prototype.getName=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="keyword">this</span>.name)&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubA</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.subName=<span class="string">'sub'</span>+<span class="keyword">this</span>.name</span><br><span class="line">&#125;</span><br><span class="line">SubA.prototype=<span class="keyword">new</span> A()</span><br></pre></td></tr></table></figure>
</li>
<li><p>问题：</p>
<p><img src="/2020/05/15/JavaScript%E5%85%A8%E8%A7%A3JavaScript%E9%83%A8%E5%88%86(%E4%BA%8C)%E5%AF%B9%E8%B1%A1%E3%80%81%E5%8E%9F%E5%9E%8B%E3%80%81%E7%BB%A7%E6%89%BF/%E7%B1%BB%E5%BC%8F%E7%BB%A7%E6%89%BF.PNG" alt></p>
<p>由图可知</p>
<ol>
<li>该方式不会支持父类构造函数A有参数的情况</li>
<li>该方式会把父类的所有内容继承下来哪怕是父类不希望传递的属性list</li>
</ol>
</li>
<li><p>原因：由于通过这个语句<code>SubA.prototype=new A()</code>我们获得了A的一个实例，但是在这个new的时候由于类本身也是个抽象概念，不知道具体实例所以当我们执行A构造函数的时候我们并不知道要给A的构造函数传什么值所以<code>this.name=undefined</code>，(问题1)且我们new A的时候把A的所有属性和原型都指向了<code>prototype</code>所以A中的所有属性方法 对象都会被传递(问题2)</p>
</li>
</ul>
<h3 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h3><ul>
<li><p>方法：在继承时执行父类的构造函数方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name=name;</span><br><span class="line">    <span class="keyword">this</span>.list=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">&#125;</span><br><span class="line">A.prototype.getName=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="keyword">this</span>.name)&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubA</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    A.call(<span class="keyword">this</span>,name);</span><br><span class="line">    <span class="keyword">this</span>.subName=<span class="string">'sub'</span>+<span class="keyword">this</span>.name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>问题：</p>
<p><img src="/2020/05/15/JavaScript%E5%85%A8%E8%A7%A3JavaScript%E9%83%A8%E5%88%86(%E4%BA%8C)%E5%AF%B9%E8%B1%A1%E3%80%81%E5%8E%9F%E5%9E%8B%E3%80%81%E7%BB%A7%E6%89%BF/%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%BB%A7%E6%89%BF.PNG" alt></p>
<p>由图可知</p>
<ol>
<li>该方式无法获得父类的prototype上的属性</li>
</ol>
</li>
<li><p>原因：当我们执行new SubA的时候<code>A.call...</code>会执行，因此会把name和list拿过来赋值给当前的this也就是SubA但是由于只执行了这一个方法就仅仅相当执行了赋值操作，对父类原型和原型链上的内容无任何处理</p>
</li>
</ul>
<h3 id="组合继承-1"><a href="#组合继承-1" class="headerlink" title="组合继承"></a>组合继承</h3><ul>
<li><p>方法：类式继承+构造函数继承</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name=name;</span><br><span class="line">    <span class="keyword">this</span>.list=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">&#125;</span><br><span class="line">A.prototype.getName=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="keyword">this</span>.name)&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubA</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    A.call(<span class="keyword">this</span>,name);</span><br><span class="line">    <span class="keyword">this</span>.subName=<span class="string">'sub'</span>+<span class="keyword">this</span>.name;</span><br><span class="line">&#125;</span><br><span class="line">SubA.prototype=<span class="keyword">new</span> A()</span><br></pre></td></tr></table></figure>
</li>
<li><p>问题：</p>
<p><img src="/2020/05/15/JavaScript%E5%85%A8%E8%A7%A3JavaScript%E9%83%A8%E5%88%86(%E4%BA%8C)%E5%AF%B9%E8%B1%A1%E3%80%81%E5%8E%9F%E5%9E%8B%E3%80%81%E7%BB%A7%E6%89%BF/%E7%BB%84%E5%90%88%E5%BC%8F%E7%BB%A7%E6%89%BF.PNG" alt></p>
<p>由图可知</p>
<ol>
<li>会继承一堆没有用的函数和属性</li>
</ol>
</li>
<li><p>原因：当我们执行new SubA中A.call…`会执行，因此会把name和list拿过来赋值给当前的this也就是SubA，在外面newA的时候又把A中的属性拿了过来</p>
</li>
</ul>
<h3 id="寄生式组合继承"><a href="#寄生式组合继承" class="headerlink" title="寄生式组合继承"></a>寄生式组合继承</h3><ul>
<li><p>方法：在组合继承的基础上寻找一个干净的中间量只继承原型(寄生)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name=name;</span><br><span class="line">    <span class="keyword">this</span>.list=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">&#125;</span><br><span class="line">A.prototype.getName=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="keyword">this</span>.name)&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubA</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    A.call(<span class="keyword">this</span>,name);</span><br><span class="line">    <span class="keyword">this</span>.subName=<span class="string">'sub'</span>+<span class="keyword">this</span>.name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//SubA.prototype=new A()改造成=&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inhertPrototype</span>(<span class="params">subClass,superClass</span>)</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">whippingBoy</span>(<span class="params"></span>)</span>&#123;&#125;;<span class="comment">//被寄生函数</span></span><br><span class="line">    whippingBoy.prototype=superClass.prototype;</span><br><span class="line">    subClass.prototype=<span class="keyword">new</span> whippingBoy();</span><br><span class="line">&#125;</span><br><span class="line">inhertPrototype(SubA,A);</span><br></pre></td></tr></table></figure>
</li>
<li><p>问题：</p>
<p><img src="/2020/05/15/JavaScript%E5%85%A8%E8%A7%A3JavaScript%E9%83%A8%E5%88%86(%E4%BA%8C)%E5%AF%B9%E8%B1%A1%E3%80%81%E5%8E%9F%E5%9E%8B%E3%80%81%E7%BB%A7%E6%89%BF/%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%BB%A7%E6%89%BF.PNG" alt></p>
<p>由图可知</p>
<ol>
<li>该方式无法获得父类的prototype上的属性</li>
</ol>
</li>
<li><p>原因：当我们执行new SubA的时候<code>A.call...</code>会执行，因此会把name和list拿过来赋值给当前的this也就是SubA但是由于只执行了这一个方法就仅仅相当执行了赋值操作，对父类原型和原型链上的内容无任何处理</p>
</li>
</ul>
<h3 id="组合继承-2"><a href="#组合继承-2" class="headerlink" title="组合继承"></a>组合继承</h3><ul>
<li><p>方法：类式继承+构造函数继承</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name=name;</span><br><span class="line">    <span class="keyword">this</span>.list=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">&#125;</span><br><span class="line">A.prototype.getName=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="keyword">this</span>.name)&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubA</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    A.call(<span class="keyword">this</span>,name);</span><br><span class="line">    <span class="keyword">this</span>.subName=<span class="string">'sub'</span>+<span class="keyword">this</span>.name;</span><br><span class="line">&#125;</span><br><span class="line">SubA.prototype=<span class="keyword">new</span> A()</span><br></pre></td></tr></table></figure>
</li>
<li><p>结果</p>
</li>
</ul>
<p><img src="/2020/05/15/JavaScript%E5%85%A8%E8%A7%A3JavaScript%E9%83%A8%E5%88%86(%E4%BA%8C)%E5%AF%B9%E8%B1%A1%E3%80%81%E5%8E%9F%E5%9E%8B%E3%80%81%E7%BB%A7%E6%89%BF/%E5%AF%84%E7%94%9F.PNG" alt></p>
]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript全解</tag>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript全解:DOM部分</title>
    <url>/2020/05/15/JavaScript%E5%85%A8%E8%A7%A3BOM%E9%83%A8%E5%88%86/</url>
    <content><![CDATA[<p><img src="/2020/05/15/JavaScript%E5%85%A8%E8%A7%A3BOM%E9%83%A8%E5%88%86/web.png" alt></p>
<h1 id="BOM"><a href="#BOM" class="headerlink" title="BOM"></a>BOM</h1><h2 id="BOM简介"><a href="#BOM简介" class="headerlink" title="BOM简介"></a>BOM简介</h2><ul>
<li><p><strong>什么是BOM</strong>:BOM(Broswer Object Model):浏览器对象模型，是来描述浏览器对象之间的层次关系的模型，每个浏览器都有各自的BOM实现，我们用BOM的API来完成浏览器的各种操作</p>
</li>
<li><p><strong>BOM组成</strong>:BOM最大的对象是window，里面存放了其他多个对象</p>
<a id="more"></a>

<p><img src="/2020/05/15/JavaScript%E5%85%A8%E8%A7%A3BOM%E9%83%A8%E5%88%86/BOM.jpg" alt>核心 1. </p>
</li>
</ul>
<ol>
<li><p>Location对象：地址对象，存放当前访问的url信息</p>
</li>
<li><p>Navigator对象：浏览器对象，存放当前浏览器的一些基础信息</p>
</li>
<li><p>Screen对象：屏幕对象，存放当前浏览器页面屏幕的信息</p>
</li>
<li><p>history:历史对象，存放浏览器访问页面历史信息</p>
</li>
</ol>
<h2 id="window自带属性和事件"><a href="#window自带属性和事件" class="headerlink" title="window自带属性和事件"></a>window自带属性和事件</h2><ul>
<li><h3 id="加载-window-onload"><a href="#加载-window-onload" class="headerlink" title="加载(window.onload)"></a>加载(window.onload)</h3><p>页面所有内容加载完成之后执行加载</p>
<p><strong>与DOMContentLoader的区别</strong></p>
<p>​    window.onload需要等页面所有内容加载完成后再执行，DOMContentLoader只需要dom对象加载完成后    即可执行</p>
</li>
<li><h3 id="窗口变化-window-reseize"><a href="#窗口变化-window-reseize" class="headerlink" title="窗口变化(window.reseize)"></a>窗口变化(window.reseize)</h3><p>窗口页面大小发生变化</p>
<p>innerWidth:浏览器宽度</p>
<p>innerHeight：浏览器高度</p>
</li>
<li><h3 id="定时器-window-setTimeout-window-setInterval"><a href="#定时器-window-setTimeout-window-setInterval" class="headerlink" title="定时器(window.setTimeout/window.setInterval)"></a>定时器(window.setTimeout/window.setInterval)</h3><ul>
<li>setTimeout(fn,times)<ul>
<li>fn：定时器执行函数</li>
<li>times：定时器延迟时间(毫秒)</li>
</ul>
</li>
<li>setInterval(fn,times)</li>
<li>异同<ul>
<li>同：<ol>
<li>参数内容和意义相同，延时器单位都是毫秒返回定时器的特殊id</li>
<li>都需要清除定时器</li>
<li>times都有一个最小间隔时间，不能真的设置为0。H5中为4ms</li>
<li>都是宏任务，属于异步操作</li>
</ol>
</li>
<li>异<ol>
<li>setTimeout延迟执行一次，setInterval间隔执行</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li><h3 id="offset、client、scroll"><a href="#offset、client、scroll" class="headerlink" title="offset、client、scroll"></a>offset、client、scroll</h3><blockquote>
<p>所有系列的内容都是值没有单位的，且都是<strong><font color="red">只读</font></strong>的</p>
</blockquote>
<p><img src="/2020/05/15/JavaScript%E5%85%A8%E8%A7%A3BOM%E9%83%A8%E5%88%86/offclient.jpg" alt></p>
<h4 id="offset-元素偏移量"><a href="#offset-元素偏移量" class="headerlink" title="offset(元素偏移量)"></a>offset(元素偏移量)</h4><blockquote>
<p>获取当前元素距离第一个带有定位的父元素的位置</p>
</blockquote>
<ul>
<li><strong>offsetTop/offsetLeft</strong>：相对于第一个带有定位的父元素上/左边框方偏移量</li>
<li><strong>offsetWidth/offsetHeight</strong>：返回元素的宽/高(包含元素所有的margin，padding，content的总和)</li>
</ul>
<h4 id="client-可视区偏移"><a href="#client-可视区偏移" class="headerlink" title="client(可视区偏移)"></a>client(可视区偏移)</h4><blockquote>
<p>获取当前元素距离页面左上角(<strong>document</strong>)的位置偏移</p>
</blockquote>
<ul>
<li><strong>clientTop/clientLeft</strong>：相对于第一个带有定位的父元素上/左边框方偏移量</li>
<li><strong>clientWidth/clientHeight</strong>：返回当前元素的宽/高(包含元素padding，content的总和<strong><font color="red">不包含margin</font></strong>)</li>
</ul>
<h4 id="scroll-实际内容"><a href="#scroll-实际内容" class="headerlink" title="scroll(实际内容)"></a>scroll(实际内容)</h4><blockquote>
<p>获取当前元素距离实际内容</p>
</blockquote>
<ul>
<li><strong>scrollTop/scrollLeft</strong>：被卷去的内容距离容器上/左边框偏移量</li>
<li><strong>clientWidth/clientHeight</strong>：返回当前元素的实际宽/高(<strong><font color="red">只包含内容</font></strong>)</li>
</ul>
<h4 id="页面整体滚动"><a href="#页面整体滚动" class="headerlink" title="页面整体滚动"></a>页面整体滚动</h4><ul>
<li><p><strong>pageXOffset</strong>： 返回当前页面相对于窗口显示区左上角的 X 位置。 </p>
</li>
<li><p><strong>pageYOffset</strong> ：返回当前页面相对于窗口显示区左上角的 Y 位置。 </p>
</li>
</ul>
</li>
</ul>
<h3 id="this"><a href="#this" class="headerlink" title="this"></a>this</h3><h4 id="什么是this"><a href="#什么是this" class="headerlink" title="什么是this"></a>什么是this</h4><p><code>this</code>在js中是一个关键字，是一个指针，指向我们调用函数的对象。</p>
<h4 id="执行上下文"><a href="#执行上下文" class="headerlink" title="执行上下文"></a>执行上下文</h4><p> 执行上下文 是语言规范中的一个概念，大致等同于函数的执行“环境”。具体的有：变量作用域（和 <em>作用域链条</em>，闭包里面来自外部作用域的变量），函数参数，以及 <code>this</code> 对象的值。</p>
<h4 id="this指向"><a href="#this指向" class="headerlink" title="this指向"></a>this指向</h4><ol>
<li>在全局作用域或者普通函数中使用时指向的是全局对象(window)</li>
<li>在方法中谁调用this就指向谁(全局方法的this指向window，setTimeout=&gt;window.setTimeout)</li>
<li>在构造函数中this指向构造函数的实例</li>
<li>箭头函数本身没有this对象，函数中this就是父级函数中的this</li>
</ol>
<h5 id="修改this指向"><a href="#修改this指向" class="headerlink" title="修改this指向"></a>修改this指向</h5><blockquote>
<p>调用函数时通过以下方法将执行上下文和对应参数传入，只用传入的指向上下文代替原本的this</p>
</blockquote>
<ol>
<li><p>bind()：不需要执行函数就可以将 <code>this</code> 的值准确设置到你选择的一个对象上。还可以通过逗号隔开传递多个参数，如 <code>func.bind(this, param1, param2, ...)</code> 。</p>
</li>
<li><p>apply()：将 <code>this</code> 的值准确设置到你选择的一个对象上。第二个参数是一个数组，数组的每一项是你希望传递给函数的参数。最后执行函数。</p>
</li>
<li><p>call()：将 <code>this</code> 的值准确设置到你选择的一个对象上，然后想 <code>bind</code> 一样通过逗号分隔传递多个参数给函数。如：<code>print.call(this, param1, param2, ...)</code>。最后执行函数。</p>
</li>
</ol>
<h2 id="window内置对象"><a href="#window内置对象" class="headerlink" title="window内置对象"></a>window内置对象</h2><h4 id="Location对象"><a href="#Location对象" class="headerlink" title="Location对象"></a>Location对象</h4><blockquote>
<p>用于设置或获取页面的URL，并可以对其解析</p>
</blockquote>
<h4 id="URL-："><a href="#URL-：" class="headerlink" title="** URL**："></a>** URL**：</h4><h4 id="同一资源定位符，是互联网上标准资源的地址"><a href="#同一资源定位符，是互联网上标准资源的地址" class="headerlink" title="同一资源定位符，是互联网上标准资源的地址"></a>同一资源定位符，是互联网上标准资源的地址</h4><p><strong>url组成</strong>：</p>
<p><img src="/2020/05/15/JavaScript%E5%85%A8%E8%A7%A3BOM%E9%83%A8%E5%88%86/URL.jpg" alt></p>
<ul>
<li>protocol/schemel 协议，常用的协议是http</li>
<li>hostname/Domain 主机地址，可以是域名，也可以是IP地址</li>
<li>port 端口 http协议默认端口是：80端口，如果不写默认就是:80端口</li>
<li>path 路径 网络资源在服务器中的指定路径</li>
<li>parameter 参数 如果要向服务器传入参数，在这部分输入</li>
<li>query 查询字符串 如果需要从服务器那里查询内容，在这里编辑</li>
<li>fragment 片段 网页中可能会分为不同的片段，如果想访问网页后直接到达指定位置，可以在这部分设置</li>
</ul>
<h4 id="Location-属性"><a href="#Location-属性" class="headerlink" title="Location 属性"></a>Location 属性</h4><ul>
<li><p>hash：保存当前url中的哈希值（url中#号后面的任意个字符），url中不包含哈希值        则返回空串</p>
</li>
<li><p>host：保存当前url中的域名和端口号</p>
</li>
<li><p>href：获取当前页面所有地址</p>
</li>
<li><p>pathName：保存当前url中路径或者文件名</p>
</li>
<li><p>port：保存当前url中的端口号</p>
</li>
<li><p>protocol：保存当前url使用的协议</p>
</li>
<li><p>search：保存url中的查询字符串(?xxx)</p>
</li>
<li><p>assign(url):导航到参数url位置并生成一条历史记录（等同与 location.href=url， window.localtion=url)</p>
</li>
<li><p>replace(url):导航到参数rul位置但不生成历史记录</p>
</li>
<li><p>reload(boolean)：重新加载当前文档，传参true表示强制从服务器加载所有资源</p>
</li>
</ul>
<h3 id="Navigator对象"><a href="#Navigator对象" class="headerlink" title="Navigator对象"></a>Navigator对象</h3><blockquote>
<p>存储了浏览器的对应信息</p>
</blockquote>
<ul>
<li><p>userAgent：用户代理字符串，通常用来判断当前使用的是什么浏览器</p>
</li>
<li><p>plugins：保存安装所有插件信息的数组，用来判断当前用户是否安装了页面所必须的插件，IE无此属性（通过ActiveXobject对象来判断）</p>
</li>
</ul>
<h3 id="History对象"><a href="#History对象" class="headerlink" title="History对象"></a>History对象</h3><blockquote>
<p>存放当前浏览器浏览历史</p>
</blockquote>
<p>length(属性):history对象中的记录总数</p>
<p>方法：</p>
<ul>
<li><p>back()：前往浏览器历史条目中后一个URL，后退</p>
</li>
<li><p>forward()：前往浏览器历史条目中前一个URL，前进</p>
</li>
<li><p>go(number)： 可加载历史列表中的某个具体的页面，URL 参数使用的是要访问的 URL，或 URL 的子串。而 number 参数使用的是要访问的 URL 在 History 的 URL 列表中的相对位置。    </p>
</li>
</ul>
<h2 id="浏览器存储"><a href="#浏览器存储" class="headerlink" title="浏览器存储　　　　"></a>浏览器存储　　　　</h2><h3 id="cookie："><a href="#cookie：" class="headerlink" title="cookie："></a>cookie：</h3><p>Cookie：是指由服务端生成，发送给客户端（通常是浏览器），为了辨别用户身份、进行session跟踪而储存在用户本地终端上的数据（通常经过加密）</p>
<p><strong>问题</strong>：</p>
<ol>
<li><p>Cookie会被附加在每个HTTP请求中，所以无形中增加了流量。</p>
</li>
<li><p>由于在HTTP请求中的Cookie是明文传递的，所以安全性成问题。（除非用HTTPS）</p>
</li>
<li><p>Cookie的大小限制在4KB左右。对于复杂的存储需求来说是不够用的。</p>
</li>
</ol>
<h3 id="session："><a href="#session：" class="headerlink" title="session："></a>session：</h3><p>Session：由服务端生成，保存在服务器的内存、缓存、硬盘或数据库中的用对象来存储特定用户会话所需的信息。</p>
<p><strong>问题</strong>：</p>
<ol>
<li><p>session会在一定时间内保存在服务器上，当访问增多，会比较占用服务器的性能</p>
</li>
<li><p>session不能区分路径，同一个用户在访问一个网站期间，所有的session在任何一个地方都可以访问到</p>
</li>
</ol>
<h2 id="WebStorage（localStorage-sessionStorage"><a href="#WebStorage（localStorage-sessionStorage" class="headerlink" title="WebStorage（localStorage/sessionStorage)"></a>WebStorage（localStorage/sessionStorage)</h2><p>Web Storage的概念和cookie相似，区别是它是为了更大容量存储设计的(5M),以键值对的形式存储数据，并提供了一系列操作数据的方法</p>
<p><strong>方法</strong>：</p>
<p><strong>xxx.setItem(key,value),xxx.getItem(key)</strong>：获取/设置WebStorage中的值</p>
<p><strong>xxx.removeItem(key)</strong>:删除WebStorage的key以及key对应的value</p>
<p><strong>xxx.clear()</strong>:清空WebStorage中的所有内容</p>
<p>三者的区别</p>
<table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">Cookie</th>
<th align="left">localStorage</th>
<th align="left">sessionStorage</th>
</tr>
</thead>
<tbody><tr>
<td align="left">数据的生命期</td>
<td align="left">可设置失效时间，默认是关闭浏览器后失效</td>
<td align="left">除非被清除，否则永久保存</td>
<td align="left">仅在当前会话下有效，关闭页面或浏览器后被清除</td>
</tr>
<tr>
<td align="left">存放数据大小</td>
<td align="left">4K左右</td>
<td align="left">一般为5MB</td>
<td align="left">一般为5MB</td>
</tr>
<tr>
<td align="left">与服务器端通信</td>
<td align="left">每次都会携带在HTTP头中，如果使用cookie保存过多数据会带来性能问题</td>
<td align="left">仅在客户端（即浏览器）中保存，不参与和服务器的通信</td>
<td align="left">仅在客户端（即浏览器）中保存，不参与和服务器的通信</td>
</tr>
<tr>
<td align="left">易用性</td>
<td align="left">需要程序员自己封装，源生的Cookie接口不友好</td>
<td align="left">源生接口可以接受，亦可再次封装来对Object和Array有更好的支持</td>
<td align="left">源生接口可以接受，亦可再次封装来对Object和Array有更好的支持</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript全解</tag>
        <tag>HTML</tag>
        <tag>BOM</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript全解:DOM部分</title>
    <url>/2020/04/20/JavaScript%E5%85%A8%E8%A7%A3DOM%E9%83%A8%E5%88%86/</url>
    <content><![CDATA[<p><img src="/2020/04/20/JavaScript%E5%85%A8%E8%A7%A3DOM%E9%83%A8%E5%88%86/web.png" alt></p>
<h1 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h1><h2 id="DOM简介"><a href="#DOM简介" class="headerlink" title="DOM简介"></a>DOM简介</h2><ul>
<li><p><strong>什么是DOM</strong>:DOM(Document Object Model):文档对象模型，它是由W3C推荐的处理可扩展标记语言(XML,HTML)的标准<strong>编程接口</strong>。</p>
</li>
<li><p><strong>DOM组成</strong>:DOM被W3C分成了三个部分/层级</p>
<ol>
<li>核心 DOM 用于任何结构化文档的标准模型</li>
<li>XML DOM 用于 XML 文档的标准模型</li>
<li>HTML DOM用于 HTML 文档的标准模型</li>
</ol>
<blockquote>
<p>本文记录的均是HTML的DOM标准</p>
</blockquote>
</li>
</ul>
<a id="more"></a>

<h2 id="DOM组成"><a href="#DOM组成" class="headerlink" title="DOM组成"></a>DOM组成</h2><blockquote>
<p>在浏览器中每一个页面加载都会被转化成一个文档对象(document),页面上的所有展示内容都由该文档按照层级解析而来这种结构关系也叫做DOM树(DOM数据结构)</p>
</blockquote>
<p><img src="/2020/04/20/JavaScript%E5%85%A8%E8%A7%A3DOM%E9%83%A8%E5%88%86/DOM%E6%A0%91.jpg" alt></p>
<ul>
<li>文档：每一个页面就是一个文档，DOM中用document表示，包含了该页面的所有内容</li>
<li>元素：页面中的有标签，用element表示</li>
<li>节点：网页汇总的所有内容区块(标签，属性，注释等)，用node表示</li>
<li>事件：页面中发生的所有不同的具有交互效果的行为(点击，键盘输入)等</li>
</ul>
<blockquote>
<p>以上四个内容都可以当做对象来看，也就是常说的组成DOM四大对象</p>
</blockquote>
<h2 id="页面中的Document和Element对象"><a href="#页面中的Document和Element对象" class="headerlink" title="页面中的Document和Element对象"></a>页面中的Document和Element对象</h2><ul>
<li><p><strong>获取节点</strong> <em>页面中document，element都提供了来对页面中的元素进行一系列的操作包括(获取、增加、删除等)</em></p>
<ul>
<li><p>获取页面元素getELementByxxx</p>
<ul>
<li>通过id获取<code>getELementById(‘id’)</code>内容是大小写敏感的字符串，下同，返回一个符合要求的元素对象</li>
<li>通过className获取<code>getELementByClassName(‘className’)</code>返回符合要求的伪数组</li>
<li>通过标签名获取<code>getELementByTagName(‘tag’)</code>返回符合要求的伪数组</li>
<li>通过选择器获取<code>querySelector(选择器)</code>返回第一个符合要求元素对象，<code>querySelectorAll(选择器)</code>返回所有符合要求元素对象集合</li>
</ul>
</li>
<li><p>获取页面中的body和html</p>
<ul>
<li>body：<code>document.body</code></li>
<li>html：<code>document.documentElement</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Dom节点操作"><a href="#Dom节点操作" class="headerlink" title="Dom节点操作"></a>Dom节点操作</h3><ul>
<li><p>操作节点的两种方式</p>
<ul>
<li>Attribute：用getAttribute来获取特殊的属性值，用setAttribute来设置元素属性，removeAttribute删除属性(可以增删取原本元素不存在的属性即自定义属性)，修改的是对应标签内容</li>
<li>Prototype：用js的方式获取元素自带属性(width,id等)，直接用element.xx获取，修改的是节点的js对象</li>
</ul>
</li>
<li><p>节点操作的API</p>
<ul>
<li><p>创建元素:</p>
<ul>
<li>document.write</li>
<li>innerHTML</li>
<li>createElement</li>
</ul>
</li>
<li><p>插入：xx.appendChild(节点)在后面追加节点 xx.insertBefore在前面插入节点</p>
</li>
<li><p>获取父元素：xx.parentNode</p>
</li>
<li><p>获取子元素：xx.childNodes/xx.children</p>
</li>
<li><p>获取第一个和最后一个子元素：</p>
<ul>
<li>xx.firstChild/xx.lastChild:返回对应节点可能会包含文本节点</li>
<li>xx.firstElementChild/xx.lastElementChild</li>
</ul>
</li>
<li><p>获取上一个和下一个兄弟节点：xx.perviousSibling/xx.nextSibling</p>
</li>
</ul>
</li>
</ul>
<h3 id="DOM性能优化"><a href="#DOM性能优化" class="headerlink" title="DOM性能优化"></a>DOM性能优化</h3><ul>
<li><p>缓存DOM：将需要频繁获取内容先用对象缓存起来，使用时直接使用对象</p>
</li>
<li><p>合并操作：将频繁操作合并成一次性操作</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//假设向页面的ul中插入100个li</span></span><br><span class="line"><span class="keyword">const</span> listNode=<span class="built_in">document</span>.getElementById(<span class="string">'list'</span>)</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">传统方法</span></span><br><span class="line"><span class="comment">引发了100次的DOM重新渲染</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">    <span class="keyword">let</span> li=<span class="built_in">document</span>.creatElement(<span class="string">'li'</span>)</span><br><span class="line">    li.innerElement=<span class="string">`List item <span class="subst">$&#123;i&#125;</span>`</span></span><br><span class="line">    listNode.appendChild(li)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">改进方法 创建一个代码片段</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//创建一个代码片段 这是一个游离的区域并不在DOM中</span></span><br><span class="line"><span class="keyword">let</span> freg=<span class="built_in">document</span>.creatDocumentFragment()</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">    <span class="keyword">let</span> li=<span class="built_in">document</span>.creatElement(<span class="string">'li'</span>)</span><br><span class="line">    li.innerElement=<span class="string">`List item <span class="subst">$&#123;i&#125;</span>`</span></span><br><span class="line">    freg.appendChild(li)</span><br><span class="line">    <span class="comment">// 将所有操作都缓存进该区域</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//真正执行插入操作，只引发1次DOM重新渲染</span></span><br><span class="line">listNode.appendChild(frag)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><h3 id="事件要素"><a href="#事件要素" class="headerlink" title="事件要素"></a>事件要素</h3><ol>
<li><p>事件源：事件触发对象</p>
<ol start="2">
<li>事件类型：事件交互类型</li>
<li>事件处理函数：事件处理程序</li>
</ol>
</li>
</ol>
<h3 id="事件注册"><a href="#事件注册" class="headerlink" title="事件注册"></a>事件注册</h3><h4 id="传统方式"><a href="#传统方式" class="headerlink" title="传统方式"></a>传统方式</h4><ul>
<li>方式：事件源.onXxx/<code>&lt;button onClick=&#39;xxx&#39;&gt;</code></li>
<li>事件唯一，前面事件函数会被覆盖注册的事件函数所覆盖，只会执行最后一次注册的函数</li>
</ul>
<h4 id="方法监听"><a href="#方法监听" class="headerlink" title="方法监听"></a>方法监听</h4><ul>
<li><p>方式：xxx.addEventListener(type,listener,useCapture)</p>
<ul>
<li>type:事件类型的字符串，click，mousemove等</li>
<li>listener：事件处理函数</li>
<li>useCapture(可选，默认false)：事件触发方式true捕获阶段触发，false事件冒泡阶段触发</li>
</ul>
</li>
<li><p>事件不唯一，按照事件注册顺序执行</p>
</li>
</ul>
<h3 id="事件删除"><a href="#事件删除" class="headerlink" title="事件删除"></a>事件删除</h3><h4 id="传统"><a href="#传统" class="headerlink" title="传统"></a>传统</h4><p>xxx.onXXX=null</p>
<h4 id="方法监听-1"><a href="#方法监听-1" class="headerlink" title="方法监听"></a>方法监听</h4><p>xxx.removeEventListener(type,function)</p>
<ul>
<li>type:：类型</li>
<li>function：处理事件名称</li>
</ul>
<h3 id="事件流"><a href="#事件流" class="headerlink" title="事件流"></a>事件流</h3><blockquote>
<p>事件流是描述页面接收事件的顺序，当事件发生时会在元素节点之间按照特定的顺序传播，这个过程叫DOM事件流</p>
</blockquote>
<h4 id="事件流过程"><a href="#事件流过程" class="headerlink" title="事件流过程"></a>事件流过程</h4><p><img src="/2020/04/20/JavaScript%E5%85%A8%E8%A7%A3DOM%E9%83%A8%E5%88%86/%E4%BA%8B%E4%BB%B6%E6%B5%81.jpg" alt></p>
<ol>
<li>捕获阶段：从最外层document阶段开始向子节点依次传递事件</li>
<li>当前目标阶段：触发事件的最具体元素</li>
<li>冒泡阶段：从最开始触发事件的那个元素开始向父元素依次传播事件</li>
</ol>
<h4 id="事件对象-event"><a href="#事件对象-event" class="headerlink" title="事件对象(event)"></a>事件对象(event)</h4><blockquote>
<p>每一个事件上注册的函数都会带有一个默认的参数，里面包含了该事件一系列的相关内容</p>
</blockquote>
<ul>
<li>e.target:最初始事件触发的对象</li>
<li>e.type:事件的类型</li>
<li>e.preventDefault：阻止默认事件</li>
<li>e.stopPropagation:阻止事件冒泡</li>
<li>e.currentTarget:当前绑定的捕获事件对象</li>
</ul>
<h4 id="事件委托-事件代理"><a href="#事件委托-事件代理" class="headerlink" title="事件委托(事件代理)"></a>事件委托(事件代理)</h4><blockquote>
<p>利用事件的冒泡机制将众多相同内容不同数据的子元素处理事件移植到父元素中，在父元素中进行统一处理</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"ul"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>4<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">        <span class="comment">//在一个ul中每次点击li获取对应的数据</span></span></span><br><span class="line">        /*</span><br><span class="line">        传统方式给每一个li绑定事件</span><br><span class="line">        */</span><br><span class="line"><span class="javascript">        <span class="keyword">const</span> li = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'li'</span>)</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">for</span> (<span class="keyword">const</span> i of li) &#123;</span></span><br><span class="line"><span class="actionscript">            i.onclick = <span class="function"><span class="keyword">function</span> <span class="params">(e)</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">                <span class="keyword">if</span> (e.target.nodeName === <span class="string">'LI'</span>) &#123;</span></span><br><span class="line">                    alert(e.target.innerText)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"><span class="actionscript">        <span class="comment">//事件委托 通过冒泡机制在父元素节点ul中统一处理</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">const</span> ul = <span class="built_in">document</span>.getElementById(<span class="string">'ul'</span>);</span></span><br><span class="line"><span class="actionscript">        ul.onclick = <span class="function"><span class="keyword">function</span> <span class="params">(e)</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">            <span class="keyword">if</span> (e.target.nodeName === <span class="string">'LI'</span>) &#123;</span></span><br><span class="line">                alert(e.target.innerText)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript全解</tag>
        <tag>DOM</tag>
        <tag>HTML</tag>
      </tags>
  </entry>
</search>
