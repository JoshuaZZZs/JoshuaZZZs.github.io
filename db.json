{"meta":{"version":1,"warehouse":"3.0.2"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":0,"renderable":0},{"_id":"source/README","path":"README","modified":0,"renderable":0},{"_id":"themes/ayer/source/404.html","path":"404.html","modified":0,"renderable":1},{"_id":"themes/ayer/source/favicon.ico","path":"favicon.ico","modified":0,"renderable":1},{"_id":"themes/ayer/source/css/clipboard.styl","path":"css/clipboard.styl","modified":0,"renderable":1},{"_id":"themes/ayer/source/css/custom.styl","path":"css/custom.styl","modified":0,"renderable":1},{"_id":"themes/ayer/source/dist/main.css","path":"dist/main.css","modified":0,"renderable":1},{"_id":"themes/ayer/source/dist/main.js","path":"dist/main.js","modified":0,"renderable":1},{"_id":"themes/ayer/source/images/ayer-side.svg","path":"images/ayer-side.svg","modified":0,"renderable":1},{"_id":"themes/ayer/source/images/ayer.png","path":"images/ayer.png","modified":0,"renderable":1},{"_id":"themes/ayer/source/images/ayer.svg","path":"images/ayer.svg","modified":0,"renderable":1},{"_id":"themes/ayer/source/images/forkme.png","path":"images/forkme.png","modified":0,"renderable":1},{"_id":"themes/ayer/source/images/cover7.jpg","path":"images/cover7.jpg","modified":0,"renderable":1},{"_id":"themes/ayer/source/images/sponsor.jpg","path":"images/sponsor.jpg","modified":0,"renderable":1},{"_id":"themes/ayer/source/js/busuanzi-2.3.pure.min.js","path":"js/busuanzi-2.3.pure.min.js","modified":0,"renderable":1},{"_id":"themes/ayer/source/js/clickLove.js","path":"js/clickLove.js","modified":0,"renderable":1},{"_id":"themes/ayer/source/js/lazyload.min.js","path":"js/lazyload.min.js","modified":0,"renderable":1},{"_id":"themes/ayer/source/js/tocbot.min.js","path":"js/tocbot.min.js","modified":0,"renderable":1},{"_id":"themes/ayer/source/js/search.js","path":"js/search.js","modified":0,"renderable":1},{"_id":"themes/ayer/source/images/404.jpg","path":"images/404.jpg","modified":0,"renderable":1},{"_id":"themes/ayer/source/images/alipay.jpg","path":"images/alipay.jpg","modified":0,"renderable":1},{"_id":"themes/ayer/source/images/cover2.jpg","path":"images/cover2.jpg","modified":0,"renderable":1},{"_id":"themes/ayer/source/images/wechat.jpg","path":"images/wechat.jpg","modified":0,"renderable":1},{"_id":"themes/ayer/source/js/jquery-2.0.3.min.js","path":"js/jquery-2.0.3.min.js","modified":0,"renderable":1},{"_id":"themes/ayer/source/images/cover6.jpg","path":"images/cover6.jpg","modified":0,"renderable":1},{"_id":"themes/ayer/source/images/cover3.jpg","path":"images/cover3.jpg","modified":0,"renderable":1},{"_id":"themes/ayer/source/images/cover1.jpg","path":"images/cover1.jpg","modified":0,"renderable":1},{"_id":"themes/ayer/source/images/cover4.jpg","path":"images/cover4.jpg","modified":0,"renderable":1},{"_id":"themes/ayer/source/images/cover5.jpg","path":"images/cover5.jpg","modified":0,"renderable":1}],"Cache":[{"_id":"source/CNAME","hash":"97212926fb93f1f559a12cbc14bc0399300c7f9a","modified":1587440452369},{"_id":"source/README","hash":"55aeb39cf7887750e9fa9bf59283642a0445cb9c","modified":1587440452369},{"_id":"themes/ayer/.gitignore","hash":"b253f9829edcd1cf2a1fff279de3091e987dce6e","modified":1587035855800},{"_id":"themes/ayer/.postcssrc","hash":"c171a60205840e3dcd3825d5bbb6b2d19d48ee76","modified":1587035855800},{"_id":"themes/ayer/.stylintrc","hash":"eec4e824067be1a223745ca426aa367c8d482673","modified":1587035855801},{"_id":"themes/ayer/.travis.yml","hash":"5acc6f203681ce88bc2dbb0f86e0b3dd32a243a0","modified":1587035855801},{"_id":"themes/ayer/README.md","hash":"6262f2efa7143ff48d8198060a4a226ccb0e5e4b","modified":1587035855802},{"_id":"themes/ayer/LICENSE","hash":"115a72f86fc1c3f3211398517cd7593a40703334","modified":1587035855801},{"_id":"themes/ayer/_config.yml","hash":"798cee02ef61345caf3ed4a6e75f1bf537fb6a14","modified":1587547872723},{"_id":"themes/ayer/logo.png","hash":"16fbb131601570b21890a922cd6e596691ccff42","modified":1587035855815},{"_id":"themes/ayer/package-lock.json","hash":"f11f5672fff61ff3337665c54e07a9446043e8e9","modified":1587035969392},{"_id":"themes/ayer/package.json","hash":"13fed8473f02f11cb3d12b3c66e3631f479a9ecf","modified":1587035969348},{"_id":"source/_posts/ES6总结二(对象和数组).md","hash":"1377d906b71cdf8b665baf5ac4a19447df907bae","modified":1587037356627},{"_id":"source/_posts/ES6总结一(变量与函数).md","hash":"34ed2b2bb554d5cea0a097772e0a75423b275f01","modified":1587526990779},{"_id":"source/_posts/ES6语法总结三(解构、Set和Map).md","hash":"05dd0e4c48dbb62252715a78e4e0716a22e402eb","modified":1587527060879},{"_id":"source/_posts/ES6语法总结四(迭代生成器、Promise和异步).md","hash":"d3ac1942c202a000fecff8c3ff83e8d21853799d","modified":1587527108409},{"_id":"source/_posts/HelloShips.md","hash":"52cf22a683f9c6e36c5f22f7cb5b29d2626fd591","modified":1587369507717},{"_id":"source/_posts/日系风格调色思路.md","hash":"3fdba61f1ae858c80811d54582afda141f2f2ca3","modified":1587547530090},{"_id":"source/_posts/浅谈SVG.md","hash":"8b025ffba6d16d2e86da789228c976956fbb9e9e","modified":1587037369723},{"_id":"source/_posts/青春向左.md","hash":"57d6ab521d8be0495fa5dbc7b69737853936da70","modified":1587695856274},{"_id":"source/categories/index.md","hash":"93274bf29c5e54a73b9745bbaaf0118b49b194bb","modified":1587036419158},{"_id":"source/tags/index.md","hash":"4767c7493033a7d163a4e9a71395c985779c5c05","modified":1587036442086},{"_id":"themes/ayer/.github/FUNDING.yml","hash":"49e772bb69fec01a4a7bf9d440a28069f3df7970","modified":1587035855800},{"_id":"themes/ayer/languages/de.yml","hash":"d12bd7ebee4772e9f982a760eb7512506c7f2bb5","modified":1587035855802},{"_id":"themes/ayer/languages/default.yml","hash":"217d6347d560eeb47f09def61c545f27b40f672d","modified":1587035855802},{"_id":"themes/ayer/languages/en.yml","hash":"217d6347d560eeb47f09def61c545f27b40f672d","modified":1587035855803},{"_id":"themes/ayer/languages/es.yml","hash":"c85f8dba8ae7b3a5e57cdfa617f5884b9d0b8a89","modified":1587035855803},{"_id":"themes/ayer/languages/fr.yml","hash":"0626e3949158af713f5b80ea490c8316b89479fc","modified":1587035855803},{"_id":"themes/ayer/languages/ja.yml","hash":"86a9d614d96beb9a6e514b155c024bc8964b1160","modified":1587035855804},{"_id":"themes/ayer/languages/ko.yml","hash":"1eb9f1f456bad2833651b2bc256178aedb806df2","modified":1587035855804},{"_id":"themes/ayer/languages/nl.yml","hash":"f9200f7837f5d91d21cd220d698393247249b2a4","modified":1587035855804},{"_id":"themes/ayer/languages/no.yml","hash":"a9c8d5d981a17c1091b892f5dbbbfcbae65b806e","modified":1587035855804},{"_id":"themes/ayer/languages/ru.yml","hash":"2586cc5b7a1d6db96ab00ea6d83e663e591270a3","modified":1587035855805},{"_id":"themes/ayer/languages/pt.yml","hash":"c46d632ac39abe213506f64ebfeea96bc13913a3","modified":1587035855804},{"_id":"themes/ayer/languages/vi.yml","hash":"2303f9ba6f2424eede332fe06f84256f807ff4f5","modified":1587035855805},{"_id":"themes/ayer/languages/zh-CN.yml","hash":"c49e4abdf60740b891f252ce24e37a272a512d4d","modified":1587035855805},{"_id":"themes/ayer/languages/zh-TW.yml","hash":"00f7146f64bef1a4d0fc974c59975786c4e08f60","modified":1587035855805},{"_id":"themes/ayer/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1587035855814},{"_id":"themes/ayer/layout/categories.ejs","hash":"4039d782c0b1c935ad4898a0bf29afc58c95fbde","modified":1587035855814},{"_id":"themes/ayer/layout/index.ejs","hash":"c40a98c0a6f55c27959e44c9e8e4f2619fc2ad3f","modified":1587035855814},{"_id":"themes/ayer/layout/layout.ejs","hash":"63f080aefd0618e359a5fb53027a300c0210aaa5","modified":1587035855814},{"_id":"themes/ayer/layout/page.ejs","hash":"75879224e47b3329d7accfc2403580a2412dce25","modified":1587035855815},{"_id":"themes/ayer/layout/post.ejs","hash":"75879224e47b3329d7accfc2403580a2412dce25","modified":1587035855815},{"_id":"themes/ayer/layout/tags.ejs","hash":"e7c9f93c6f7041a7d2aa95e85cc131b22aa426b7","modified":1587035855815},{"_id":"themes/ayer/scripts/default_config.js","hash":"617c2614d8bd8ffda2f2f84ab54fb18866e39b33","modified":1587035855818},{"_id":"themes/ayer/source/404.html","hash":"871a8a7c25dca0e4cd77f8adf5bf81f9c7ba3987","modified":1587035855828},{"_id":"themes/ayer/source/favicon.ico","hash":"473ba682e828a7e34f24fae320e77b6bed4260c7","modified":1587035855830},{"_id":"themes/ayer/source-src/main.js","hash":"e42992bf24b2864e33ea5fdfab122b5d41851066","modified":1587035855828},{"_id":"source/_posts/ES6总结一(变量与函数)/const声明.png","hash":"b83bce1c45d260f0f73177448bb2f8ecae367f86","modified":1583745929324},{"_id":"source/_posts/ES6总结一(变量与函数)/全局块级绑定2.png","hash":"4d10bffea957ee15057a1e59cad0fec1acc5d3fc","modified":1583744787452},{"_id":"source/_posts/ES6总结一(变量与函数)/全局块级绑定1.png","hash":"37cc0f29aee0221e226dcf282d9a9ee7f5c57a37","modified":1583742326445},{"_id":"source/_posts/ES6语法总结三(解构、Set和Map)/数组解构赋值.png","hash":"2fe333c266dc125cd38573e4b1714487ce93e918","modified":1584448702612},{"_id":"source/_posts/ES6语法总结四(迭代生成器、Promise和异步)/Promise生命周期.png","hash":"08aab9bc9e9350cd2e38cc0facddb10e1c1dc6dc","modified":1585033764014},{"_id":"source/_posts/日系风格调色思路/小森林·夏秋.jpg","hash":"b1d4b612866f0bd35b18717788a665cb37c712d6","modified":1587470315539},{"_id":"themes/ayer/layout/_partial/after-footer.ejs","hash":"271d6ad8e1789b581c3ea02637cf42cef23f2b4a","modified":1587035855806},{"_id":"themes/ayer/layout/_partial/archive-post.ejs","hash":"6b3e77cdbf8271c2a22b839608cccaa651f84e93","modified":1587035855806},{"_id":"themes/ayer/layout/_partial/archive.ejs","hash":"12e04e14a663fb4d30f4a22e92b0c3c2de36aaab","modified":1587035855806},{"_id":"themes/ayer/layout/_partial/article.ejs","hash":"52e57e3182873aeaaca13a5881daa242801a49aa","modified":1587035855806},{"_id":"themes/ayer/layout/_partial/ayer.ejs","hash":"a9b3043ba2fd9a321a3569139993fb0745369594","modified":1587035855808},{"_id":"themes/ayer/layout/_partial/baidu-analytics.ejs","hash":"155327c23607f69989b58845f24d842a54e504b8","modified":1587035855808},{"_id":"themes/ayer/layout/_partial/footer.ejs","hash":"8890b71ae3ab8b7c5f1681758f9204714b5553b2","modified":1587035855808},{"_id":"themes/ayer/layout/_partial/google-analytics.ejs","hash":"3a23d6ae48305c9f1b5c400da780288c2425254b","modified":1587035855808},{"_id":"themes/ayer/layout/_partial/head.ejs","hash":"f60e599d19f4a1c759a00a4c12a349506e65d467","modified":1587035855808},{"_id":"themes/ayer/layout/_partial/katex.ejs","hash":"02cb9da065cd315a06d62d13872dc687c62e9a1f","modified":1587035855809},{"_id":"themes/ayer/layout/_partial/mathjax.ejs","hash":"bcc264b6d6b58b3b692139c4d8b1381da4820da8","modified":1587035855809},{"_id":"themes/ayer/layout/_partial/modal.ejs","hash":"b9caece8b5fb47e250c67f6f80f101f08d04eba9","modified":1587035855809},{"_id":"themes/ayer/layout/_partial/music.ejs","hash":"4a67b36cadf2661a5579a454b7d6e0be34e7a0d4","modified":1587035855809},{"_id":"themes/ayer/layout/_partial/sidebar.ejs","hash":"b7efb7f2b300de23d12ef310d710d809d979f4fd","modified":1587035855813},{"_id":"themes/ayer/layout/_partial/totop.ejs","hash":"b2fc5726168f012bc61845f33a46404ff4065947","modified":1587035855813},{"_id":"themes/ayer/layout/_partial/viewer.ejs","hash":"219f0a0ec2eb35e8ba27a849639a5f634273fb6f","modified":1587035855814},{"_id":"themes/ayer/scripts/filters/index.js","hash":"e0c3b821ecd1cb614569282fb4f6e6f555545f8b","modified":1587035855818},{"_id":"themes/ayer/scripts/filters/meta_generator.js","hash":"86d0b5a475f59324b277824b2de15775505080c6","modified":1587035855818},{"_id":"themes/ayer/scripts/helpers/ayer-plus-vendors.js","hash":"611f3bcd8220312f92c11fa6a5dad02f011068d2","modified":1587035855819},{"_id":"themes/ayer/scripts/helpers/wordcount.js","hash":"2014b5c5053ad737887b61014a045cc1b08799cd","modified":1587035855819},{"_id":"themes/ayer/scripts/lib/core.js","hash":"00509e97554914e5b0a20e0843dc90bcf53461aa","modified":1587035855819},{"_id":"themes/ayer/source/css/clipboard.styl","hash":"145f335d6369744a75c2c39a50f63a88f720f85b","modified":1587035855828},{"_id":"themes/ayer/source/css/custom.styl","hash":"d3dc76192935e696c2c153b014b5c28fbb4c88a7","modified":1587035855828},{"_id":"themes/ayer/source/dist/main.css","hash":"04f8a68c358c6b1f027d7cb88a12a882018f5cca","modified":1587035855829},{"_id":"themes/ayer/source/dist/main.js","hash":"db0c241ade4b1c8069789afee8e4f882462ec366","modified":1587035855830},{"_id":"themes/ayer/source/images/ayer-side.svg","hash":"ad004ce7a873de0f91774f3d5923e010396a07bd","modified":1587035855831},{"_id":"themes/ayer/source/images/ayer.png","hash":"0466c05244273f645d239cd27513bfa3c50308aa","modified":1587035855832},{"_id":"themes/ayer/source/images/ayer.svg","hash":"379c3307f97c364718a1dbc1e52fb14de12eb11a","modified":1587035855832},{"_id":"themes/ayer/source/images/forkme.png","hash":"99c3e21a169421e4f249befb428396c729863a75","modified":1587035855865},{"_id":"themes/ayer/source/images/cover7.jpg","hash":"573bff6899d2d9c5bcba0dc9c60cd1ec9eb8b029","modified":1587035855865},{"_id":"themes/ayer/source/images/sponsor.jpg","hash":"b3efa167f50cad85404c83f21dec2be570ed21dc","modified":1587035855866},{"_id":"themes/ayer/source/js/busuanzi-2.3.pure.min.js","hash":"6e41f31100ae7eb3a6f23f2c168f6dd56e7f7a9a","modified":1587035855867},{"_id":"themes/ayer/source/js/clickLove.js","hash":"a35dfb7ff19796c005ee30b55fd95e39d6d59a89","modified":1587035855867},{"_id":"themes/ayer/source/js/lazyload.min.js","hash":"d9bc50752cd7e331dbd0a833386838397c9a079f","modified":1587035855868},{"_id":"themes/ayer/source/js/tocbot.min.js","hash":"bae97e8a24a05a99335f8e725641c8ca9c50502a","modified":1587035855869},{"_id":"themes/ayer/source/js/search.js","hash":"6d5c093d12e922ad204dab1723b786c35847bf1b","modified":1587035855869},{"_id":"themes/ayer/source-src/css/_darkmode.styl","hash":"278d48e62f94faf55c470e76be57ecb2f9ad5def","modified":1587035855819},{"_id":"themes/ayer/source-src/css/_mixins.styl","hash":"e4804d78ded3714495f8ac9cebdbd2871ed97549","modified":1587035855820},{"_id":"themes/ayer/source-src/css/_normalize.styl","hash":"df9ca719f651c45a88ab4d6afa6d29edf51aeba9","modified":1587035855820},{"_id":"themes/ayer/source-src/css/_extend.styl","hash":"974b9483061fe83f585cc496791ba07e87c78689","modified":1587035855819},{"_id":"themes/ayer/source-src/css/_remixicon.styl","hash":"78f4dd8c613df005d6ecf6a073d96d38bbbe531e","modified":1587035855827},{"_id":"themes/ayer/source-src/css/_variables.styl","hash":"2fdb4425b6213fed28921f53179e825aee0500cf","modified":1587035855827},{"_id":"themes/ayer/source-src/css/style.styl","hash":"07cea9104627ae1957bde7658be816cc19346766","modified":1587035855827},{"_id":"themes/ayer/source-src/js/ayer.js","hash":"e6846036ef2b44d6bef4f5bb60f3bf6b732953eb","modified":1587035855828},{"_id":"themes/ayer/source-src/js/share.js","hash":"e8fd85622f774be877438421c182cd37eb15196e","modified":1587035855828},{"_id":"source/_posts/日系风格调色思路/小森林·冬春.jpg","hash":"81fed6e091b59d40388c761ee46c1869f729cecd","modified":1587469772724},{"_id":"source/_posts/日系风格调色思路/海街日记1.jpg","hash":"f33ffe8fc800f357b44e4df43f3c88cfce3b7da5","modified":1587198820850},{"_id":"source/_posts/日系风格调色思路/海街日记2.jpg","hash":"fc6c69f6620cb63cb9f3ad340ccedc8adb138d19","modified":1587471992630},{"_id":"source/_posts/日系风格调色思路/海街日记3.jpg","hash":"5d72e291b6e866f947104d7b09c308db14bf3a9e","modified":1587469598075},{"_id":"source/_posts/青春向左/自传.jpg","hash":"798bee1e2420e7dacdd3838a936201832a3c6e57","modified":1587650755395},{"_id":"themes/ayer/screenshots/hexo-theme-ayer.png","hash":"4111670e622ce09837b6b9cc641782af75805079","modified":1587035855818},{"_id":"themes/ayer/source/images/404.jpg","hash":"4f36a8d378712427cded03f5166949f5e0ba754c","modified":1587035855830},{"_id":"themes/ayer/source/images/alipay.jpg","hash":"8f5409e29764fca573f1d274003910aa3c919de1","modified":1587035855831},{"_id":"themes/ayer/source/images/cover2.jpg","hash":"f61dd08c95327468c5f6bc5175eff68d00f05b46","modified":1587035855835},{"_id":"themes/ayer/source/images/wechat.jpg","hash":"93a362574a8498e75dca469b7bceb0b321fda387","modified":1587035855866},{"_id":"themes/ayer/source/js/jquery-2.0.3.min.js","hash":"e68550a39c95a6400287b3abd77f40c44f322e50","modified":1587035855868},{"_id":"source/_posts/日系风格调色思路/日系2.jpg","hash":"0bb583f8b401f33f3e86843e14f0d1ed39f95085","modified":1587473301802},{"_id":"source/_posts/日系风格调色思路/日系3.jpg","hash":"6a2a70b02d0a7e37084ec12a1b38ad92c1842f11","modified":1587473324596},{"_id":"source/_posts/青春向左/七号公园.jpg","hash":"05b5b3d4e45a4db65d6e184cdb683ea07ade2fbc","modified":1587194622729},{"_id":"themes/ayer/layout/_partial/post/albums.ejs","hash":"f4cfbabca9f59a9e5aa457a6f2a9cf6f56cd22b3","modified":1587035855809},{"_id":"themes/ayer/layout/_partial/post/busuanzi.ejs","hash":"4c7a9191658395bcac45dcd07c165af8773cffa9","modified":1587035855809},{"_id":"themes/ayer/layout/_partial/post/category.ejs","hash":"89cb32e8d98bad81d3ef33377212e9b253699d3d","modified":1587035855810},{"_id":"themes/ayer/layout/_partial/post/clipboard.ejs","hash":"c93d82de1635536a633b6254b604590ab4428594","modified":1587035855810},{"_id":"themes/ayer/layout/_partial/post/date.ejs","hash":"947f513f7a85fbcf085624e46dc2ae6de8185eec","modified":1587035855810},{"_id":"themes/ayer/layout/_partial/post/gallery.ejs","hash":"6f78a49edc91f230b0a838c77630e9671d8d6089","modified":1587035855810},{"_id":"themes/ayer/layout/_partial/post/gitalk.ejs","hash":"38bb3f504a878d163a430ce6253dae3142a8fae5","modified":1587035855811},{"_id":"themes/ayer/layout/_partial/post/justifiedGallery.ejs","hash":"a313df6a014a0f2ba6b869dabc56bacb8ff6324d","modified":1587035855811},{"_id":"themes/ayer/layout/_partial/post/minivaline.ejs","hash":"f3d8fb65059e9f8c427627050671279fe4e0931f","modified":1587035855811},{"_id":"themes/ayer/layout/_partial/post/nav.ejs","hash":"a73010cbbc463089a1376889850fb0890143c988","modified":1587035855811},{"_id":"themes/ayer/layout/_partial/post/search.ejs","hash":"47c818c236b063d6ce0c41e0824f9f10a3521414","modified":1587035855812},{"_id":"themes/ayer/layout/_partial/post/share.ejs","hash":"9a978d55358878c97186ed010e536e1b314adb35","modified":1587035855812},{"_id":"themes/ayer/layout/_partial/post/tag.ejs","hash":"694b5101bcc44c9f9c1cc62e5ad2fdfb4b7c7a07","modified":1587035855812},{"_id":"themes/ayer/layout/_partial/post/title.ejs","hash":"e55c57b8cb8c8acf0ed998ea31c2fbc1d6256027","modified":1587035855812},{"_id":"themes/ayer/layout/_partial/post/tocbot.ejs","hash":"17ac504f2a6d561765046a0ba19dcce504104517","modified":1587035855812},{"_id":"themes/ayer/layout/_partial/post/topping.ejs","hash":"de2c50fb5b7a816287c6d048a2a22ae9c29abcdd","modified":1587035855812},{"_id":"themes/ayer/layout/_partial/post/valine.ejs","hash":"070662f5e0ccfcdecbae3607c224b2ccf7cdefe9","modified":1587035855813},{"_id":"themes/ayer/layout/_partial/post/word.ejs","hash":"5b785368a0a6f3b5538aa1b9e7574daa8dfb0df6","modified":1587035855813},{"_id":"themes/ayer/source/images/cover6.jpg","hash":"a5b8a5dddff2607fee5fccf5fdef3b214a8468cc","modified":1587035855864},{"_id":"themes/ayer/source-src/css/_partial/albums.styl","hash":"5802253789028a4d9dac474168fc7132045e72ff","modified":1587035855821},{"_id":"themes/ayer/source-src/css/_partial/apple.styl","hash":"333f9e59dc6625c4dee126a1c1a9c25ce9292655","modified":1587035855822},{"_id":"themes/ayer/source-src/css/_partial/archive.styl","hash":"c20ad235d8aab4bc77a2372a053d86fe0069f7fe","modified":1587035855822},{"_id":"themes/ayer/source-src/css/_partial/article.styl","hash":"61c9b30c01c6ecd3e90ae3f568df690e70754c7f","modified":1587035855822},{"_id":"themes/ayer/source-src/css/_partial/categories.styl","hash":"b86d2385a095c60ef012641874e222febf017cd3","modified":1587035855823},{"_id":"themes/ayer/source-src/css/_partial/ayer.styl","hash":"cfcae3839170f2d04ea504a3cd3d62a9cde6647d","modified":1587035855823},{"_id":"themes/ayer/source-src/css/_partial/articles.styl","hash":"ddbe833939180afdc832659c5cdad08f77ef4f46","modified":1587035855822},{"_id":"themes/ayer/source-src/css/_partial/float.styl","hash":"b1abfdfd05e74745484f7e6d043ef2842b3f6b41","modified":1587035855823},{"_id":"themes/ayer/source-src/css/_partial/footer.styl","hash":"ae22e9d1525f267be368359ed0096f26791b809e","modified":1587035855823},{"_id":"themes/ayer/source-src/css/_partial/gallery.styl","hash":"f5eae1b0030cfd97f1646844c9d3f692dbb38946","modified":1587035855824},{"_id":"themes/ayer/source-src/css/_partial/gitalk.styl","hash":"0678e8b330daea56fa30d14e97de73289a7d6f22","modified":1587035855824},{"_id":"themes/ayer/source-src/css/_partial/highlight.styl","hash":"1210f704aae34ef653e3a458cccb700b05353ea1","modified":1587035855824},{"_id":"themes/ayer/source-src/css/_partial/justifiedGallery.styl","hash":"9828c78fb59c3ea3de7cce2569313d12c4b1a6ff","modified":1587035855824},{"_id":"themes/ayer/source-src/css/_partial/layout.styl","hash":"11cb01af7fc318f371e4df414a7f3301b80e8cb6","modified":1587035855824},{"_id":"themes/ayer/source-src/css/_partial/lists.styl","hash":"dc45f8b1a5942d4d979fb0859bc47a86f73fe0a9","modified":1587035855825},{"_id":"themes/ayer/source-src/css/_partial/mobile.styl","hash":"ba8ab5a0280b953aa97435ff8946cbcbb2755a27","modified":1587035855825},{"_id":"themes/ayer/source-src/css/_partial/navbar.styl","hash":"30d7e1de22185c4b4da33eef66b5eb96f9e5ae98","modified":1587035855825},{"_id":"themes/ayer/source-src/css/_partial/pace.styl","hash":"bbda18c692fc66ae99e45347ff52c14e44a08e3b","modified":1587035855825},{"_id":"themes/ayer/source-src/css/_partial/reward.styl","hash":"a032e43e5842f752fd612ddbbd7943ecece7c35b","modified":1587035855825},{"_id":"themes/ayer/source-src/css/_partial/search.styl","hash":"3f2c7bd1371f6f25aec7c581dbae7b52f95ec4c6","modified":1587035855826},{"_id":"themes/ayer/source-src/css/_partial/share.styl","hash":"4a6e6ac9156553dd5cee1eeee8fdc6f1f8a5d117","modified":1587035855826},{"_id":"themes/ayer/source-src/css/_partial/sidebar.styl","hash":"cdc7bea47a768b18991decde0d38c554399621ee","modified":1587035855826},{"_id":"themes/ayer/source-src/css/_partial/tag.styl","hash":"6072aa6bd16e0a1e75f0258d7b20587cab56fff8","modified":1587035855826},{"_id":"themes/ayer/source-src/css/_partial/tocbot.styl","hash":"05e5ce77238111ce61e9cc3732a76e39e387c6aa","modified":1587035855826},{"_id":"themes/ayer/source-src/css/_partial/totop.styl","hash":"b6010788be1d99a345abcf0cf9cdf0a564b90d3c","modified":1587035855826},{"_id":"source/_posts/日系风格调色思路/原图1.jpg","hash":"e85119f4178defc684a8f0a8275f7d22ff2b13db","modified":1587477659503},{"_id":"source/_posts/青春向左/人生海海.jpg","hash":"1d2c2173f11794b218754e73808a9471740e4e08","modified":1587194609113},{"_id":"themes/ayer/source/images/cover3.jpg","hash":"7b4e7c9ce19ce5d5c1588b2567e88ecbb04370af","modified":1587035855838},{"_id":"source/_posts/日系风格调色思路/日系1.jpg","hash":"fcd7e3f90f6b7116a9b6678dbb12de1fbf0d590f","modified":1587473262191},{"_id":"themes/ayer/source/images/cover1.jpg","hash":"e019fbed6158ae3e4ec3d255b41bddc1afcbfa90","modified":1587035855834},{"_id":"source/_posts/日系风格调色思路/photograph.jpg","hash":"105bd08770894fa454c0fe2e7c6430a32cec6dff","modified":1587545966040},{"_id":"source/_posts/public/images/photograph.jpg","hash":"105bd08770894fa454c0fe2e7c6430a32cec6dff","modified":1587545966040},{"_id":"themes/ayer/source/images/cover4.jpg","hash":"77040e609d2f1c60e00a8e47cb95b25bf7ff5b9c","modified":1587035855842},{"_id":"themes/ayer/source/images/cover5.jpg","hash":"1a2d6182d94b015a45fe4bf8e8a239dfcc0ef776","modified":1587035855863},{"_id":"source/_posts/青春向左/演唱会.jpg","hash":"0f9f0b56af0436c9e6d7786273fb6cc3c35ca4a3","modified":1587650462648},{"_id":"public/search.xml","hash":"f6f876a2ee673377eef088b284fda12bed654c57","modified":1588037641028},{"_id":"public/categories/index.html","hash":"b492c75eda50f2aec51975b2cd377c17be6b2758","modified":1588037641028},{"_id":"public/tags/index.html","hash":"d87704539b00dde55ef2146b0030f95b43da9bf7","modified":1588037641028},{"_id":"public/archives/index.html","hash":"8baa533e56848b82263fc822023e0718a1ecf3d6","modified":1588037641028},{"_id":"public/archives/2019/index.html","hash":"1bdc38011eb65d5d24fc147c8c487d86faad9178","modified":1587650960899},{"_id":"public/archives/2019/10/index.html","hash":"5272021ad1deaf52cd8d59b06dba1a5a95e59fb2","modified":1587650960899},{"_id":"public/archives/2019/11/index.html","hash":"4079857b7666cc272ab5c9d6153cd808d4ad9613","modified":1587650960899},{"_id":"public/archives/2019/12/index.html","hash":"c95f48578a80e25bd49c6e301b9cc86dfece6038","modified":1587650960899},{"_id":"public/archives/2020/index.html","hash":"59d4eb071e907db927a5b6f2523712d5140abc0c","modified":1588037641028},{"_id":"public/archives/2020/01/index.html","hash":"917dcbedf3ede5429848fb8db0f41df1c5bd607b","modified":1588037641028},{"_id":"public/archives/2020/04/index.html","hash":"4cd11c555e91f76791cdc42070e917298354ba50","modified":1587650960899},{"_id":"public/categories/web前端/index.html","hash":"561bf5a9bf5a9b343d9aba894ea993a048ed1b5e","modified":1587650960899},{"_id":"public/categories/摄影/index.html","hash":"61631098b7b9f31a754de33866e429ceed1453da","modified":1587650960899},{"_id":"public/categories/随笔/index.html","hash":"885fb92fb3a797c9e73029c0ae7ded6b473d874f","modified":1587650960899},{"_id":"public/tags/前端/index.html","hash":"a83eb12cfc610d1c953b0643c3ca81da38c12b92","modified":1587650960899},{"_id":"public/tags/ES6/index.html","hash":"8674058081f9ef186b82df1421b2adf3aa5b1b5b","modified":1587650960899},{"_id":"public/tags/后期/index.html","hash":"3efbf562b99affe68797d65584292fb78a2c5da6","modified":1587650960899},{"_id":"public/tags/随笔/index.html","hash":"1b2c04b0c61fd4168e0086706a8a700ac3457732","modified":1587650960899},{"_id":"public/tags/调色/index.html","hash":"d4bdf9ea6fbc12865e07e1048c85618a74cc62cb","modified":1587650960899},{"_id":"public/tags/摄影/index.html","hash":"e13914ce812625b095f2316891e07825954a09db","modified":1587650960899},{"_id":"public/tags/五月天/index.html","hash":"64b0c6deeb848a7a77f28f944d609b35578584a7","modified":1587650960899},{"_id":"public/tags/生活/index.html","hash":"3c44b4d4881e9b21b497812281d65d8240de2432","modified":1587650960899},{"_id":"public/tags/杂谈/index.html","hash":"a0e08d820dcfae86dc669084603855bc4d293795","modified":1587650960899},{"_id":"public/tags/Hello-Ships/index.html","hash":"28965170b9b3501dd4e37f364d5d6af716ff295a","modified":1587650960899},{"_id":"public/tags/SVG/index.html","hash":"a76f9676bcca25608d85022d4b5712928b71b2b9","modified":1587650960899},{"_id":"public/2020/04/09/日系风格调色思路/index.html","hash":"a11471a507d611513bf85369b1182c3ff612a693","modified":1588037641028},{"_id":"public/2020/01/20/ES6语法总结四(迭代生成器、Promise和异步)/index.html","hash":"04a28bf15aafe601b5e8ceaaebbc6f541c7fd593","modified":1588037641028},{"_id":"public/2020/01/05/ES6语法总结三(解构、Set和Map)/index.html","hash":"2fd116580159c054301d6a71a9a857e72c807ce2","modified":1587650960899},{"_id":"public/2019/12/07/浅谈SVG/index.html","hash":"68db48abcef209a83fbd9a0cc590b66f670f972f","modified":1587650960899},{"_id":"public/2019/11/21/ES6总结二(对象和数组)/index.html","hash":"1b83217c228ff2afc3b09e3423f0fd82fc0647c2","modified":1587650960899},{"_id":"public/2019/11/03/青春向左/index.html","hash":"327c7b05654da09730a980b100471c563999eb2f","modified":1587695870511},{"_id":"public/2019/10/11/ES6总结一(变量与函数)/index.html","hash":"2050b39ee0935c463df62b697ead2e2d392e1f61","modified":1587650960899},{"_id":"public/2019/10/06/HelloShips/index.html","hash":"949392eba2e4264fff8c684105fc5021b182d5b7","modified":1587650960899},{"_id":"public/index.html","hash":"73f4da2c80b3e36873cdf7c59f4a0438829a8324","modified":1588037641028},{"_id":"public/CNAME","hash":"97212926fb93f1f559a12cbc14bc0399300c7f9a","modified":1587650960899},{"_id":"public/README","hash":"55aeb39cf7887750e9fa9bf59283642a0445cb9c","modified":1587650960899},{"_id":"public/favicon.ico","hash":"473ba682e828a7e34f24fae320e77b6bed4260c7","modified":1587650960899},{"_id":"public/images/ayer-side.svg","hash":"ad004ce7a873de0f91774f3d5923e010396a07bd","modified":1587650960899},{"_id":"public/images/ayer.png","hash":"0466c05244273f645d239cd27513bfa3c50308aa","modified":1587650960899},{"_id":"public/images/ayer.svg","hash":"379c3307f97c364718a1dbc1e52fb14de12eb11a","modified":1587650960899},{"_id":"public/images/cover7.jpg","hash":"573bff6899d2d9c5bcba0dc9c60cd1ec9eb8b029","modified":1587650960899},{"_id":"public/images/forkme.png","hash":"99c3e21a169421e4f249befb428396c729863a75","modified":1587650960899},{"_id":"public/images/sponsor.jpg","hash":"b3efa167f50cad85404c83f21dec2be570ed21dc","modified":1587650960899},{"_id":"public/images/404.jpg","hash":"4f36a8d378712427cded03f5166949f5e0ba754c","modified":1587650960899},{"_id":"public/2019/10/11/ES6总结一(变量与函数)/const声明.png","hash":"b83bce1c45d260f0f73177448bb2f8ecae367f86","modified":1587650960899},{"_id":"public/2019/10/11/ES6总结一(变量与函数)/全局块级绑定1.png","hash":"37cc0f29aee0221e226dcf282d9a9ee7f5c57a37","modified":1587650960899},{"_id":"public/2019/10/11/ES6总结一(变量与函数)/全局块级绑定2.png","hash":"4d10bffea957ee15057a1e59cad0fec1acc5d3fc","modified":1587650960899},{"_id":"public/2020/04/09/日系风格调色思路/小森林·夏秋.jpg","hash":"b1d4b612866f0bd35b18717788a665cb37c712d6","modified":1587650960899},{"_id":"public/2020/01/05/ES6语法总结三(解构、Set和Map)/数组解构赋值.png","hash":"2fe333c266dc125cd38573e4b1714487ce93e918","modified":1587650960899},{"_id":"public/2020/01/20/ES6语法总结四(迭代生成器、Promise和异步)/Promise生命周期.png","hash":"08aab9bc9e9350cd2e38cc0facddb10e1c1dc6dc","modified":1587650960899},{"_id":"public/images/alipay.jpg","hash":"8f5409e29764fca573f1d274003910aa3c919de1","modified":1587650960899},{"_id":"public/images/cover2.jpg","hash":"f61dd08c95327468c5f6bc5175eff68d00f05b46","modified":1587650960899},{"_id":"public/images/wechat.jpg","hash":"93a362574a8498e75dca469b7bceb0b321fda387","modified":1587650960899},{"_id":"public/2019/11/03/青春向左/自传.jpg","hash":"798bee1e2420e7dacdd3838a936201832a3c6e57","modified":1587650960899},{"_id":"public/2020/04/09/日系风格调色思路/小森林·冬春.jpg","hash":"81fed6e091b59d40388c761ee46c1869f729cecd","modified":1587650960899},{"_id":"public/2020/04/09/日系风格调色思路/海街日记2.jpg","hash":"fc6c69f6620cb63cb9f3ad340ccedc8adb138d19","modified":1587650960899},{"_id":"public/2020/04/09/日系风格调色思路/海街日记1.jpg","hash":"f33ffe8fc800f357b44e4df43f3c88cfce3b7da5","modified":1587650960899},{"_id":"public/2020/04/09/日系风格调色思路/海街日记3.jpg","hash":"5d72e291b6e866f947104d7b09c308db14bf3a9e","modified":1587650960899},{"_id":"public/css/clipboard.css","hash":"7990b92ffeda1b06b94b50140d9c95dac21bd418","modified":1587650960899},{"_id":"public/css/custom.css","hash":"78b13bf5b98278ff65cdb0a731f2a1c98b2324a5","modified":1587650960899},{"_id":"public/dist/main.js","hash":"2c886c8382df92c7af2bd7e446f3e3aa499c829e","modified":1587650960899},{"_id":"public/js/busuanzi-2.3.pure.min.js","hash":"6e41f31100ae7eb3a6f23f2c168f6dd56e7f7a9a","modified":1587650960899},{"_id":"public/js/clickLove.js","hash":"9e8e79d69ad8338761272f86fe5cad0ad5e503cc","modified":1587650960899},{"_id":"public/js/lazyload.min.js","hash":"b801b3946fb9b72e03512c0663458e140e1fa77b","modified":1587650960899},{"_id":"public/js/search.js","hash":"118be0e0918532ac1225f62e1a0a6f0673e0b173","modified":1587650960899},{"_id":"public/404.html","hash":"f12f5ef64d06569220ff54e41c453332ee785e44","modified":1587650960899},{"_id":"public/2020/04/09/日系风格调色思路/日系2.jpg","hash":"0bb583f8b401f33f3e86843e14f0d1ed39f95085","modified":1587650960899},{"_id":"public/2020/04/09/日系风格调色思路/日系3.jpg","hash":"6a2a70b02d0a7e37084ec12a1b38ad92c1842f11","modified":1587650960899},{"_id":"public/2019/11/03/青春向左/七号公园.jpg","hash":"05b5b3d4e45a4db65d6e184cdb683ea07ade2fbc","modified":1587650960899},{"_id":"public/js/tocbot.min.js","hash":"bae97e8a24a05a99335f8e725641c8ca9c50502a","modified":1587650960899},{"_id":"public/images/cover6.jpg","hash":"a5b8a5dddff2607fee5fccf5fdef3b214a8468cc","modified":1587650960899},{"_id":"public/2019/11/03/青春向左/人生海海.jpg","hash":"1d2c2173f11794b218754e73808a9471740e4e08","modified":1587650960899},{"_id":"public/2020/04/09/日系风格调色思路/原图1.jpg","hash":"e85119f4178defc684a8f0a8275f7d22ff2b13db","modified":1587650960899},{"_id":"public/images/cover1.jpg","hash":"e019fbed6158ae3e4ec3d255b41bddc1afcbfa90","modified":1587650960899},{"_id":"public/2020/04/09/日系风格调色思路/日系1.jpg","hash":"fcd7e3f90f6b7116a9b6678dbb12de1fbf0d590f","modified":1587650960899},{"_id":"public/2020/04/09/日系风格调色思路/photograph.jpg","hash":"105bd08770894fa454c0fe2e7c6430a32cec6dff","modified":1587650960899},{"_id":"public/images/cover3.jpg","hash":"7b4e7c9ce19ce5d5c1588b2567e88ecbb04370af","modified":1587650960899},{"_id":"public/dist/main.css","hash":"04f8a68c358c6b1f027d7cb88a12a882018f5cca","modified":1587650960899},{"_id":"public/images/cover4.jpg","hash":"77040e609d2f1c60e00a8e47cb95b25bf7ff5b9c","modified":1587650960899},{"_id":"public/js/jquery-2.0.3.min.js","hash":"800edb7787c30f4982bf38f2cb8f4f6fb61340e9","modified":1587650960899},{"_id":"public/images/cover5.jpg","hash":"1a2d6182d94b015a45fe4bf8e8a239dfcc0ef776","modified":1587650960899},{"_id":"public/2019/11/03/青春向左/演唱会.jpg","hash":"0f9f0b56af0436c9e6d7786273fb6cc3c35ca4a3","modified":1587650960899},{"_id":"source/_posts/青春向左/logo.png","hash":"7654ae549e3e507d60d66e7f706402da379893f2","modified":1587651492149},{"_id":"source/_posts/青春向左/自传.png","hash":"dd3f1bfee108c62c794e8d6627dec76c8e1526a4","modified":1587651609877},{"_id":"public/2019/11/03/青春向左/logo.png","hash":"7654ae549e3e507d60d66e7f706402da379893f2","modified":1587651659315},{"_id":"public/2019/11/03/青春向左/自传.png","hash":"dd3f1bfee108c62c794e8d6627dec76c8e1526a4","modified":1587651659315},{"_id":"source/_posts/VueX.md","hash":"b310a237abb8955857f2485a09dccaaef8354fe9","modified":1588037630546},{"_id":"source/_posts/VueX/flow.png","hash":"73bb62ebc338fcd64ee95bde18684ffe3b3bb379","modified":1588037432126},{"_id":"source/_posts/VueX/vuex.png","hash":"4fb73c3495849d5ac2ac80546a8431d563a7da45","modified":1588037433645},{"_id":"source/_posts/ES6/image/数组解构赋值.png","hash":"2fe333c266dc125cd38573e4b1714487ce93e918","modified":1584448702612},{"_id":"source/_posts/ES6/image/Promise生命周期.png","hash":"08aab9bc9e9350cd2e38cc0facddb10e1c1dc6dc","modified":1585033764014},{"_id":"source/_posts/ES6/image/const声明.png","hash":"b83bce1c45d260f0f73177448bb2f8ecae367f86","modified":1583745929324},{"_id":"source/_posts/ES6/image/全局块级绑定1.png","hash":"37cc0f29aee0221e226dcf282d9a9ee7f5c57a37","modified":1583742326445},{"_id":"source/_posts/ES6/image/全局块级绑定2.png","hash":"4d10bffea957ee15057a1e59cad0fec1acc5d3fc","modified":1583744787452},{"_id":"public/categories/Webj��/index.html","hash":"c162ebf7da7f9b64f270e7ead44954fc25036d68","modified":1588037641028},{"_id":"public/tags/Vue/index.html","hash":"5d2a66cc9d087d685c0c812ae83b6538b8de6c50","modified":1588037641028},{"_id":"public/tags/VueX/index.html","hash":"a9c75305dc8ff13ed2744b5cad23f26509836227","modified":1588037641028},{"_id":"public/2020/01/21/VueX/index.html","hash":"a11d52df92747f9d75d233c17eee7dfd30b80cd7","modified":1588037641028},{"_id":"public/2020/01/21/VueX/vuex.png","hash":"4fb73c3495849d5ac2ac80546a8431d563a7da45","modified":1588037641028},{"_id":"public/2020/01/21/VueX/flow.png","hash":"73bb62ebc338fcd64ee95bde18684ffe3b3bb379","modified":1588037641028}],"Category":[{"name":"web前端","_id":"ck9cue22a00043gcsaej4hkqq"},{"name":"摄影","_id":"ck9cue22j000b3gcsfa7r4jw0"},{"name":"随笔","_id":"ck9cue22k000h3gcsh7980s6k"},{"name":"Webǰ��","_id":"ck9j8lyev0001n0cs5eum2tos"}],"Data":[],"Page":[{"title":"categories","type":"categories","layout":"categories","_content":"\n","source":"categories/index.md","raw":"---\ntitle: categories\ntype: \"categories\"\nlayout: \"categories\"\n---\n\n","date":"2020-04-20T08:57:32.331Z","updated":"2020-04-16T11:26:59.158Z","path":"categories/index.html","comments":1,"_id":"ck9cue22700013gcsa6rx7d15","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"tags","type":"tags","layout":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ntype: \"tags\"\nlayout: \"tags\"\n---\n","date":"2020-04-20T08:57:32.332Z","updated":"2020-04-16T11:27:22.086Z","path":"tags/index.html","comments":1,"_id":"ck9cue22900033gcsad9731ow","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"ES6语法总结(二)","date":"2019-11-21T10:54:12.000Z","_content":"\n\n\n# ES6语法总结\n\n## 对象(Object)\n\n- **属性初始化器速记**：在ES6中当对象字面量中的属性只有名称时， JS 引擎会在周边作用域查找同名变量。若找到，该变量的值将会被赋给对象字面量的同名属性。所以当属性和值相同时可以只写一个名称例：\n\n  ```javascript\n  function createPerson(name, age) {\n      return {\n          name,\n          age\n      };\n  }\n  \n  ```\n<!--more-->\n- **方法简写**:在ES6为字面量定义函数时必须指定一个名称并用完整的函数定义来为对象添加方法，在ES6中也将其做了优化\n\n  ```javascript\n  var person = {\n  name: \"zhoushaung\",\n  sayName: function(){//es5 \n  console.log(this.name);\n  }\n  };\n  sayName(){//es6 \n  console.log(this.name);\n  }\n  \n  ```\n\n- **可计算的属性名**:对象实例能使用“需计算的属性名”，只要用方括号表示法来代替小数点表示法即可,在ES6中的计算属性名是对象字面量语法的一部分所以可以直接用变量或字符串字作为属性名，同时在[]也可以使用表达式\n\n  ```javascript\n  var suffix = \" man\";\n  var person = {\n  [suffix+\"name\"]: \"zhoushuang\",\n  [suffix+\"gender\"]: \"male\"\n  };\n  console.log(person[\"man name\"]); // \"zhoushuang\"\n  console.log(person[\"mane gender\"]); //male\n  ```\n\n  \n\n- **新增方法(Object.is(),Object.assign())**：\n\n  - Object.is:用来弥补相等运算符的不足(`==`和`===`)，在一般相等运算符无法判定值相同类型不同的情况，在严格相等运算符中无法判定为 +0 与 -0 相等， NaN === NaN 等情况，而Object.is会判定两个数据的类型和值是否相等例\n\n    ```javascript\n    console.log(+0 == -0); // true\n    console.log(+0 === -0); // true\n    console.log(Object.is(+0, -0)); // false\n    console.log(NaN == NaN); // false\n    console.log(NaN === NaN); // false\n    console.log(Object.is(NaN, NaN)); // true\n    console.log(1 == 1); // true\n    console.log(1 == \"1\"); // true\n    console.log(1 === 1); // true\n    console.log(1 === \"1\"); // false\n    console.log(Object.is(5, 5)); // true\n    console.log(Object.is(5, \"5\")); // false\n    \n    ```\n\n    \n\n  - Object.assign:用来对两个对象进行混入操作，该方法接受任意数量的参数并且会按照参数列表中的顺序来依次接收它们的属性，也就是说当有同名属性时可能会出现后来的参数覆盖前面的情况\n\n    ```javascript\n    var obj1 = {};\n    Object.assign(obj1,\n    {\n    type: \"shuaib\",\n    name: \"zhoushuang\"\n    },\n    {\n    type: \"handsome\"\n    }\n    );\n    console.log(obj1.type); // \"handsome\"\n    console.log(obj1.name); // \"zhoushuang\"\n    \n    ```\n\n- **重复的对象字面量属性**:当同一对象存在重复属性时，排在后面的属性的值会成为该属性的实际值而不会报错\n\n- **可枚举属性的顺序(Object.getOwnPropertyNames())**：该方法会根据以下规则返回对象的属性：\n\n  1. 所有的数字类型键，按升序排列。\n  2. 所有的字符串类型键，按被添加到对象的顺序排列。\n  3. 所有的符号类型（详见第六章）键，也按添加顺序排列。\n\n```javascript\nvar obj = {a: 1,0: 1,c: 1,2: 1,b: 1,1: 1};\nobj.d = 1;\nconsole.log(Object.getOwnPropertyNames(obj).join(\"\")); // \"012acbd\"\n```\n\n- **原型**：\n\n  - 新增和修改原型：Object.setPrototypeOf()允许你修改任意指定对象的原型。它接受两个参数：需要被修改原型的对象，以及将会成为前者原型的对象, Object.getPrototypeOf() 方法从任意指定对象中获取其原型.\n\n  - super调用原型的函数:\n\n    ```javascript\n    let person = {\n    getGreeting() {\n    return \"Hello\";\n    }\n    };\n    let dog = {\n    getGreeting() {\n    return \"Woof\";\n    }\n    };\n    let friend = {\n    getGreeting() {\n    return super.getGreeting() + \", hi!\";\n    }\n    };\n    // 将原型设置为 person\n    Object.setPrototypeOf(friend, person);\n    console.log(friend.getGreeting()); // \"Hello, hi!\"\n    console.log(Object.getPrototypeOf(friend) === person); // true\n    // 将原型设置为 dog\n    Object.setPrototypeOf(friend, dog);\n    console.log(friend.getGreeting()); // \"Woof, hi!\"\n    console.log(Object.getPrototypeOf(friend) === dog); // true\n    ```\n\n    有点类似于java对父类方法的重写,在有多重继承的情况下会比较好使一点\n\n## 数组\n\n- **创建数组方法**：\n\n  - Array.of():) 方法总会创建一个包含所有传入参数的数组，而不管参数的数量与类型\n\n    ```javascript\n    let items = Array.of(1, 2);\n    console.log(items.length); // 2\n    console.log(items[0]); // 1\n    console.log(items[1]); // 2\n    items = Array.of(2);\n    console.log(items.length); // 1\n    console.log(items[0]); // 2\n    items = Array.of(\"2\");\n    console.log(items.length); // 1\n    console.log(items[0]); \n    ```\n\n    \n\n  - Array.from():多用于类数组对象转化成为数组或者转化前进行额外操作时使用，接收三个参数\n\n    1. 参数对象(arguments)：传入要进行转化的初始对象\n    2. 操作方法(function)：如需额外加工，传入加工具体步骤\n    3. 映射(object):如果function已经被定义或者需要进入额外对象方法，在此传入方法所在对象，此时的this就会指向被传入的对象\n\n  ```javascript\n  let helper = {\n  diff: 1,\n  add(value) {\n  return value + this.diff;\n  }\n  };\n  function translate() {\n  return Array.from(arguments, helper.add, helper);\n  }\n  let numbers = translate(1, 2, 3);\n  console.log(numbers); // 2,3,4\n  ```\n\n- **其他方法**:\n\n  - **find()和findIndex()**:这两俩函数非常像所以把他们放在一起讨论，\n\n    - 相同点：\n      1. 都是在数组中查找符合要求的值\n      2. 均接受两个参数：一个回调函数和一个可选值用于指定回调函数内部的 this 。该回调函数可接收三个参数：数组的某个元素、该元素对应的索引位置、以及该数组自身\n      3. 均会在回调函数第一次返回 true 时停止查找\n    - 区别\n      1. find() 方法返回匹配的值\n      2. findIndex() 方法则会返回匹配位置的索引\n\n    ```javascript\n    let numbers = [25, 30, 35, 40, 45];\n    console.log(numbers.find(n => n > 33)); // 35\n    console.log(numbers.findIndex(n => n > 33)); \n    ```\n\n  - **fill() **:\n\n    - 作用:用于填充数组中的一个或者多个参数\n    - 语法:fill(number,firstIndex,lastIndex)：\n      1. number：进行替换操作的数据，\n      2. firstIndex，lastIndex:进行替换操作的初始位置和结束位置\n    - 注:后两个参数是该数组的下标,当其为负是值为Array.length+firstIndex/lastIndex\n\n  - **copyWithin()**:\n\n    - 作用：和fill一样用于填充替换数组,但这个方法可以在数组内部复制自身元素\n    - 语法:copyWithin(target,start,end):\n      1. start:粘贴的起始位置\n      2. target:从第几个位置作为粘贴项\n      3. end:被覆盖元素的个数\n\n```javascript\nlet numbers = [1, 2, 3, 4];\n// 从索引 2 的位置开始粘贴\n// 从数组索引 0 的位置开始复制数据\n// 在遇到索引 1 时停止复制\nnumbers.copyWithin(2, 0, 1);\nconsole.log(numbers.toString()); // 1,2,1,4\n```\n\n","source":"_posts/ES6总结二(对象和数组).md","raw":"---\ntitle: ES6语法总结(二)\ndate: 2019-11-21 18:54:12\ntags:\n\t- 前端\n\t- ES6\ncategories:\n\t- web前端\n\t\n---\n\n\n\n# ES6语法总结\n\n## 对象(Object)\n\n- **属性初始化器速记**：在ES6中当对象字面量中的属性只有名称时， JS 引擎会在周边作用域查找同名变量。若找到，该变量的值将会被赋给对象字面量的同名属性。所以当属性和值相同时可以只写一个名称例：\n\n  ```javascript\n  function createPerson(name, age) {\n      return {\n          name,\n          age\n      };\n  }\n  \n  ```\n<!--more-->\n- **方法简写**:在ES6为字面量定义函数时必须指定一个名称并用完整的函数定义来为对象添加方法，在ES6中也将其做了优化\n\n  ```javascript\n  var person = {\n  name: \"zhoushaung\",\n  sayName: function(){//es5 \n  console.log(this.name);\n  }\n  };\n  sayName(){//es6 \n  console.log(this.name);\n  }\n  \n  ```\n\n- **可计算的属性名**:对象实例能使用“需计算的属性名”，只要用方括号表示法来代替小数点表示法即可,在ES6中的计算属性名是对象字面量语法的一部分所以可以直接用变量或字符串字作为属性名，同时在[]也可以使用表达式\n\n  ```javascript\n  var suffix = \" man\";\n  var person = {\n  [suffix+\"name\"]: \"zhoushuang\",\n  [suffix+\"gender\"]: \"male\"\n  };\n  console.log(person[\"man name\"]); // \"zhoushuang\"\n  console.log(person[\"mane gender\"]); //male\n  ```\n\n  \n\n- **新增方法(Object.is(),Object.assign())**：\n\n  - Object.is:用来弥补相等运算符的不足(`==`和`===`)，在一般相等运算符无法判定值相同类型不同的情况，在严格相等运算符中无法判定为 +0 与 -0 相等， NaN === NaN 等情况，而Object.is会判定两个数据的类型和值是否相等例\n\n    ```javascript\n    console.log(+0 == -0); // true\n    console.log(+0 === -0); // true\n    console.log(Object.is(+0, -0)); // false\n    console.log(NaN == NaN); // false\n    console.log(NaN === NaN); // false\n    console.log(Object.is(NaN, NaN)); // true\n    console.log(1 == 1); // true\n    console.log(1 == \"1\"); // true\n    console.log(1 === 1); // true\n    console.log(1 === \"1\"); // false\n    console.log(Object.is(5, 5)); // true\n    console.log(Object.is(5, \"5\")); // false\n    \n    ```\n\n    \n\n  - Object.assign:用来对两个对象进行混入操作，该方法接受任意数量的参数并且会按照参数列表中的顺序来依次接收它们的属性，也就是说当有同名属性时可能会出现后来的参数覆盖前面的情况\n\n    ```javascript\n    var obj1 = {};\n    Object.assign(obj1,\n    {\n    type: \"shuaib\",\n    name: \"zhoushuang\"\n    },\n    {\n    type: \"handsome\"\n    }\n    );\n    console.log(obj1.type); // \"handsome\"\n    console.log(obj1.name); // \"zhoushuang\"\n    \n    ```\n\n- **重复的对象字面量属性**:当同一对象存在重复属性时，排在后面的属性的值会成为该属性的实际值而不会报错\n\n- **可枚举属性的顺序(Object.getOwnPropertyNames())**：该方法会根据以下规则返回对象的属性：\n\n  1. 所有的数字类型键，按升序排列。\n  2. 所有的字符串类型键，按被添加到对象的顺序排列。\n  3. 所有的符号类型（详见第六章）键，也按添加顺序排列。\n\n```javascript\nvar obj = {a: 1,0: 1,c: 1,2: 1,b: 1,1: 1};\nobj.d = 1;\nconsole.log(Object.getOwnPropertyNames(obj).join(\"\")); // \"012acbd\"\n```\n\n- **原型**：\n\n  - 新增和修改原型：Object.setPrototypeOf()允许你修改任意指定对象的原型。它接受两个参数：需要被修改原型的对象，以及将会成为前者原型的对象, Object.getPrototypeOf() 方法从任意指定对象中获取其原型.\n\n  - super调用原型的函数:\n\n    ```javascript\n    let person = {\n    getGreeting() {\n    return \"Hello\";\n    }\n    };\n    let dog = {\n    getGreeting() {\n    return \"Woof\";\n    }\n    };\n    let friend = {\n    getGreeting() {\n    return super.getGreeting() + \", hi!\";\n    }\n    };\n    // 将原型设置为 person\n    Object.setPrototypeOf(friend, person);\n    console.log(friend.getGreeting()); // \"Hello, hi!\"\n    console.log(Object.getPrototypeOf(friend) === person); // true\n    // 将原型设置为 dog\n    Object.setPrototypeOf(friend, dog);\n    console.log(friend.getGreeting()); // \"Woof, hi!\"\n    console.log(Object.getPrototypeOf(friend) === dog); // true\n    ```\n\n    有点类似于java对父类方法的重写,在有多重继承的情况下会比较好使一点\n\n## 数组\n\n- **创建数组方法**：\n\n  - Array.of():) 方法总会创建一个包含所有传入参数的数组，而不管参数的数量与类型\n\n    ```javascript\n    let items = Array.of(1, 2);\n    console.log(items.length); // 2\n    console.log(items[0]); // 1\n    console.log(items[1]); // 2\n    items = Array.of(2);\n    console.log(items.length); // 1\n    console.log(items[0]); // 2\n    items = Array.of(\"2\");\n    console.log(items.length); // 1\n    console.log(items[0]); \n    ```\n\n    \n\n  - Array.from():多用于类数组对象转化成为数组或者转化前进行额外操作时使用，接收三个参数\n\n    1. 参数对象(arguments)：传入要进行转化的初始对象\n    2. 操作方法(function)：如需额外加工，传入加工具体步骤\n    3. 映射(object):如果function已经被定义或者需要进入额外对象方法，在此传入方法所在对象，此时的this就会指向被传入的对象\n\n  ```javascript\n  let helper = {\n  diff: 1,\n  add(value) {\n  return value + this.diff;\n  }\n  };\n  function translate() {\n  return Array.from(arguments, helper.add, helper);\n  }\n  let numbers = translate(1, 2, 3);\n  console.log(numbers); // 2,3,4\n  ```\n\n- **其他方法**:\n\n  - **find()和findIndex()**:这两俩函数非常像所以把他们放在一起讨论，\n\n    - 相同点：\n      1. 都是在数组中查找符合要求的值\n      2. 均接受两个参数：一个回调函数和一个可选值用于指定回调函数内部的 this 。该回调函数可接收三个参数：数组的某个元素、该元素对应的索引位置、以及该数组自身\n      3. 均会在回调函数第一次返回 true 时停止查找\n    - 区别\n      1. find() 方法返回匹配的值\n      2. findIndex() 方法则会返回匹配位置的索引\n\n    ```javascript\n    let numbers = [25, 30, 35, 40, 45];\n    console.log(numbers.find(n => n > 33)); // 35\n    console.log(numbers.findIndex(n => n > 33)); \n    ```\n\n  - **fill() **:\n\n    - 作用:用于填充数组中的一个或者多个参数\n    - 语法:fill(number,firstIndex,lastIndex)：\n      1. number：进行替换操作的数据，\n      2. firstIndex，lastIndex:进行替换操作的初始位置和结束位置\n    - 注:后两个参数是该数组的下标,当其为负是值为Array.length+firstIndex/lastIndex\n\n  - **copyWithin()**:\n\n    - 作用：和fill一样用于填充替换数组,但这个方法可以在数组内部复制自身元素\n    - 语法:copyWithin(target,start,end):\n      1. start:粘贴的起始位置\n      2. target:从第几个位置作为粘贴项\n      3. end:被覆盖元素的个数\n\n```javascript\nlet numbers = [1, 2, 3, 4];\n// 从索引 2 的位置开始粘贴\n// 从数组索引 0 的位置开始复制数据\n// 在遇到索引 1 时停止复制\nnumbers.copyWithin(2, 0, 1);\nconsole.log(numbers.toString()); // 1,2,1,4\n```\n\n","slug":"ES6总结二(对象和数组)","published":1,"updated":"2020-04-16T11:42:36.627Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9cue22100003gcs93qy5nm4","content":"<h1 id=\"ES6语法总结\"><a href=\"#ES6语法总结\" class=\"headerlink\" title=\"ES6语法总结\"></a>ES6语法总结</h1><h2 id=\"对象-Object\"><a href=\"#对象-Object\" class=\"headerlink\" title=\"对象(Object)\"></a>对象(Object)</h2><ul>\n<li><p><strong>属性初始化器速记</strong>：在ES6中当对象字面量中的属性只有名称时， JS 引擎会在周边作用域查找同名变量。若找到，该变量的值将会被赋给对象字面量的同名属性。所以当属性和值相同时可以只写一个名称例：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createPerson</span>(<span class=\"params\">name, age</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">        name,</span><br><span class=\"line\">        age</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<a id=\"more\"></a></li>\n<li><p><strong>方法简写</strong>:在ES6为字面量定义函数时必须指定一个名称并用完整的函数定义来为对象添加方法，在ES6中也将其做了优化</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> person = &#123;</span><br><span class=\"line\">name: <span class=\"string\">\"zhoushaung\"</span>,</span><br><span class=\"line\">sayName: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;<span class=\"comment\">//es5 </span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">sayName()&#123;<span class=\"comment\">//es6 </span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>可计算的属性名</strong>:对象实例能使用“需计算的属性名”，只要用方括号表示法来代替小数点表示法即可,在ES6中的计算属性名是对象字面量语法的一部分所以可以直接用变量或字符串字作为属性名，同时在[]也可以使用表达式</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> suffix = <span class=\"string\">\" man\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> person = &#123;</span><br><span class=\"line\">[suffix+<span class=\"string\">\"name\"</span>]: <span class=\"string\">\"zhoushuang\"</span>,</span><br><span class=\"line\">[suffix+<span class=\"string\">\"gender\"</span>]: <span class=\"string\">\"male\"</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(person[<span class=\"string\">\"man name\"</span>]); <span class=\"comment\">// \"zhoushuang\"</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(person[<span class=\"string\">\"mane gender\"</span>]); <span class=\"comment\">//male</span></span><br></pre></td></tr></table></figure>\n\n\n\n</li>\n</ul>\n<ul>\n<li><p><strong>新增方法(Object.is(),Object.assign())</strong>：</p>\n<ul>\n<li><p>Object.is:用来弥补相等运算符的不足(<code>==</code>和<code>===</code>)，在一般相等运算符无法判定值相同类型不同的情况，在严格相等运算符中无法判定为 +0 与 -0 相等， NaN === NaN 等情况，而Object.is会判定两个数据的类型和值是否相等例</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(+<span class=\"number\">0</span> == <span class=\"number\">-0</span>); <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(+<span class=\"number\">0</span> === <span class=\"number\">-0</span>); <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Object</span>.is(+<span class=\"number\">0</span>, <span class=\"number\">-0</span>)); <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"literal\">NaN</span> == <span class=\"literal\">NaN</span>); <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"literal\">NaN</span> === <span class=\"literal\">NaN</span>); <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Object</span>.is(<span class=\"literal\">NaN</span>, <span class=\"literal\">NaN</span>)); <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"number\">1</span> == <span class=\"number\">1</span>); <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"number\">1</span> == <span class=\"string\">\"1\"</span>); <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"number\">1</span> === <span class=\"number\">1</span>); <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"number\">1</span> === <span class=\"string\">\"1\"</span>); <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Object</span>.is(<span class=\"number\">5</span>, <span class=\"number\">5</span>)); <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Object</span>.is(<span class=\"number\">5</span>, <span class=\"string\">\"5\"</span>)); <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n\n\n\n</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><p>Object.assign:用来对两个对象进行混入操作，该方法接受任意数量的参数并且会按照参数列表中的顺序来依次接收它们的属性，也就是说当有同名属性时可能会出现后来的参数覆盖前面的情况</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj1 = &#123;&#125;;</span><br><span class=\"line\"><span class=\"built_in\">Object</span>.assign(obj1,</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">type: <span class=\"string\">\"shuaib\"</span>,</span><br><span class=\"line\">name: <span class=\"string\">\"zhoushuang\"</span></span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">type: <span class=\"string\">\"handsome\"</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj1.type); <span class=\"comment\">// \"handsome\"</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj1.name); <span class=\"comment\">// \"zhoushuang\"</span></span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<ul>\n<li><p><strong>重复的对象字面量属性</strong>:当同一对象存在重复属性时，排在后面的属性的值会成为该属性的实际值而不会报错</p>\n</li>\n<li><p><strong>可枚举属性的顺序(Object.getOwnPropertyNames())</strong>：该方法会根据以下规则返回对象的属性：</p>\n<ol>\n<li>所有的数字类型键，按升序排列。</li>\n<li>所有的字符串类型键，按被添加到对象的顺序排列。</li>\n<li>所有的符号类型（详见第六章）键，也按添加顺序排列。</li>\n</ol>\n</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;<span class=\"attr\">a</span>: <span class=\"number\">1</span>,<span class=\"number\">0</span>: <span class=\"number\">1</span>,<span class=\"attr\">c</span>: <span class=\"number\">1</span>,<span class=\"number\">2</span>: <span class=\"number\">1</span>,<span class=\"attr\">b</span>: <span class=\"number\">1</span>,<span class=\"number\">1</span>: <span class=\"number\">1</span>&#125;;</span><br><span class=\"line\">obj.d = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Object</span>.getOwnPropertyNames(obj).join(<span class=\"string\">\"\"</span>)); <span class=\"comment\">// \"012acbd\"</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p><strong>原型</strong>：</p>\n<ul>\n<li><p>新增和修改原型：Object.setPrototypeOf()允许你修改任意指定对象的原型。它接受两个参数：需要被修改原型的对象，以及将会成为前者原型的对象, Object.getPrototypeOf() 方法从任意指定对象中获取其原型.</p>\n</li>\n<li><p>super调用原型的函数:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> person = &#123;</span><br><span class=\"line\">getGreeting() &#123;</span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"string\">\"Hello\"</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">let</span> dog = &#123;</span><br><span class=\"line\">getGreeting() &#123;</span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"string\">\"Woof\"</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">let</span> friend = &#123;</span><br><span class=\"line\">getGreeting() &#123;</span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"keyword\">super</span>.getGreeting() + <span class=\"string\">\", hi!\"</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">// 将原型设置为 person</span></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.setPrototypeOf(friend, person);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(friend.getGreeting()); <span class=\"comment\">// \"Hello, hi!\"</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Object</span>.getPrototypeOf(friend) === person); <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"comment\">// 将原型设置为 dog</span></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.setPrototypeOf(friend, dog);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(friend.getGreeting()); <span class=\"comment\">// \"Woof, hi!\"</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Object</span>.getPrototypeOf(friend) === dog); <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<p>有点类似于java对父类方法的重写,在有多重继承的情况下会比较好使一点</p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h2><ul>\n<li><p><strong>创建数组方法</strong>：</p>\n<ul>\n<li><p>Array.of():) 方法总会创建一个包含所有传入参数的数组，而不管参数的数量与类型</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> items = <span class=\"built_in\">Array</span>.of(<span class=\"number\">1</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(items.length); <span class=\"comment\">// 2</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(items[<span class=\"number\">0</span>]); <span class=\"comment\">// 1</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(items[<span class=\"number\">1</span>]); <span class=\"comment\">// 2</span></span><br><span class=\"line\">items = <span class=\"built_in\">Array</span>.of(<span class=\"number\">2</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(items.length); <span class=\"comment\">// 1</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(items[<span class=\"number\">0</span>]); <span class=\"comment\">// 2</span></span><br><span class=\"line\">items = <span class=\"built_in\">Array</span>.of(<span class=\"string\">\"2\"</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(items.length); <span class=\"comment\">// 1</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(items[<span class=\"number\">0</span>]);</span><br></pre></td></tr></table></figure>\n\n\n\n</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><p>Array.from():多用于类数组对象转化成为数组或者转化前进行额外操作时使用，接收三个参数</p>\n<ol>\n<li>参数对象(arguments)：传入要进行转化的初始对象</li>\n<li>操作方法(function)：如需额外加工，传入加工具体步骤</li>\n<li>映射(object):如果function已经被定义或者需要进入额外对象方法，在此传入方法所在对象，此时的this就会指向被传入的对象</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> helper = &#123;</span><br><span class=\"line\">diff: <span class=\"number\">1</span>,</span><br><span class=\"line\">add(value) &#123;</span><br><span class=\"line\"><span class=\"keyword\">return</span> value + <span class=\"keyword\">this</span>.diff;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">translate</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"built_in\">Array</span>.from(<span class=\"built_in\">arguments</span>, helper.add, helper);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> numbers = translate(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(numbers); <span class=\"comment\">// 2,3,4</span></span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<ul>\n<li><p><strong>其他方法</strong>:</p>\n<ul>\n<li><p><strong>find()和findIndex()</strong>:这两俩函数非常像所以把他们放在一起讨论，</p>\n<ul>\n<li>相同点：<ol>\n<li>都是在数组中查找符合要求的值</li>\n<li>均接受两个参数：一个回调函数和一个可选值用于指定回调函数内部的 this 。该回调函数可接收三个参数：数组的某个元素、该元素对应的索引位置、以及该数组自身</li>\n<li>均会在回调函数第一次返回 true 时停止查找</li>\n</ol>\n</li>\n<li>区别<ol>\n<li>find() 方法返回匹配的值</li>\n<li>findIndex() 方法则会返回匹配位置的索引</li>\n</ol>\n</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> numbers = [<span class=\"number\">25</span>, <span class=\"number\">30</span>, <span class=\"number\">35</span>, <span class=\"number\">40</span>, <span class=\"number\">45</span>];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(numbers.find(<span class=\"function\"><span class=\"params\">n</span> =&gt;</span> n &gt; <span class=\"number\">33</span>)); <span class=\"comment\">// 35</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(numbers.findIndex(<span class=\"function\"><span class=\"params\">n</span> =&gt;</span> n &gt; <span class=\"number\">33</span>));</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>*<em>fill() *</em>:</p>\n<ul>\n<li>作用:用于填充数组中的一个或者多个参数</li>\n<li>语法:fill(number,firstIndex,lastIndex)：<ol>\n<li>number：进行替换操作的数据，</li>\n<li>firstIndex，lastIndex:进行替换操作的初始位置和结束位置</li>\n</ol>\n</li>\n<li>注:后两个参数是该数组的下标,当其为负是值为Array.length+firstIndex/lastIndex</li>\n</ul>\n</li>\n<li><p><strong>copyWithin()</strong>:</p>\n<ul>\n<li>作用：和fill一样用于填充替换数组,但这个方法可以在数组内部复制自身元素</li>\n<li>语法:copyWithin(target,start,end):<ol>\n<li>start:粘贴的起始位置</li>\n<li>target:从第几个位置作为粘贴项</li>\n<li>end:被覆盖元素的个数</li>\n</ol>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> numbers = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>];</span><br><span class=\"line\"><span class=\"comment\">// 从索引 2 的位置开始粘贴</span></span><br><span class=\"line\"><span class=\"comment\">// 从数组索引 0 的位置开始复制数据</span></span><br><span class=\"line\"><span class=\"comment\">// 在遇到索引 1 时停止复制</span></span><br><span class=\"line\">numbers.copyWithin(<span class=\"number\">2</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(numbers.toString()); <span class=\"comment\">// 1,2,1,4</span></span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"<h1 id=\"ES6语法总结\"><a href=\"#ES6语法总结\" class=\"headerlink\" title=\"ES6语法总结\"></a>ES6语法总结</h1><h2 id=\"对象-Object\"><a href=\"#对象-Object\" class=\"headerlink\" title=\"对象(Object)\"></a>对象(Object)</h2><ul>\n<li><p><strong>属性初始化器速记</strong>：在ES6中当对象字面量中的属性只有名称时， JS 引擎会在周边作用域查找同名变量。若找到，该变量的值将会被赋给对象字面量的同名属性。所以当属性和值相同时可以只写一个名称例：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createPerson</span>(<span class=\"params\">name, age</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">        name,</span><br><span class=\"line\">        age</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li></ul>","more":"\n<li><p><strong>方法简写</strong>:在ES6为字面量定义函数时必须指定一个名称并用完整的函数定义来为对象添加方法，在ES6中也将其做了优化</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> person = &#123;</span><br><span class=\"line\">name: <span class=\"string\">\"zhoushaung\"</span>,</span><br><span class=\"line\">sayName: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;<span class=\"comment\">//es5 </span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">sayName()&#123;<span class=\"comment\">//es6 </span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>可计算的属性名</strong>:对象实例能使用“需计算的属性名”，只要用方括号表示法来代替小数点表示法即可,在ES6中的计算属性名是对象字面量语法的一部分所以可以直接用变量或字符串字作为属性名，同时在[]也可以使用表达式</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> suffix = <span class=\"string\">\" man\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> person = &#123;</span><br><span class=\"line\">[suffix+<span class=\"string\">\"name\"</span>]: <span class=\"string\">\"zhoushuang\"</span>,</span><br><span class=\"line\">[suffix+<span class=\"string\">\"gender\"</span>]: <span class=\"string\">\"male\"</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(person[<span class=\"string\">\"man name\"</span>]); <span class=\"comment\">// \"zhoushuang\"</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(person[<span class=\"string\">\"mane gender\"</span>]); <span class=\"comment\">//male</span></span><br></pre></td></tr></table></figure>\n\n\n\n</li>\n\n<ul>\n<li><p><strong>新增方法(Object.is(),Object.assign())</strong>：</p>\n<ul>\n<li><p>Object.is:用来弥补相等运算符的不足(<code>==</code>和<code>===</code>)，在一般相等运算符无法判定值相同类型不同的情况，在严格相等运算符中无法判定为 +0 与 -0 相等， NaN === NaN 等情况，而Object.is会判定两个数据的类型和值是否相等例</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(+<span class=\"number\">0</span> == <span class=\"number\">-0</span>); <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(+<span class=\"number\">0</span> === <span class=\"number\">-0</span>); <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Object</span>.is(+<span class=\"number\">0</span>, <span class=\"number\">-0</span>)); <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"literal\">NaN</span> == <span class=\"literal\">NaN</span>); <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"literal\">NaN</span> === <span class=\"literal\">NaN</span>); <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Object</span>.is(<span class=\"literal\">NaN</span>, <span class=\"literal\">NaN</span>)); <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"number\">1</span> == <span class=\"number\">1</span>); <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"number\">1</span> == <span class=\"string\">\"1\"</span>); <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"number\">1</span> === <span class=\"number\">1</span>); <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"number\">1</span> === <span class=\"string\">\"1\"</span>); <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Object</span>.is(<span class=\"number\">5</span>, <span class=\"number\">5</span>)); <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Object</span>.is(<span class=\"number\">5</span>, <span class=\"string\">\"5\"</span>)); <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n\n\n\n</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><p>Object.assign:用来对两个对象进行混入操作，该方法接受任意数量的参数并且会按照参数列表中的顺序来依次接收它们的属性，也就是说当有同名属性时可能会出现后来的参数覆盖前面的情况</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj1 = &#123;&#125;;</span><br><span class=\"line\"><span class=\"built_in\">Object</span>.assign(obj1,</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">type: <span class=\"string\">\"shuaib\"</span>,</span><br><span class=\"line\">name: <span class=\"string\">\"zhoushuang\"</span></span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">type: <span class=\"string\">\"handsome\"</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj1.type); <span class=\"comment\">// \"handsome\"</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj1.name); <span class=\"comment\">// \"zhoushuang\"</span></span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<ul>\n<li><p><strong>重复的对象字面量属性</strong>:当同一对象存在重复属性时，排在后面的属性的值会成为该属性的实际值而不会报错</p>\n</li>\n<li><p><strong>可枚举属性的顺序(Object.getOwnPropertyNames())</strong>：该方法会根据以下规则返回对象的属性：</p>\n<ol>\n<li>所有的数字类型键，按升序排列。</li>\n<li>所有的字符串类型键，按被添加到对象的顺序排列。</li>\n<li>所有的符号类型（详见第六章）键，也按添加顺序排列。</li>\n</ol>\n</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;<span class=\"attr\">a</span>: <span class=\"number\">1</span>,<span class=\"number\">0</span>: <span class=\"number\">1</span>,<span class=\"attr\">c</span>: <span class=\"number\">1</span>,<span class=\"number\">2</span>: <span class=\"number\">1</span>,<span class=\"attr\">b</span>: <span class=\"number\">1</span>,<span class=\"number\">1</span>: <span class=\"number\">1</span>&#125;;</span><br><span class=\"line\">obj.d = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Object</span>.getOwnPropertyNames(obj).join(<span class=\"string\">\"\"</span>)); <span class=\"comment\">// \"012acbd\"</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p><strong>原型</strong>：</p>\n<ul>\n<li><p>新增和修改原型：Object.setPrototypeOf()允许你修改任意指定对象的原型。它接受两个参数：需要被修改原型的对象，以及将会成为前者原型的对象, Object.getPrototypeOf() 方法从任意指定对象中获取其原型.</p>\n</li>\n<li><p>super调用原型的函数:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> person = &#123;</span><br><span class=\"line\">getGreeting() &#123;</span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"string\">\"Hello\"</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">let</span> dog = &#123;</span><br><span class=\"line\">getGreeting() &#123;</span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"string\">\"Woof\"</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">let</span> friend = &#123;</span><br><span class=\"line\">getGreeting() &#123;</span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"keyword\">super</span>.getGreeting() + <span class=\"string\">\", hi!\"</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">// 将原型设置为 person</span></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.setPrototypeOf(friend, person);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(friend.getGreeting()); <span class=\"comment\">// \"Hello, hi!\"</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Object</span>.getPrototypeOf(friend) === person); <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"comment\">// 将原型设置为 dog</span></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.setPrototypeOf(friend, dog);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(friend.getGreeting()); <span class=\"comment\">// \"Woof, hi!\"</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Object</span>.getPrototypeOf(friend) === dog); <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<p>有点类似于java对父类方法的重写,在有多重继承的情况下会比较好使一点</p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h2><ul>\n<li><p><strong>创建数组方法</strong>：</p>\n<ul>\n<li><p>Array.of():) 方法总会创建一个包含所有传入参数的数组，而不管参数的数量与类型</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> items = <span class=\"built_in\">Array</span>.of(<span class=\"number\">1</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(items.length); <span class=\"comment\">// 2</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(items[<span class=\"number\">0</span>]); <span class=\"comment\">// 1</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(items[<span class=\"number\">1</span>]); <span class=\"comment\">// 2</span></span><br><span class=\"line\">items = <span class=\"built_in\">Array</span>.of(<span class=\"number\">2</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(items.length); <span class=\"comment\">// 1</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(items[<span class=\"number\">0</span>]); <span class=\"comment\">// 2</span></span><br><span class=\"line\">items = <span class=\"built_in\">Array</span>.of(<span class=\"string\">\"2\"</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(items.length); <span class=\"comment\">// 1</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(items[<span class=\"number\">0</span>]);</span><br></pre></td></tr></table></figure>\n\n\n\n</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><p>Array.from():多用于类数组对象转化成为数组或者转化前进行额外操作时使用，接收三个参数</p>\n<ol>\n<li>参数对象(arguments)：传入要进行转化的初始对象</li>\n<li>操作方法(function)：如需额外加工，传入加工具体步骤</li>\n<li>映射(object):如果function已经被定义或者需要进入额外对象方法，在此传入方法所在对象，此时的this就会指向被传入的对象</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> helper = &#123;</span><br><span class=\"line\">diff: <span class=\"number\">1</span>,</span><br><span class=\"line\">add(value) &#123;</span><br><span class=\"line\"><span class=\"keyword\">return</span> value + <span class=\"keyword\">this</span>.diff;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">translate</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"built_in\">Array</span>.from(<span class=\"built_in\">arguments</span>, helper.add, helper);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> numbers = translate(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(numbers); <span class=\"comment\">// 2,3,4</span></span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<ul>\n<li><p><strong>其他方法</strong>:</p>\n<ul>\n<li><p><strong>find()和findIndex()</strong>:这两俩函数非常像所以把他们放在一起讨论，</p>\n<ul>\n<li>相同点：<ol>\n<li>都是在数组中查找符合要求的值</li>\n<li>均接受两个参数：一个回调函数和一个可选值用于指定回调函数内部的 this 。该回调函数可接收三个参数：数组的某个元素、该元素对应的索引位置、以及该数组自身</li>\n<li>均会在回调函数第一次返回 true 时停止查找</li>\n</ol>\n</li>\n<li>区别<ol>\n<li>find() 方法返回匹配的值</li>\n<li>findIndex() 方法则会返回匹配位置的索引</li>\n</ol>\n</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> numbers = [<span class=\"number\">25</span>, <span class=\"number\">30</span>, <span class=\"number\">35</span>, <span class=\"number\">40</span>, <span class=\"number\">45</span>];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(numbers.find(<span class=\"function\"><span class=\"params\">n</span> =&gt;</span> n &gt; <span class=\"number\">33</span>)); <span class=\"comment\">// 35</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(numbers.findIndex(<span class=\"function\"><span class=\"params\">n</span> =&gt;</span> n &gt; <span class=\"number\">33</span>));</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>*<em>fill() *</em>:</p>\n<ul>\n<li>作用:用于填充数组中的一个或者多个参数</li>\n<li>语法:fill(number,firstIndex,lastIndex)：<ol>\n<li>number：进行替换操作的数据，</li>\n<li>firstIndex，lastIndex:进行替换操作的初始位置和结束位置</li>\n</ol>\n</li>\n<li>注:后两个参数是该数组的下标,当其为负是值为Array.length+firstIndex/lastIndex</li>\n</ul>\n</li>\n<li><p><strong>copyWithin()</strong>:</p>\n<ul>\n<li>作用：和fill一样用于填充替换数组,但这个方法可以在数组内部复制自身元素</li>\n<li>语法:copyWithin(target,start,end):<ol>\n<li>start:粘贴的起始位置</li>\n<li>target:从第几个位置作为粘贴项</li>\n<li>end:被覆盖元素的个数</li>\n</ol>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> numbers = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>];</span><br><span class=\"line\"><span class=\"comment\">// 从索引 2 的位置开始粘贴</span></span><br><span class=\"line\"><span class=\"comment\">// 从数组索引 0 的位置开始复制数据</span></span><br><span class=\"line\"><span class=\"comment\">// 在遇到索引 1 时停止复制</span></span><br><span class=\"line\">numbers.copyWithin(<span class=\"number\">2</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(numbers.toString()); <span class=\"comment\">// 1,2,1,4</span></span><br></pre></td></tr></table></figure>"},{"title":"ES6语法总结(一)","date":"2019-10-11T09:22:55.000Z","_content":"\n\n\n# ES6语法总结\n\n## 块级绑定（*let ，var，const*）\n\n### 传统var的问题（*变量提升，块级作用域*）\n\nvar是用来声明各类型变量的关键字，但存在一个问题--**变量提升**（*在当前作用域内使用var关键词声明的变量都会提升到当前作用域的顶部*）例:\n\n```javascript\nfunction getValue(condition) {\nif (condition) {\nvar value = \"blue\";\n// 其他代码\nreturn value;\n} else {\n// value 在此处可访问，值为 undefined\nreturn null;\n}\n// value 在此处可访问，值为 undefined\n}\n```\n\n<!--more-->\n在这里可以很明显的知道value虽然定义在了if为真后的语句块中但事实上在整个函数内部都能访问的到，这段代码实际上相当于\n\n```javascript\nfunction getValue(condition) {\n\nvar value;\nif (condition) {\nvalue = \"blue\"\n```\n\n这就可能会产生一些意想不到的问题了，因此ES6中增加了一个**块级作用域**的概念（*就是让所声明的变量在指定块的作用域外无法被访问。块级作用域（词法作用域）在如下情况被创建：*\n1. *在一个函数内部*\n2. *在一个代码块（由一对花括号{}包裹）内部）* \n\n### let与const\n\n#### 共同特性：\n\n- 块级声明：两者均为块级声明即仅在当前定义语句行开始生效，以let为例：\n\n- ```javascript\nfunction getValue(condition) {\n  if (condition) {\n  //console.log(value)报错\n\n   let value = \"blue\";\n\n  //console.log(value) blue\neturn value;\n  } else {\n  \n  return null;\n}\n  \n  }\n  ```\n\n\n\n- 禁止重复声明：在同一作用域内不能重复声明一个参数，否则会报错。\n\n- 暂时性死区：使用let与const声明的变量会被存放到暂时性死区中，只有js引擎执行到该语句时声明语句才会把它移出，在此之前的任何对死区内变量进行的操作都会发生运行时异常（runtime error）\n\n- 全局块级绑定：当在全局作用域上使用 var 时，它会创建一个新的全局变量，并成为全局对象（在浏览器中是 window ）的一个属性。这可能会无意中覆盖原本自带的属性例：\n\n  ![](ES6总结一(变量与函数)/全局块级绑定1.png)\n\n  RegExp原本是全局自带的函数 但是用var声明同名全局变量后，原本的RegExp就被新值代替了，这样就无法使用原本自带的正则函数，而let与const的全局绑定的时候会创建一个全新变量而屏蔽自带的同名变量，这样避免了全局属性被污染例：\n\n  ![](ES6总结一(变量与函数)/全局块级绑定2.png)\n\n需要注意的是在这种情况下使用自定义的变量直接变量名即可而需要使用全局自带方法时需要用window.\n\n#### const特性\n\nconst关键字用于声明一个不可修改的常量，一般情况而言对于const声明的变量进行任何修改都会报错，除此之外还有一种情况下不会报错：**对象或数组等引用类型中对于属性值的修改**，只要不是对整个类型进行操作都是合法的例：\n\n![](ES6总结一(变量与函数)/const声明.png)\n\n\n\n## 函数\n\n### 参数对象\n\n- ES5的默认参数值问题：先看一个例子：\n\n- ```javascript\n  function getRequest(url, timeout, timeout) {\n  timeout = timeout || 2000;\n  allback = callback || function() {};\n  // 函数的剩余部分\n  }\n  ```\n\n 在这个函数中我们用||运算符给timeout，timeout都赋予了默认值，但是当timeout为0时由于0的布尔值为false所以会被设为2000但有时候其实是需要赋值为0的，所以在我们为函数赋默认值时有时候会有出现传0或‘’参数被覆盖的情况，解决这种情况可以用typeof===‘undefined’解决但是增加了很多代码量，所以es6中对这种情况进行了改进\n\n- ES6中参数对象--(**具名对象**)\n  - **语法**:`function makeRequest(url, timeout = 2000, callback = function() {}) }`ES6中一般在参数列表声明时赋与默认值，在这种情况下只有两种函数才会有默认值\n\n1. ​\t\t未传入第二三个对象\n2. 传入undfined(这里的null是一个数据类型，因此传入null不会赋予默认值)\n  \n   - **消除对arguments对象的影响**：在ES5中在函数对与参数的任意操作都会影响到arguments对象里面的值，只有在ES5严格模式下才会消除影响而只要被启用了ES6规则都可以消除影响\n   \n   - **传递默认表达式**：在设置具名参数默认值的时候不仅可以使用基本参数类型还可以使用表达式，即\n   \n   - ```javascript\n     function getValue() {\n     return 5;\n     }\n     function add(first=1, second = getValue()) {\n     return first + second;\n     }\n     console.log(add(1, 1)); // 2\n     console.log(add(1)); // 6\n     console.log(add(1)); // 7\n     ```\n   \n   - 在这种情况下我们就能够动态的给具名参数赋值，也因此可以**默认值复用**即我们除了可以使用表达式赋值还能够使用前面的参数赋值`function add(first=1, second=first)`，但需要注意我们使用表达式的时候一定本那个忘记()否则只是传递了引用而非结果，前面的参数也不能复用后面参数的默认值\n   \n   - **暂时性死区**：在let和const中存在暂时性死区同样的，在声明具名参数的时候也存在暂时性死区，在赋值表达式的时候说了前面的参数无法复用后面的，原因就在此，以上面的函数为例，在js执行的时候参数的赋值方式是：`let first=1;let second=getValue()`,所以由于let与const的暂时性死区也造成了具名参数的暂时性死区\n\n- ES6中参数对象--(**具名对象**)\n\n  - 剩余参数对象\n\n    - 语法：有...与紧跟的具名参数组成例\n\n      ```javascript\n      function pick(object, ...keys) {\n      let result = Object.create(null);\n      for (let i = 0, len = keys.length; i < len; i++) {\n      result[keys[i]] = object[keys[i]];\n      }\n      return result;\n      }\n      ```\n\n      keys就是一个剩余参数对象，他会包含object之后的所有参数对象\n\n    - 使用的时候要注意两个点1.不能再剩余参数之后再声明参数，2.不能再settr字面量属性中使用\n\n-   拓展运算符(...)\n  \n- 拓展运算符会便利参数对象所有可枚举的属性，拷贝到当前对象中，对象，数组。字符串等均可使用\n  \n- 箭头函数(=>)\n  - 语法：`（）=>{函数体}`,当只有一个参数或者之有一条执行语句时可以省略括号，当有多个参数，无参数，函数体有多条语句时必须用`（）=>{}`的格式\n  - 特点：\n    - **没有this绑定**:箭头函数体内部的this与调用它的父级指向一致\n    - **没有arguments绑定**：函数体内无法使用arguments访问它本身的参数对象，但是可以访问父级的arguments对象\n    - **具名参数和不具名参数**:在箭头函数中都能正常使用\n\n- 尾调用优化：\n\n  - 语法：在函数的最后一句调用某函数的第一句(也可以是自己)例：\n\n    ```javascript\n    function Something() {\n    return SomethingElse(); // 尾调用\n    }\n    ```\n\n  - 作用：会清除当前函数的栈帧并重复使用以此提高性能在ES6严格模式中有以下情况会启用尾调用：\n\n    1. 尾调用不能引用当前栈帧中的变量（意味着该函数不能是闭包）；\n    2. 进行尾调用的函数在尾调用返回结果后不能做额外操作；\n    3. 尾调用的结果作为当前函数的返回值。\n\n  - 应用：一般是应用在递归函数，或者有复杂计算过程的函数时效果明显，\n\n","source":"_posts/ES6总结一(变量与函数).md","raw":"---\ntitle: ES6语法总结(一)\ndate: 2019-10-11 17:22:55\ntags:\n\t- 前端\n\t- ES6\ncategories:\n\t- web前端\n\t\n---\n\n\n\n# ES6语法总结\n\n## 块级绑定（*let ，var，const*）\n\n### 传统var的问题（*变量提升，块级作用域*）\n\nvar是用来声明各类型变量的关键字，但存在一个问题--**变量提升**（*在当前作用域内使用var关键词声明的变量都会提升到当前作用域的顶部*）例:\n\n```javascript\nfunction getValue(condition) {\nif (condition) {\nvar value = \"blue\";\n// 其他代码\nreturn value;\n} else {\n// value 在此处可访问，值为 undefined\nreturn null;\n}\n// value 在此处可访问，值为 undefined\n}\n```\n\n<!--more-->\n在这里可以很明显的知道value虽然定义在了if为真后的语句块中但事实上在整个函数内部都能访问的到，这段代码实际上相当于\n\n```javascript\nfunction getValue(condition) {\n\nvar value;\nif (condition) {\nvalue = \"blue\"\n```\n\n这就可能会产生一些意想不到的问题了，因此ES6中增加了一个**块级作用域**的概念（*就是让所声明的变量在指定块的作用域外无法被访问。块级作用域（词法作用域）在如下情况被创建：*\n1. *在一个函数内部*\n2. *在一个代码块（由一对花括号{}包裹）内部）* \n\n### let与const\n\n#### 共同特性：\n\n- 块级声明：两者均为块级声明即仅在当前定义语句行开始生效，以let为例：\n\n- ```javascript\nfunction getValue(condition) {\n  if (condition) {\n  //console.log(value)报错\n\n   let value = \"blue\";\n\n  //console.log(value) blue\neturn value;\n  } else {\n  \n  return null;\n}\n  \n  }\n  ```\n\n\n\n- 禁止重复声明：在同一作用域内不能重复声明一个参数，否则会报错。\n\n- 暂时性死区：使用let与const声明的变量会被存放到暂时性死区中，只有js引擎执行到该语句时声明语句才会把它移出，在此之前的任何对死区内变量进行的操作都会发生运行时异常（runtime error）\n\n- 全局块级绑定：当在全局作用域上使用 var 时，它会创建一个新的全局变量，并成为全局对象（在浏览器中是 window ）的一个属性。这可能会无意中覆盖原本自带的属性例：\n\n  ![](ES6总结一(变量与函数)/全局块级绑定1.png)\n\n  RegExp原本是全局自带的函数 但是用var声明同名全局变量后，原本的RegExp就被新值代替了，这样就无法使用原本自带的正则函数，而let与const的全局绑定的时候会创建一个全新变量而屏蔽自带的同名变量，这样避免了全局属性被污染例：\n\n  ![](ES6总结一(变量与函数)/全局块级绑定2.png)\n\n需要注意的是在这种情况下使用自定义的变量直接变量名即可而需要使用全局自带方法时需要用window.\n\n#### const特性\n\nconst关键字用于声明一个不可修改的常量，一般情况而言对于const声明的变量进行任何修改都会报错，除此之外还有一种情况下不会报错：**对象或数组等引用类型中对于属性值的修改**，只要不是对整个类型进行操作都是合法的例：\n\n![](ES6总结一(变量与函数)/const声明.png)\n\n\n\n## 函数\n\n### 参数对象\n\n- ES5的默认参数值问题：先看一个例子：\n\n- ```javascript\n  function getRequest(url, timeout, timeout) {\n  timeout = timeout || 2000;\n  allback = callback || function() {};\n  // 函数的剩余部分\n  }\n  ```\n\n 在这个函数中我们用||运算符给timeout，timeout都赋予了默认值，但是当timeout为0时由于0的布尔值为false所以会被设为2000但有时候其实是需要赋值为0的，所以在我们为函数赋默认值时有时候会有出现传0或‘’参数被覆盖的情况，解决这种情况可以用typeof===‘undefined’解决但是增加了很多代码量，所以es6中对这种情况进行了改进\n\n- ES6中参数对象--(**具名对象**)\n  - **语法**:`function makeRequest(url, timeout = 2000, callback = function() {}) }`ES6中一般在参数列表声明时赋与默认值，在这种情况下只有两种函数才会有默认值\n\n1. ​\t\t未传入第二三个对象\n2. 传入undfined(这里的null是一个数据类型，因此传入null不会赋予默认值)\n  \n   - **消除对arguments对象的影响**：在ES5中在函数对与参数的任意操作都会影响到arguments对象里面的值，只有在ES5严格模式下才会消除影响而只要被启用了ES6规则都可以消除影响\n   \n   - **传递默认表达式**：在设置具名参数默认值的时候不仅可以使用基本参数类型还可以使用表达式，即\n   \n   - ```javascript\n     function getValue() {\n     return 5;\n     }\n     function add(first=1, second = getValue()) {\n     return first + second;\n     }\n     console.log(add(1, 1)); // 2\n     console.log(add(1)); // 6\n     console.log(add(1)); // 7\n     ```\n   \n   - 在这种情况下我们就能够动态的给具名参数赋值，也因此可以**默认值复用**即我们除了可以使用表达式赋值还能够使用前面的参数赋值`function add(first=1, second=first)`，但需要注意我们使用表达式的时候一定本那个忘记()否则只是传递了引用而非结果，前面的参数也不能复用后面参数的默认值\n   \n   - **暂时性死区**：在let和const中存在暂时性死区同样的，在声明具名参数的时候也存在暂时性死区，在赋值表达式的时候说了前面的参数无法复用后面的，原因就在此，以上面的函数为例，在js执行的时候参数的赋值方式是：`let first=1;let second=getValue()`,所以由于let与const的暂时性死区也造成了具名参数的暂时性死区\n\n- ES6中参数对象--(**具名对象**)\n\n  - 剩余参数对象\n\n    - 语法：有...与紧跟的具名参数组成例\n\n      ```javascript\n      function pick(object, ...keys) {\n      let result = Object.create(null);\n      for (let i = 0, len = keys.length; i < len; i++) {\n      result[keys[i]] = object[keys[i]];\n      }\n      return result;\n      }\n      ```\n\n      keys就是一个剩余参数对象，他会包含object之后的所有参数对象\n\n    - 使用的时候要注意两个点1.不能再剩余参数之后再声明参数，2.不能再settr字面量属性中使用\n\n-   拓展运算符(...)\n  \n- 拓展运算符会便利参数对象所有可枚举的属性，拷贝到当前对象中，对象，数组。字符串等均可使用\n  \n- 箭头函数(=>)\n  - 语法：`（）=>{函数体}`,当只有一个参数或者之有一条执行语句时可以省略括号，当有多个参数，无参数，函数体有多条语句时必须用`（）=>{}`的格式\n  - 特点：\n    - **没有this绑定**:箭头函数体内部的this与调用它的父级指向一致\n    - **没有arguments绑定**：函数体内无法使用arguments访问它本身的参数对象，但是可以访问父级的arguments对象\n    - **具名参数和不具名参数**:在箭头函数中都能正常使用\n\n- 尾调用优化：\n\n  - 语法：在函数的最后一句调用某函数的第一句(也可以是自己)例：\n\n    ```javascript\n    function Something() {\n    return SomethingElse(); // 尾调用\n    }\n    ```\n\n  - 作用：会清除当前函数的栈帧并重复使用以此提高性能在ES6严格模式中有以下情况会启用尾调用：\n\n    1. 尾调用不能引用当前栈帧中的变量（意味着该函数不能是闭包）；\n    2. 进行尾调用的函数在尾调用返回结果后不能做额外操作；\n    3. 尾调用的结果作为当前函数的返回值。\n\n  - 应用：一般是应用在递归函数，或者有复杂计算过程的函数时效果明显，\n\n","slug":"ES6总结一(变量与函数)","published":1,"updated":"2020-04-22T03:43:10.779Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9cue22800023gcsaab3gbnf","content":"<h1 id=\"ES6语法总结\"><a href=\"#ES6语法总结\" class=\"headerlink\" title=\"ES6语法总结\"></a>ES6语法总结</h1><h2 id=\"块级绑定（let-，var，const）\"><a href=\"#块级绑定（let-，var，const）\" class=\"headerlink\" title=\"块级绑定（let ，var，const）\"></a>块级绑定（<em>let ，var，const</em>）</h2><h3 id=\"传统var的问题（变量提升，块级作用域）\"><a href=\"#传统var的问题（变量提升，块级作用域）\" class=\"headerlink\" title=\"传统var的问题（变量提升，块级作用域）\"></a>传统var的问题（<em>变量提升，块级作用域</em>）</h3><p>var是用来声明各类型变量的关键字，但存在一个问题–<strong>变量提升</strong>（<em>在当前作用域内使用var关键词声明的变量都会提升到当前作用域的顶部</em>）例:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getValue</span>(<span class=\"params\">condition</span>) </span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (condition) &#123;</span><br><span class=\"line\"><span class=\"keyword\">var</span> value = <span class=\"string\">\"blue\"</span>;</span><br><span class=\"line\"><span class=\"comment\">// 其他代码</span></span><br><span class=\"line\"><span class=\"keyword\">return</span> value;</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\"><span class=\"comment\">// value 在此处可访问，值为 undefined</span></span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// value 在此处可访问，值为 undefined</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<a id=\"more\"></a>\n<p>在这里可以很明显的知道value虽然定义在了if为真后的语句块中但事实上在整个函数内部都能访问的到，这段代码实际上相当于</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getValue</span>(<span class=\"params\">condition</span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> value;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (condition) &#123;</span><br><span class=\"line\">value = <span class=\"string\">\"blue\"</span></span><br></pre></td></tr></table></figure>\n\n<p>这就可能会产生一些意想不到的问题了，因此ES6中增加了一个<strong>块级作用域</strong>的概念（<em>就是让所声明的变量在指定块的作用域外无法被访问。块级作用域（词法作用域）在如下情况被创建：</em></p>\n<ol>\n<li><em>在一个函数内部</em></li>\n<li><em>在一个代码块（由一对花括号{}包裹）内部）</em> </li>\n</ol>\n<h3 id=\"let与const\"><a href=\"#let与const\" class=\"headerlink\" title=\"let与const\"></a>let与const</h3><h4 id=\"共同特性：\"><a href=\"#共同特性：\" class=\"headerlink\" title=\"共同特性：\"></a>共同特性：</h4><ul>\n<li><p>块级声明：两者均为块级声明即仅在当前定义语句行开始生效，以let为例：</p>\n</li>\n<li><pre><code class=\"javascript\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getValue</span>(<span class=\"params\">condition</span>) </span>{\n<span class=\"keyword\">if</span> (condition) {\n<span class=\"comment\">//console.log(value)报错</span>\n\n <span class=\"keyword\">let</span> value = <span class=\"string\">\"blue\"</span>;\n\n<span class=\"comment\">//console.log(value) blue</span>\neturn value;\n} <span class=\"keyword\">else</span> {\n\n<span class=\"keyword\">return</span> <span class=\"literal\">null</span>;\n}\n\n}\n&lt;!--￼<span class=\"number\">2</span>--&gt;\n\n在这个函数中我们用||运算符给timeout，timeout都赋予了默认值，但是当timeout为<span class=\"number\">0</span>时由于<span class=\"number\">0</span>的布尔值为<span class=\"literal\">false</span>所以会被设为<span class=\"number\">2000</span>但有时候其实是需要赋值为<span class=\"number\">0</span>的，所以在我们为函数赋默认值时有时候会有出现传<span class=\"number\">0</span>或‘’参数被覆盖的情况，解决这种情况可以用<span class=\"keyword\">typeof</span>===‘<span class=\"literal\">undefined</span>’解决但是增加了很多代码量，所以es6中对这种情况进行了改进</code></pre>\n</li>\n<li><p>ES6中参数对象–(<strong>具名对象</strong>)</p>\n<ul>\n<li><strong>语法</strong>:<code>function makeRequest(url, timeout = 2000, callback = function() {}) }</code>ES6中一般在参数列表声明时赋与默认值，在这种情况下只有两种函数才会有默认值</li>\n</ul>\n</li>\n</ul>\n<ol>\n<li><p>​        未传入第二三个对象</p>\n</li>\n<li><p>传入undfined(这里的null是一个数据类型，因此传入null不会赋予默认值)</p>\n<ul>\n<li><p><strong>消除对arguments对象的影响</strong>：在ES5中在函数对与参数的任意操作都会影响到arguments对象里面的值，只有在ES5严格模式下才会消除影响而只要被启用了ES6规则都可以消除影响</p>\n</li>\n<li><p><strong>传递默认表达式</strong>：在设置具名参数默认值的时候不仅可以使用基本参数类型还可以使用表达式，即</p>\n</li>\n<li><pre><code class=\"javascript\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getValue</span>(<span class=\"params\"></span>) </span>{\n<span class=\"keyword\">return</span> <span class=\"number\">5</span>;\n}\n<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">add</span>(<span class=\"params\">first=<span class=\"number\">1</span>, second = getValue(</span>)) </span>{\n<span class=\"keyword\">return</span> first + second;\n}\n<span class=\"built_in\">console</span>.log(add(<span class=\"number\">1</span>, <span class=\"number\">1</span>)); <span class=\"comment\">// 2</span>\n<span class=\"built_in\">console</span>.log(add(<span class=\"number\">1</span>)); <span class=\"comment\">// 6</span>\n<span class=\"built_in\">console</span>.log(add(<span class=\"number\">1</span>)); <span class=\"comment\">// 7</span>\n&lt;!--￼<span class=\"number\">3</span>--&gt;\n\n keys就是一个剩余参数对象，他会包含object之后的所有参数对象\n\n- 使用的时候要注意两个点<span class=\"number\">1.</span>不能再剩余参数之后再声明参数，<span class=\"number\">2.</span>不能再settr字面量属性中使用</code></pre>\n</li>\n</ul>\n</li>\n</ol>\n<ul>\n<li><p>拓展运算符(…)</p>\n</li>\n<li><p>拓展运算符会便利参数对象所有可枚举的属性，拷贝到当前对象中，对象，数组。字符串等均可使用</p>\n</li>\n<li><p>箭头函数(=&gt;)</p>\n<ul>\n<li>语法：<code>（）=&gt;{函数体}</code>,当只有一个参数或者之有一条执行语句时可以省略括号，当有多个参数，无参数，函数体有多条语句时必须用<code>（）=&gt;{}</code>的格式</li>\n<li>特点：<ul>\n<li><strong>没有this绑定</strong>:箭头函数体内部的this与调用它的父级指向一致</li>\n<li><strong>没有arguments绑定</strong>：函数体内无法使用arguments访问它本身的参数对象，但是可以访问父级的arguments对象</li>\n<li><strong>具名参数和不具名参数</strong>:在箭头函数中都能正常使用</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>尾调用优化：</p>\n<ul>\n<li><p>语法：在函数的最后一句调用某函数的第一句(也可以是自己)例：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Something</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">return</span> SomethingElse(); <span class=\"comment\">// 尾调用</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>作用：会清除当前函数的栈帧并重复使用以此提高性能在ES6严格模式中有以下情况会启用尾调用：</p>\n<ol>\n<li>尾调用不能引用当前栈帧中的变量（意味着该函数不能是闭包）；</li>\n<li>进行尾调用的函数在尾调用返回结果后不能做额外操作；</li>\n<li>尾调用的结果作为当前函数的返回值。</li>\n</ol>\n</li>\n<li><p>应用：一般是应用在递归函数，或者有复杂计算过程的函数时效果明显，</p>\n</li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"<h1 id=\"ES6语法总结\"><a href=\"#ES6语法总结\" class=\"headerlink\" title=\"ES6语法总结\"></a>ES6语法总结</h1><h2 id=\"块级绑定（let-，var，const）\"><a href=\"#块级绑定（let-，var，const）\" class=\"headerlink\" title=\"块级绑定（let ，var，const）\"></a>块级绑定（<em>let ，var，const</em>）</h2><h3 id=\"传统var的问题（变量提升，块级作用域）\"><a href=\"#传统var的问题（变量提升，块级作用域）\" class=\"headerlink\" title=\"传统var的问题（变量提升，块级作用域）\"></a>传统var的问题（<em>变量提升，块级作用域</em>）</h3><p>var是用来声明各类型变量的关键字，但存在一个问题–<strong>变量提升</strong>（<em>在当前作用域内使用var关键词声明的变量都会提升到当前作用域的顶部</em>）例:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getValue</span>(<span class=\"params\">condition</span>) </span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (condition) &#123;</span><br><span class=\"line\"><span class=\"keyword\">var</span> value = <span class=\"string\">\"blue\"</span>;</span><br><span class=\"line\"><span class=\"comment\">// 其他代码</span></span><br><span class=\"line\"><span class=\"keyword\">return</span> value;</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\"><span class=\"comment\">// value 在此处可访问，值为 undefined</span></span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// value 在此处可访问，值为 undefined</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","more":"<p>在这里可以很明显的知道value虽然定义在了if为真后的语句块中但事实上在整个函数内部都能访问的到，这段代码实际上相当于</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getValue</span>(<span class=\"params\">condition</span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> value;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (condition) &#123;</span><br><span class=\"line\">value = <span class=\"string\">\"blue\"</span></span><br></pre></td></tr></table></figure>\n\n<p>这就可能会产生一些意想不到的问题了，因此ES6中增加了一个<strong>块级作用域</strong>的概念（<em>就是让所声明的变量在指定块的作用域外无法被访问。块级作用域（词法作用域）在如下情况被创建：</em></p>\n<ol>\n<li><em>在一个函数内部</em></li>\n<li><em>在一个代码块（由一对花括号{}包裹）内部）</em> </li>\n</ol>\n<h3 id=\"let与const\"><a href=\"#let与const\" class=\"headerlink\" title=\"let与const\"></a>let与const</h3><h4 id=\"共同特性：\"><a href=\"#共同特性：\" class=\"headerlink\" title=\"共同特性：\"></a>共同特性：</h4><ul>\n<li><p>块级声明：两者均为块级声明即仅在当前定义语句行开始生效，以let为例：</p>\n</li>\n<li><pre><code class=\"javascript\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getValue</span>(<span class=\"params\">condition</span>) </span>{\n<span class=\"keyword\">if</span> (condition) {\n<span class=\"comment\">//console.log(value)报错</span>\n\n <span class=\"keyword\">let</span> value = <span class=\"string\">\"blue\"</span>;\n\n<span class=\"comment\">//console.log(value) blue</span>\neturn value;\n} <span class=\"keyword\">else</span> {\n\n<span class=\"keyword\">return</span> <span class=\"literal\">null</span>;\n}\n\n}\n&lt;!--￼<span class=\"number\">2</span>--&gt;\n\n在这个函数中我们用||运算符给timeout，timeout都赋予了默认值，但是当timeout为<span class=\"number\">0</span>时由于<span class=\"number\">0</span>的布尔值为<span class=\"literal\">false</span>所以会被设为<span class=\"number\">2000</span>但有时候其实是需要赋值为<span class=\"number\">0</span>的，所以在我们为函数赋默认值时有时候会有出现传<span class=\"number\">0</span>或‘’参数被覆盖的情况，解决这种情况可以用<span class=\"keyword\">typeof</span>===‘<span class=\"literal\">undefined</span>’解决但是增加了很多代码量，所以es6中对这种情况进行了改进</code></pre>\n</li>\n<li><p>ES6中参数对象–(<strong>具名对象</strong>)</p>\n<ul>\n<li><strong>语法</strong>:<code>function makeRequest(url, timeout = 2000, callback = function() {}) }</code>ES6中一般在参数列表声明时赋与默认值，在这种情况下只有两种函数才会有默认值</li>\n</ul>\n</li>\n</ul>\n<ol>\n<li><p>​        未传入第二三个对象</p>\n</li>\n<li><p>传入undfined(这里的null是一个数据类型，因此传入null不会赋予默认值)</p>\n<ul>\n<li><p><strong>消除对arguments对象的影响</strong>：在ES5中在函数对与参数的任意操作都会影响到arguments对象里面的值，只有在ES5严格模式下才会消除影响而只要被启用了ES6规则都可以消除影响</p>\n</li>\n<li><p><strong>传递默认表达式</strong>：在设置具名参数默认值的时候不仅可以使用基本参数类型还可以使用表达式，即</p>\n</li>\n<li><pre><code class=\"javascript\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getValue</span>(<span class=\"params\"></span>) </span>{\n<span class=\"keyword\">return</span> <span class=\"number\">5</span>;\n}\n<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">add</span>(<span class=\"params\">first=<span class=\"number\">1</span>, second = getValue(</span>)) </span>{\n<span class=\"keyword\">return</span> first + second;\n}\n<span class=\"built_in\">console</span>.log(add(<span class=\"number\">1</span>, <span class=\"number\">1</span>)); <span class=\"comment\">// 2</span>\n<span class=\"built_in\">console</span>.log(add(<span class=\"number\">1</span>)); <span class=\"comment\">// 6</span>\n<span class=\"built_in\">console</span>.log(add(<span class=\"number\">1</span>)); <span class=\"comment\">// 7</span>\n&lt;!--￼<span class=\"number\">3</span>--&gt;\n\n keys就是一个剩余参数对象，他会包含object之后的所有参数对象\n\n- 使用的时候要注意两个点<span class=\"number\">1.</span>不能再剩余参数之后再声明参数，<span class=\"number\">2.</span>不能再settr字面量属性中使用</code></pre>\n</li>\n</ul>\n</li>\n</ol>\n<ul>\n<li><p>拓展运算符(…)</p>\n</li>\n<li><p>拓展运算符会便利参数对象所有可枚举的属性，拷贝到当前对象中，对象，数组。字符串等均可使用</p>\n</li>\n<li><p>箭头函数(=&gt;)</p>\n<ul>\n<li>语法：<code>（）=&gt;{函数体}</code>,当只有一个参数或者之有一条执行语句时可以省略括号，当有多个参数，无参数，函数体有多条语句时必须用<code>（）=&gt;{}</code>的格式</li>\n<li>特点：<ul>\n<li><strong>没有this绑定</strong>:箭头函数体内部的this与调用它的父级指向一致</li>\n<li><strong>没有arguments绑定</strong>：函数体内无法使用arguments访问它本身的参数对象，但是可以访问父级的arguments对象</li>\n<li><strong>具名参数和不具名参数</strong>:在箭头函数中都能正常使用</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>尾调用优化：</p>\n<ul>\n<li><p>语法：在函数的最后一句调用某函数的第一句(也可以是自己)例：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Something</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">return</span> SomethingElse(); <span class=\"comment\">// 尾调用</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>作用：会清除当前函数的栈帧并重复使用以此提高性能在ES6严格模式中有以下情况会启用尾调用：</p>\n<ol>\n<li>尾调用不能引用当前栈帧中的变量（意味着该函数不能是闭包）；</li>\n<li>进行尾调用的函数在尾调用返回结果后不能做额外操作；</li>\n<li>尾调用的结果作为当前函数的返回值。</li>\n</ol>\n</li>\n<li><p>应用：一般是应用在递归函数，或者有复杂计算过程的函数时效果明显，</p>\n</li>\n</ul>\n</li>\n</ul>"},{"title":"日系风格拍摄思路","date":"2020-04-09T14:45:18.000Z","_content":"\n![](日系风格调色思路/photograph.jpg)\n\n# 日系风格拍摄思路\n\n最近开始尝试拍摄日系风格，看了网上很多文章，之后在拍摄和后期的过程中自己也在不断的改进慢慢的有了一些浅薄的理解，但基于每个人摄影的风格，采用的手法，照片的构图等等都不一样。具体操作参数并没有普遍意义，所以我只写总体思路，这样应用场景能广泛些。\n\n## 什么是日系风格\n\n我所理解的日系风格简单来说就是从小到大接触的日本的动漫，电影，插画等等这里选取几部我很喜欢的日系电影《海街日记》《小森林》来说明\n\n先看看不同手法的剧照和巨巨巨想去的镰仓\n\n![](日系风格调色思路/海街日记1.jpg)\n\n<center><font color='#ccc'><em>《海街日记》</em></font></center>\n<!--more-->\n\n![](日系风格调色思路/小森林·冬春.jpg)\n\n<center><font color='#ccc'><em>《小森林·冬春》</em></font></center>\n\n![](日系风格调色思路/海街日记3.jpg)\n\n<center><font color='#ccc' ><em>《海街日记》--樱花</em></font></center>\n![](日系风格调色思路/海街日记2.jpg)\n\n<center><font color='#ccc' ><em>《海街日记》--小家</em></font></center>\n日系风格的电影和照片总是给人一种治愈，温暖，简单的情绪，而这种来自于**真实和谐的照片内容结构+整体相似的色彩渲染的氛围**\n\n#### 内容结构\n\n在以上的例子中有冷暖色调和高低色温,但他们的场景都有一个共通点——简单，不管是街景，樱花，树林还是院落都是我们生活中常见的景象，不需要特殊的构图，线条，力求真实，看起来就像是我们生活中不经意的瞬间\n\n#### 色彩\n\n真实简单的场景仅能够有代入感但这远不足够，还需要色彩来调整照片的重点和加强氛围借此来表达出情绪,个人认为这一类清新的日系所追求的目标应该是照片所有内容共同构建出来的氛围，所以我们应当让整体和谐，削弱突出的细节，把看者注意力转移整体的情景中。在大部分情况下降低对比度都是一个必要的选择。\n\n## 日系风格的取景\n\n这一类的日系取景的整体思路,就是雨露均沾。在拍摄前最好在脑海中先构建出你需要拍摄的大概情景或者想要的效果，再根据效果和实际场景去取景。这部分除了丰富的想象力之外我觉着多看这一类的电(强推是枝裕和，总是在看似无趣的日常里面表达出轻微但是稠密且绵长的情感。非常nice~)或者多看类似的图片会好一些，画面主体内容上结构比例和谐即可但最好不要出现过于突出的主体.\n\n如果是有人像参与，最好让人像成为景中的一部分，穿着上也尽量素一些，太过花哨的着装会浪费多余的注意力，破坏整体的情境，着装的色调也最好和整体环境的色调贴近，不好选的话中性色调是个不错的选择。\n\n\n\n## 日系风格的后期调色\n\n原片完成之后，后期调色也是渲染氛围的重要一步，在整体色调上尽量以主体环境颜色以基准或者以你提前想好的效果为准(但是一定要偏色)，照片整体的色温贴近而色调需要取决于画面的主体和颜色的通透情况而定，在大多数情况下需要降低对比度，提高曝光。\n\n## 样例\n\n下面也选了两张我自己拍摄的，第二章由于原片被我删了所以只讲一下我第一张的调色思路，以下是原图\n\n![](日系风格调色思路/原图1.jpg)\n\n这一张拍摄前我提前想好了想要一种夏日林间少女感觉，所以采用的是逆光手法+大光圈拍摄，当时拍摄的时间是四五点的公园树林里，照片主体偏黄，所以整体风格选都尽量靠近暖色上面靠近，且能观察到画面上除余阳光直射的部分外其他部分都偏暗。\n\n小清新类的日系照片通透性都非常好，而我们首先要做的就是让画面看起来干净，整体性强一些。先降低对比度增强整体性，其次增加曝光和亮度来进一步削弱带来的影响消除影响，增加通透性。\n\n画面干净之后我们需要做的就是调整色温和色调，制造偏色来营造我们想要的效果，已经说过我们主体选用的是暖色调，所以我们需要画面看起来干净温暖，调高色温降低色调让整体画面去贴近暖色，同时也要适当调整饱和度，让画面整体颜色结构合理。\n\n再后就是做一些微小的细节处理，增加阴影亮度，黑白色阶，高光，降低清晰度等等去贴近我们想要的效果。\n\n![](日系风格调色思路/日系2.jpg)\n\n第二掌拍摄的时候并没有想好，只是拍摄第一张的过程中偶然拍摄的，所以整体效果是后期自己决定的，主题颜色是绿色，所以整体颜色也向中性偏冷靠近，这张拍摄的时候就很亮了，取景布局也很好，不需要改动结果只需要简单的增加绿色明度，纯度去增强画面主体(由于是近景所以画面整体性和谐就略等于主体+背景)，略微增加高光阴影，降低黑色色阶，增加背景和主体的对比。最后略微降低色温和色调，制造偏色即可。\n\n![](日系风格调色思路/日系3.jpg)","source":"_posts/日系风格调色思路.md","raw":"---\ntitle: 日系风格拍摄思路\ndate: 2020-04-09 22:45:18\ntags:\n\t- 后期\n\t- 随笔\n\t- 调色\n\t- 摄影\ncategories:\n\t- 摄影\n---\n\n![](日系风格调色思路/photograph.jpg)\n\n# 日系风格拍摄思路\n\n最近开始尝试拍摄日系风格，看了网上很多文章，之后在拍摄和后期的过程中自己也在不断的改进慢慢的有了一些浅薄的理解，但基于每个人摄影的风格，采用的手法，照片的构图等等都不一样。具体操作参数并没有普遍意义，所以我只写总体思路，这样应用场景能广泛些。\n\n## 什么是日系风格\n\n我所理解的日系风格简单来说就是从小到大接触的日本的动漫，电影，插画等等这里选取几部我很喜欢的日系电影《海街日记》《小森林》来说明\n\n先看看不同手法的剧照和巨巨巨想去的镰仓\n\n![](日系风格调色思路/海街日记1.jpg)\n\n<center><font color='#ccc'><em>《海街日记》</em></font></center>\n<!--more-->\n\n![](日系风格调色思路/小森林·冬春.jpg)\n\n<center><font color='#ccc'><em>《小森林·冬春》</em></font></center>\n\n![](日系风格调色思路/海街日记3.jpg)\n\n<center><font color='#ccc' ><em>《海街日记》--樱花</em></font></center>\n![](日系风格调色思路/海街日记2.jpg)\n\n<center><font color='#ccc' ><em>《海街日记》--小家</em></font></center>\n日系风格的电影和照片总是给人一种治愈，温暖，简单的情绪，而这种来自于**真实和谐的照片内容结构+整体相似的色彩渲染的氛围**\n\n#### 内容结构\n\n在以上的例子中有冷暖色调和高低色温,但他们的场景都有一个共通点——简单，不管是街景，樱花，树林还是院落都是我们生活中常见的景象，不需要特殊的构图，线条，力求真实，看起来就像是我们生活中不经意的瞬间\n\n#### 色彩\n\n真实简单的场景仅能够有代入感但这远不足够，还需要色彩来调整照片的重点和加强氛围借此来表达出情绪,个人认为这一类清新的日系所追求的目标应该是照片所有内容共同构建出来的氛围，所以我们应当让整体和谐，削弱突出的细节，把看者注意力转移整体的情景中。在大部分情况下降低对比度都是一个必要的选择。\n\n## 日系风格的取景\n\n这一类的日系取景的整体思路,就是雨露均沾。在拍摄前最好在脑海中先构建出你需要拍摄的大概情景或者想要的效果，再根据效果和实际场景去取景。这部分除了丰富的想象力之外我觉着多看这一类的电(强推是枝裕和，总是在看似无趣的日常里面表达出轻微但是稠密且绵长的情感。非常nice~)或者多看类似的图片会好一些，画面主体内容上结构比例和谐即可但最好不要出现过于突出的主体.\n\n如果是有人像参与，最好让人像成为景中的一部分，穿着上也尽量素一些，太过花哨的着装会浪费多余的注意力，破坏整体的情境，着装的色调也最好和整体环境的色调贴近，不好选的话中性色调是个不错的选择。\n\n\n\n## 日系风格的后期调色\n\n原片完成之后，后期调色也是渲染氛围的重要一步，在整体色调上尽量以主体环境颜色以基准或者以你提前想好的效果为准(但是一定要偏色)，照片整体的色温贴近而色调需要取决于画面的主体和颜色的通透情况而定，在大多数情况下需要降低对比度，提高曝光。\n\n## 样例\n\n下面也选了两张我自己拍摄的，第二章由于原片被我删了所以只讲一下我第一张的调色思路，以下是原图\n\n![](日系风格调色思路/原图1.jpg)\n\n这一张拍摄前我提前想好了想要一种夏日林间少女感觉，所以采用的是逆光手法+大光圈拍摄，当时拍摄的时间是四五点的公园树林里，照片主体偏黄，所以整体风格选都尽量靠近暖色上面靠近，且能观察到画面上除余阳光直射的部分外其他部分都偏暗。\n\n小清新类的日系照片通透性都非常好，而我们首先要做的就是让画面看起来干净，整体性强一些。先降低对比度增强整体性，其次增加曝光和亮度来进一步削弱带来的影响消除影响，增加通透性。\n\n画面干净之后我们需要做的就是调整色温和色调，制造偏色来营造我们想要的效果，已经说过我们主体选用的是暖色调，所以我们需要画面看起来干净温暖，调高色温降低色调让整体画面去贴近暖色，同时也要适当调整饱和度，让画面整体颜色结构合理。\n\n再后就是做一些微小的细节处理，增加阴影亮度，黑白色阶，高光，降低清晰度等等去贴近我们想要的效果。\n\n![](日系风格调色思路/日系2.jpg)\n\n第二掌拍摄的时候并没有想好，只是拍摄第一张的过程中偶然拍摄的，所以整体效果是后期自己决定的，主题颜色是绿色，所以整体颜色也向中性偏冷靠近，这张拍摄的时候就很亮了，取景布局也很好，不需要改动结果只需要简单的增加绿色明度，纯度去增强画面主体(由于是近景所以画面整体性和谐就略等于主体+背景)，略微增加高光阴影，降低黑色色阶，增加背景和主体的对比。最后略微降低色温和色调，制造偏色即可。\n\n![](日系风格调色思路/日系3.jpg)","slug":"日系风格调色思路","published":1,"updated":"2020-04-22T09:25:30.090Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9cue22b00063gcse83h4bmk","content":"<p><img src=\"/2020/04/09/%E6%97%A5%E7%B3%BB%E9%A3%8E%E6%A0%BC%E8%B0%83%E8%89%B2%E6%80%9D%E8%B7%AF/photograph.jpg\" alt></p>\n<h1 id=\"日系风格拍摄思路\"><a href=\"#日系风格拍摄思路\" class=\"headerlink\" title=\"日系风格拍摄思路\"></a>日系风格拍摄思路</h1><p>最近开始尝试拍摄日系风格，看了网上很多文章，之后在拍摄和后期的过程中自己也在不断的改进慢慢的有了一些浅薄的理解，但基于每个人摄影的风格，采用的手法，照片的构图等等都不一样。具体操作参数并没有普遍意义，所以我只写总体思路，这样应用场景能广泛些。</p>\n<h2 id=\"什么是日系风格\"><a href=\"#什么是日系风格\" class=\"headerlink\" title=\"什么是日系风格\"></a>什么是日系风格</h2><p>我所理解的日系风格简单来说就是从小到大接触的日本的动漫，电影，插画等等这里选取几部我很喜欢的日系电影《海街日记》《小森林》来说明</p>\n<p>先看看不同手法的剧照和巨巨巨想去的镰仓</p>\n<p><img src=\"/2020/04/09/%E6%97%A5%E7%B3%BB%E9%A3%8E%E6%A0%BC%E8%B0%83%E8%89%B2%E6%80%9D%E8%B7%AF/%E6%B5%B7%E8%A1%97%E6%97%A5%E8%AE%B01.jpg\" alt></p>\n<center><font color=\"#ccc\"><em>《海街日记》</em></font></center>\n<a id=\"more\"></a>\n\n<p><img src=\"/2020/04/09/%E6%97%A5%E7%B3%BB%E9%A3%8E%E6%A0%BC%E8%B0%83%E8%89%B2%E6%80%9D%E8%B7%AF/%E5%B0%8F%E6%A3%AE%E6%9E%97%C2%B7%E5%86%AC%E6%98%A5.jpg\" alt></p>\n<center><font color=\"#ccc\"><em>《小森林·冬春》</em></font></center>\n\n<p><img src=\"/2020/04/09/%E6%97%A5%E7%B3%BB%E9%A3%8E%E6%A0%BC%E8%B0%83%E8%89%B2%E6%80%9D%E8%B7%AF/%E6%B5%B7%E8%A1%97%E6%97%A5%E8%AE%B03.jpg\" alt></p>\n<center><font color=\"#ccc\"><em>《海街日记》--樱花</em></font></center>\n![](日系风格调色思路/海街日记2.jpg)\n\n<center><font color=\"#ccc\"><em>《海街日记》--小家</em></font></center>\n日系风格的电影和照片总是给人一种治愈，温暖，简单的情绪，而这种来自于**真实和谐的照片内容结构+整体相似的色彩渲染的氛围**\n\n<h4 id=\"内容结构\"><a href=\"#内容结构\" class=\"headerlink\" title=\"内容结构\"></a>内容结构</h4><p>在以上的例子中有冷暖色调和高低色温,但他们的场景都有一个共通点——简单，不管是街景，樱花，树林还是院落都是我们生活中常见的景象，不需要特殊的构图，线条，力求真实，看起来就像是我们生活中不经意的瞬间</p>\n<h4 id=\"色彩\"><a href=\"#色彩\" class=\"headerlink\" title=\"色彩\"></a>色彩</h4><p>真实简单的场景仅能够有代入感但这远不足够，还需要色彩来调整照片的重点和加强氛围借此来表达出情绪,个人认为这一类清新的日系所追求的目标应该是照片所有内容共同构建出来的氛围，所以我们应当让整体和谐，削弱突出的细节，把看者注意力转移整体的情景中。在大部分情况下降低对比度都是一个必要的选择。</p>\n<h2 id=\"日系风格的取景\"><a href=\"#日系风格的取景\" class=\"headerlink\" title=\"日系风格的取景\"></a>日系风格的取景</h2><p>这一类的日系取景的整体思路,就是雨露均沾。在拍摄前最好在脑海中先构建出你需要拍摄的大概情景或者想要的效果，再根据效果和实际场景去取景。这部分除了丰富的想象力之外我觉着多看这一类的电(强推是枝裕和，总是在看似无趣的日常里面表达出轻微但是稠密且绵长的情感。非常nice~)或者多看类似的图片会好一些，画面主体内容上结构比例和谐即可但最好不要出现过于突出的主体.</p>\n<p>如果是有人像参与，最好让人像成为景中的一部分，穿着上也尽量素一些，太过花哨的着装会浪费多余的注意力，破坏整体的情境，着装的色调也最好和整体环境的色调贴近，不好选的话中性色调是个不错的选择。</p>\n<h2 id=\"日系风格的后期调色\"><a href=\"#日系风格的后期调色\" class=\"headerlink\" title=\"日系风格的后期调色\"></a>日系风格的后期调色</h2><p>原片完成之后，后期调色也是渲染氛围的重要一步，在整体色调上尽量以主体环境颜色以基准或者以你提前想好的效果为准(但是一定要偏色)，照片整体的色温贴近而色调需要取决于画面的主体和颜色的通透情况而定，在大多数情况下需要降低对比度，提高曝光。</p>\n<h2 id=\"样例\"><a href=\"#样例\" class=\"headerlink\" title=\"样例\"></a>样例</h2><p>下面也选了两张我自己拍摄的，第二章由于原片被我删了所以只讲一下我第一张的调色思路，以下是原图</p>\n<p><img src=\"/2020/04/09/%E6%97%A5%E7%B3%BB%E9%A3%8E%E6%A0%BC%E8%B0%83%E8%89%B2%E6%80%9D%E8%B7%AF/%E5%8E%9F%E5%9B%BE1.jpg\" alt></p>\n<p>这一张拍摄前我提前想好了想要一种夏日林间少女感觉，所以采用的是逆光手法+大光圈拍摄，当时拍摄的时间是四五点的公园树林里，照片主体偏黄，所以整体风格选都尽量靠近暖色上面靠近，且能观察到画面上除余阳光直射的部分外其他部分都偏暗。</p>\n<p>小清新类的日系照片通透性都非常好，而我们首先要做的就是让画面看起来干净，整体性强一些。先降低对比度增强整体性，其次增加曝光和亮度来进一步削弱带来的影响消除影响，增加通透性。</p>\n<p>画面干净之后我们需要做的就是调整色温和色调，制造偏色来营造我们想要的效果，已经说过我们主体选用的是暖色调，所以我们需要画面看起来干净温暖，调高色温降低色调让整体画面去贴近暖色，同时也要适当调整饱和度，让画面整体颜色结构合理。</p>\n<p>再后就是做一些微小的细节处理，增加阴影亮度，黑白色阶，高光，降低清晰度等等去贴近我们想要的效果。</p>\n<p><img src=\"/2020/04/09/%E6%97%A5%E7%B3%BB%E9%A3%8E%E6%A0%BC%E8%B0%83%E8%89%B2%E6%80%9D%E8%B7%AF/%E6%97%A5%E7%B3%BB2.jpg\" alt></p>\n<p>第二掌拍摄的时候并没有想好，只是拍摄第一张的过程中偶然拍摄的，所以整体效果是后期自己决定的，主题颜色是绿色，所以整体颜色也向中性偏冷靠近，这张拍摄的时候就很亮了，取景布局也很好，不需要改动结果只需要简单的增加绿色明度，纯度去增强画面主体(由于是近景所以画面整体性和谐就略等于主体+背景)，略微增加高光阴影，降低黑色色阶，增加背景和主体的对比。最后略微降低色温和色调，制造偏色即可。</p>\n<p><img src=\"/2020/04/09/%E6%97%A5%E7%B3%BB%E9%A3%8E%E6%A0%BC%E8%B0%83%E8%89%B2%E6%80%9D%E8%B7%AF/%E6%97%A5%E7%B3%BB3.jpg\" alt></p>\n","site":{"data":{}},"excerpt":"<p><img src=\"/2020/04/09/%E6%97%A5%E7%B3%BB%E9%A3%8E%E6%A0%BC%E8%B0%83%E8%89%B2%E6%80%9D%E8%B7%AF/photograph.jpg\" alt></p>\n<h1 id=\"日系风格拍摄思路\"><a href=\"#日系风格拍摄思路\" class=\"headerlink\" title=\"日系风格拍摄思路\"></a>日系风格拍摄思路</h1><p>最近开始尝试拍摄日系风格，看了网上很多文章，之后在拍摄和后期的过程中自己也在不断的改进慢慢的有了一些浅薄的理解，但基于每个人摄影的风格，采用的手法，照片的构图等等都不一样。具体操作参数并没有普遍意义，所以我只写总体思路，这样应用场景能广泛些。</p>\n<h2 id=\"什么是日系风格\"><a href=\"#什么是日系风格\" class=\"headerlink\" title=\"什么是日系风格\"></a>什么是日系风格</h2><p>我所理解的日系风格简单来说就是从小到大接触的日本的动漫，电影，插画等等这里选取几部我很喜欢的日系电影《海街日记》《小森林》来说明</p>\n<p>先看看不同手法的剧照和巨巨巨想去的镰仓</p>\n<p><img src=\"/2020/04/09/%E6%97%A5%E7%B3%BB%E9%A3%8E%E6%A0%BC%E8%B0%83%E8%89%B2%E6%80%9D%E8%B7%AF/%E6%B5%B7%E8%A1%97%E6%97%A5%E8%AE%B01.jpg\" alt></p>\n<center><font color=\"#ccc\"><em>《海街日记》</em></font></center>","more":"<p><img src=\"/2020/04/09/%E6%97%A5%E7%B3%BB%E9%A3%8E%E6%A0%BC%E8%B0%83%E8%89%B2%E6%80%9D%E8%B7%AF/%E5%B0%8F%E6%A3%AE%E6%9E%97%C2%B7%E5%86%AC%E6%98%A5.jpg\" alt></p>\n<center><font color=\"#ccc\"><em>《小森林·冬春》</em></font></center>\n\n<p><img src=\"/2020/04/09/%E6%97%A5%E7%B3%BB%E9%A3%8E%E6%A0%BC%E8%B0%83%E8%89%B2%E6%80%9D%E8%B7%AF/%E6%B5%B7%E8%A1%97%E6%97%A5%E8%AE%B03.jpg\" alt></p>\n<center><font color=\"#ccc\"><em>《海街日记》--樱花</em></font></center>\n![](日系风格调色思路/海街日记2.jpg)\n\n<center><font color=\"#ccc\"><em>《海街日记》--小家</em></font></center>\n日系风格的电影和照片总是给人一种治愈，温暖，简单的情绪，而这种来自于**真实和谐的照片内容结构+整体相似的色彩渲染的氛围**\n\n<h4 id=\"内容结构\"><a href=\"#内容结构\" class=\"headerlink\" title=\"内容结构\"></a>内容结构</h4><p>在以上的例子中有冷暖色调和高低色温,但他们的场景都有一个共通点——简单，不管是街景，樱花，树林还是院落都是我们生活中常见的景象，不需要特殊的构图，线条，力求真实，看起来就像是我们生活中不经意的瞬间</p>\n<h4 id=\"色彩\"><a href=\"#色彩\" class=\"headerlink\" title=\"色彩\"></a>色彩</h4><p>真实简单的场景仅能够有代入感但这远不足够，还需要色彩来调整照片的重点和加强氛围借此来表达出情绪,个人认为这一类清新的日系所追求的目标应该是照片所有内容共同构建出来的氛围，所以我们应当让整体和谐，削弱突出的细节，把看者注意力转移整体的情景中。在大部分情况下降低对比度都是一个必要的选择。</p>\n<h2 id=\"日系风格的取景\"><a href=\"#日系风格的取景\" class=\"headerlink\" title=\"日系风格的取景\"></a>日系风格的取景</h2><p>这一类的日系取景的整体思路,就是雨露均沾。在拍摄前最好在脑海中先构建出你需要拍摄的大概情景或者想要的效果，再根据效果和实际场景去取景。这部分除了丰富的想象力之外我觉着多看这一类的电(强推是枝裕和，总是在看似无趣的日常里面表达出轻微但是稠密且绵长的情感。非常nice~)或者多看类似的图片会好一些，画面主体内容上结构比例和谐即可但最好不要出现过于突出的主体.</p>\n<p>如果是有人像参与，最好让人像成为景中的一部分，穿着上也尽量素一些，太过花哨的着装会浪费多余的注意力，破坏整体的情境，着装的色调也最好和整体环境的色调贴近，不好选的话中性色调是个不错的选择。</p>\n<h2 id=\"日系风格的后期调色\"><a href=\"#日系风格的后期调色\" class=\"headerlink\" title=\"日系风格的后期调色\"></a>日系风格的后期调色</h2><p>原片完成之后，后期调色也是渲染氛围的重要一步，在整体色调上尽量以主体环境颜色以基准或者以你提前想好的效果为准(但是一定要偏色)，照片整体的色温贴近而色调需要取决于画面的主体和颜色的通透情况而定，在大多数情况下需要降低对比度，提高曝光。</p>\n<h2 id=\"样例\"><a href=\"#样例\" class=\"headerlink\" title=\"样例\"></a>样例</h2><p>下面也选了两张我自己拍摄的，第二章由于原片被我删了所以只讲一下我第一张的调色思路，以下是原图</p>\n<p><img src=\"/2020/04/09/%E6%97%A5%E7%B3%BB%E9%A3%8E%E6%A0%BC%E8%B0%83%E8%89%B2%E6%80%9D%E8%B7%AF/%E5%8E%9F%E5%9B%BE1.jpg\" alt></p>\n<p>这一张拍摄前我提前想好了想要一种夏日林间少女感觉，所以采用的是逆光手法+大光圈拍摄，当时拍摄的时间是四五点的公园树林里，照片主体偏黄，所以整体风格选都尽量靠近暖色上面靠近，且能观察到画面上除余阳光直射的部分外其他部分都偏暗。</p>\n<p>小清新类的日系照片通透性都非常好，而我们首先要做的就是让画面看起来干净，整体性强一些。先降低对比度增强整体性，其次增加曝光和亮度来进一步削弱带来的影响消除影响，增加通透性。</p>\n<p>画面干净之后我们需要做的就是调整色温和色调，制造偏色来营造我们想要的效果，已经说过我们主体选用的是暖色调，所以我们需要画面看起来干净温暖，调高色温降低色调让整体画面去贴近暖色，同时也要适当调整饱和度，让画面整体颜色结构合理。</p>\n<p>再后就是做一些微小的细节处理，增加阴影亮度，黑白色阶，高光，降低清晰度等等去贴近我们想要的效果。</p>\n<p><img src=\"/2020/04/09/%E6%97%A5%E7%B3%BB%E9%A3%8E%E6%A0%BC%E8%B0%83%E8%89%B2%E6%80%9D%E8%B7%AF/%E6%97%A5%E7%B3%BB2.jpg\" alt></p>\n<p>第二掌拍摄的时候并没有想好，只是拍摄第一张的过程中偶然拍摄的，所以整体效果是后期自己决定的，主题颜色是绿色，所以整体颜色也向中性偏冷靠近，这张拍摄的时候就很亮了，取景布局也很好，不需要改动结果只需要简单的增加绿色明度，纯度去增强画面主体(由于是近景所以画面整体性和谐就略等于主体+背景)，略微增加高光阴影，降低黑色色阶，增加背景和主体的对比。最后略微降低色温和色调，制造偏色即可。</p>\n<p><img src=\"/2020/04/09/%E6%97%A5%E7%B3%BB%E9%A3%8E%E6%A0%BC%E8%B0%83%E8%89%B2%E6%80%9D%E8%B7%AF/%E6%97%A5%E7%B3%BB3.jpg\" alt></p>"},{"title":"青春向左","date":"2019-11-03T12:37:23.000Z","_content":"\n## 青春向左\n\n<p align=\"right\"><font color=\"#ccc\" size=\"4\"><em>——记五月天上海演唱会和零碎的情绪</em></font></right>\n\n#### 一次久别重逢\n\n![](青春向左/演唱会.jpg)\n\n2019年11月1日 ，上海虹桥体育场。\n\n18：40\n\n演唱会七点开始,我坐在座位上一边听着告五人的热场一边和有事没来的朋友发着消息，时不时听到周围略显兴奋的谈论和打闹，大家都在共同的期待着什么。\n\n19：00\n\n吵闹中灯光突然暗了下来，两秒中的停顿之后，耳边响起了熟悉的音乐，大家都兴奋的叫了起来。看着期待中的身影渐渐出现，我心里突然有些复杂的情绪交错在一起，既有看到他们的兴奋，也有对演唱会的期待，还有一种难以言说的感慨，就像是久别的老友，大家经历着各自的人生，有着不同的际遇，但在一个阳光昏黄温暖的傍晚，在一个临街的咖啡厅里大家又坐在了一起，相视一笑\n\n嘿，你们...\n\n好久不见\n\n22：00\n\n随着最后的鞠躬和致谢，演唱会还是结束了，我站起身不紧不慢的走向出口，看着三三两两走过的身影想着他们中或千里迢迢或省吃俭用都只为了加入一场三四个小时的聚会，和周围的人一起，听着五月天的歌声然后回忆着各自的故事。临到出口的时候，我转过头再看了一眼舞台，想起阿信最后疲惫的样子和有些沙哑的声音，有些心疼\n\n原来\n\n五月天也二十岁了\n\n\n\n#### 五月天的故事\n\n![](青春向左/七号公园.jpg)\n\n**我们是！五月天**\n\n1997年，破蛋的五月天和二十岁的团员们像所有的年轻人一样，有无数多的困惑，迷茫和悲伤\n\n嘴上说着爱情万岁但歌词里面尽是一夜欢愉\n\n想要对你温柔但最后还是决定还你自由\n\n以为爱情纯真但怎么故事三个人\n\n也像所有的年轻人一样，哭完了丧完了再起来战斗，去干翻这个操蛋的世界\n\n不知道明天在哪未来何去，反正人生海海，潮落之后一定有潮起\n\n故事落尽孤独一人，就别埋头吃饭让我们一起终结孤单\n\n在世界尽头无人记得但感动永远在，再吃一颗苹果吧\n\n![](青春向左/人生海海.jpg)\n\n他们是五月天，也是五个不知所措，迷茫又满是憧憬的年轻人，如果能坐着时光机去二十岁的他们的话，我想，会得到和我们一样回答......\n\n未来怎样？\n\n不知道呢\n\n所以，然后呢？\n\n一起走吧\n\n**苍狗白云**\n\n2017年，这一年五月天二十岁了，团员们也年过四十。一年前出了第九章专辑——《自传》，听完专辑之后有人说五月天变了少了活力，青春和梦想，不如蓝三，你们的热血呢？不甘呢？奋斗呢？你们可是五月天啊！\n\n如果二十年前的五月天听到小九的时候可能也会是这种感觉吧，这张专辑里面充满了回忆，释然和告别。好像和我们记忆中的五月天背道而驰，他们变了吗？\n\n我想是的。但我很喜欢，因为一首歌曲一张专辑本就是他们自己人生的剪影和思绪的结晶，二十年了，他们经历过为梦想奔走的疲惫和迷茫，因为服役带来的离散和不安，获奖但是不被认可的苦涩和委屈，也有鸟巢的十万人演唱会，妻女家人的温馨，终于获得的最佳作词人。\n\n![](青春向左/自传.png)\n\n人生海海，白云苍狗，他们写了顽固，去感谢那个从不曾放弃的自己。写了转眼去安静释然的回忆过去，准备未来的离别。写了少年他的奇幻漂流描绘人心善恶。写了任意门和兄弟去回忆和感谢二十年一直陪伴的团员。也写了派对动物，人生有限公司对生活的喧闹和反抗。他们其实从不曾放弃朝气和梦想，只是多了对生活的温柔和释然。这是五月天的二十岁，团员们的四十岁，如果这也是我的四十岁，那很让我心向往之。\n\n这是他们的自传\n\n也是我们\n\n后青春期的诗\n\n#### 生活向右\n\n不知道为什么看完演唱会之后时常会多一些无端的情绪，会想起以前经历过的事，曾经并肩的人，那些遗憾和后悔，也会想到现在不安的生活，要到来的离别，一些迷茫和无助。或者是未来的计划，想要去的地方和可能遇见的人，淡淡的憧憬和希望。有时候觉得自己矫情，又有时候自己像个小老头，可能这就是二十岁的我们吧，绝望着迷茫着悲伤有彷徨，但也努力的快乐和憧憬。\n\n![](青春向左/logo.png)\n\n整理完所有东西之后，我走到阳台透了一口气。这个时候的小区一片漆黑，看着不远处街边昏黄的路灯，时不时驶过的汽车，还有耳边时不时传来的虫鸣和空气中的淡淡花香。突然有种淡淡的幸福感，我很喜欢这一刻，静谧，美好而永恒。过了一会，一阵凉风吹过。看看手表，凌晨一点了。我走回了房间，把思绪都一一封存起来。因为第二天，要开始了。\n\n青春向左\n\n但\n\n生活向右\n\n","source":"_posts/青春向左.md","raw":"---\ntitle: 青春向左\ndate: 2019-11-03 20:37:23\ntags:\n - 五月天\n - 生活\ncategories:\n - 随笔\n---\n\n## 青春向左\n\n<p align=\"right\"><font color=\"#ccc\" size=\"4\"><em>——记五月天上海演唱会和零碎的情绪</em></font></right>\n\n#### 一次久别重逢\n\n![](青春向左/演唱会.jpg)\n\n2019年11月1日 ，上海虹桥体育场。\n\n18：40\n\n演唱会七点开始,我坐在座位上一边听着告五人的热场一边和有事没来的朋友发着消息，时不时听到周围略显兴奋的谈论和打闹，大家都在共同的期待着什么。\n\n19：00\n\n吵闹中灯光突然暗了下来，两秒中的停顿之后，耳边响起了熟悉的音乐，大家都兴奋的叫了起来。看着期待中的身影渐渐出现，我心里突然有些复杂的情绪交错在一起，既有看到他们的兴奋，也有对演唱会的期待，还有一种难以言说的感慨，就像是久别的老友，大家经历着各自的人生，有着不同的际遇，但在一个阳光昏黄温暖的傍晚，在一个临街的咖啡厅里大家又坐在了一起，相视一笑\n\n嘿，你们...\n\n好久不见\n\n22：00\n\n随着最后的鞠躬和致谢，演唱会还是结束了，我站起身不紧不慢的走向出口，看着三三两两走过的身影想着他们中或千里迢迢或省吃俭用都只为了加入一场三四个小时的聚会，和周围的人一起，听着五月天的歌声然后回忆着各自的故事。临到出口的时候，我转过头再看了一眼舞台，想起阿信最后疲惫的样子和有些沙哑的声音，有些心疼\n\n原来\n\n五月天也二十岁了\n\n\n\n#### 五月天的故事\n\n![](青春向左/七号公园.jpg)\n\n**我们是！五月天**\n\n1997年，破蛋的五月天和二十岁的团员们像所有的年轻人一样，有无数多的困惑，迷茫和悲伤\n\n嘴上说着爱情万岁但歌词里面尽是一夜欢愉\n\n想要对你温柔但最后还是决定还你自由\n\n以为爱情纯真但怎么故事三个人\n\n也像所有的年轻人一样，哭完了丧完了再起来战斗，去干翻这个操蛋的世界\n\n不知道明天在哪未来何去，反正人生海海，潮落之后一定有潮起\n\n故事落尽孤独一人，就别埋头吃饭让我们一起终结孤单\n\n在世界尽头无人记得但感动永远在，再吃一颗苹果吧\n\n![](青春向左/人生海海.jpg)\n\n他们是五月天，也是五个不知所措，迷茫又满是憧憬的年轻人，如果能坐着时光机去二十岁的他们的话，我想，会得到和我们一样回答......\n\n未来怎样？\n\n不知道呢\n\n所以，然后呢？\n\n一起走吧\n\n**苍狗白云**\n\n2017年，这一年五月天二十岁了，团员们也年过四十。一年前出了第九章专辑——《自传》，听完专辑之后有人说五月天变了少了活力，青春和梦想，不如蓝三，你们的热血呢？不甘呢？奋斗呢？你们可是五月天啊！\n\n如果二十年前的五月天听到小九的时候可能也会是这种感觉吧，这张专辑里面充满了回忆，释然和告别。好像和我们记忆中的五月天背道而驰，他们变了吗？\n\n我想是的。但我很喜欢，因为一首歌曲一张专辑本就是他们自己人生的剪影和思绪的结晶，二十年了，他们经历过为梦想奔走的疲惫和迷茫，因为服役带来的离散和不安，获奖但是不被认可的苦涩和委屈，也有鸟巢的十万人演唱会，妻女家人的温馨，终于获得的最佳作词人。\n\n![](青春向左/自传.png)\n\n人生海海，白云苍狗，他们写了顽固，去感谢那个从不曾放弃的自己。写了转眼去安静释然的回忆过去，准备未来的离别。写了少年他的奇幻漂流描绘人心善恶。写了任意门和兄弟去回忆和感谢二十年一直陪伴的团员。也写了派对动物，人生有限公司对生活的喧闹和反抗。他们其实从不曾放弃朝气和梦想，只是多了对生活的温柔和释然。这是五月天的二十岁，团员们的四十岁，如果这也是我的四十岁，那很让我心向往之。\n\n这是他们的自传\n\n也是我们\n\n后青春期的诗\n\n#### 生活向右\n\n不知道为什么看完演唱会之后时常会多一些无端的情绪，会想起以前经历过的事，曾经并肩的人，那些遗憾和后悔，也会想到现在不安的生活，要到来的离别，一些迷茫和无助。或者是未来的计划，想要去的地方和可能遇见的人，淡淡的憧憬和希望。有时候觉得自己矫情，又有时候自己像个小老头，可能这就是二十岁的我们吧，绝望着迷茫着悲伤有彷徨，但也努力的快乐和憧憬。\n\n![](青春向左/logo.png)\n\n整理完所有东西之后，我走到阳台透了一口气。这个时候的小区一片漆黑，看着不远处街边昏黄的路灯，时不时驶过的汽车，还有耳边时不时传来的虫鸣和空气中的淡淡花香。突然有种淡淡的幸福感，我很喜欢这一刻，静谧，美好而永恒。过了一会，一阵凉风吹过。看看手表，凌晨一点了。我走回了房间，把思绪都一一封存起来。因为第二天，要开始了。\n\n青春向左\n\n但\n\n生活向右\n\n","slug":"青春向左","published":1,"updated":"2020-04-24T02:37:36.274Z","_id":"ck9cue22d00073gcs7moa3c9b","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"青春向左\"><a href=\"#青春向左\" class=\"headerlink\" title=\"青春向左\"></a>青春向左</h2><p align=\"right\"><font color=\"#ccc\" size=\"4\"><em>——记五月天上海演唱会和零碎的情绪</em></font>\n\n</p><h4 id=\"一次久别重逢\"><a href=\"#一次久别重逢\" class=\"headerlink\" title=\"一次久别重逢\"></a>一次久别重逢</h4><p><img src=\"/2019/11/03/%E9%9D%92%E6%98%A5%E5%90%91%E5%B7%A6/%E6%BC%94%E5%94%B1%E4%BC%9A.jpg\" alt></p>\n<p>2019年11月1日 ，上海虹桥体育场。</p>\n<p>18：40</p>\n<p>演唱会七点开始,我坐在座位上一边听着告五人的热场一边和有事没来的朋友发着消息，时不时听到周围略显兴奋的谈论和打闹，大家都在共同的期待着什么。</p>\n<p>19：00</p>\n<p>吵闹中灯光突然暗了下来，两秒中的停顿之后，耳边响起了熟悉的音乐，大家都兴奋的叫了起来。看着期待中的身影渐渐出现，我心里突然有些复杂的情绪交错在一起，既有看到他们的兴奋，也有对演唱会的期待，还有一种难以言说的感慨，就像是久别的老友，大家经历着各自的人生，有着不同的际遇，但在一个阳光昏黄温暖的傍晚，在一个临街的咖啡厅里大家又坐在了一起，相视一笑</p>\n<p>嘿，你们…</p>\n<p>好久不见</p>\n<p>22：00</p>\n<p>随着最后的鞠躬和致谢，演唱会还是结束了，我站起身不紧不慢的走向出口，看着三三两两走过的身影想着他们中或千里迢迢或省吃俭用都只为了加入一场三四个小时的聚会，和周围的人一起，听着五月天的歌声然后回忆着各自的故事。临到出口的时候，我转过头再看了一眼舞台，想起阿信最后疲惫的样子和有些沙哑的声音，有些心疼</p>\n<p>原来</p>\n<p>五月天也二十岁了</p>\n<h4 id=\"五月天的故事\"><a href=\"#五月天的故事\" class=\"headerlink\" title=\"五月天的故事\"></a>五月天的故事</h4><p><img src=\"/2019/11/03/%E9%9D%92%E6%98%A5%E5%90%91%E5%B7%A6/%E4%B8%83%E5%8F%B7%E5%85%AC%E5%9B%AD.jpg\" alt></p>\n<p><strong>我们是！五月天</strong></p>\n<p>1997年，破蛋的五月天和二十岁的团员们像所有的年轻人一样，有无数多的困惑，迷茫和悲伤</p>\n<p>嘴上说着爱情万岁但歌词里面尽是一夜欢愉</p>\n<p>想要对你温柔但最后还是决定还你自由</p>\n<p>以为爱情纯真但怎么故事三个人</p>\n<p>也像所有的年轻人一样，哭完了丧完了再起来战斗，去干翻这个操蛋的世界</p>\n<p>不知道明天在哪未来何去，反正人生海海，潮落之后一定有潮起</p>\n<p>故事落尽孤独一人，就别埋头吃饭让我们一起终结孤单</p>\n<p>在世界尽头无人记得但感动永远在，再吃一颗苹果吧</p>\n<p><img src=\"/2019/11/03/%E9%9D%92%E6%98%A5%E5%90%91%E5%B7%A6/%E4%BA%BA%E7%94%9F%E6%B5%B7%E6%B5%B7.jpg\" alt></p>\n<p>他们是五月天，也是五个不知所措，迷茫又满是憧憬的年轻人，如果能坐着时光机去二十岁的他们的话，我想，会得到和我们一样回答……</p>\n<p>未来怎样？</p>\n<p>不知道呢</p>\n<p>所以，然后呢？</p>\n<p>一起走吧</p>\n<p><strong>苍狗白云</strong></p>\n<p>2017年，这一年五月天二十岁了，团员们也年过四十。一年前出了第九章专辑——《自传》，听完专辑之后有人说五月天变了少了活力，青春和梦想，不如蓝三，你们的热血呢？不甘呢？奋斗呢？你们可是五月天啊！</p>\n<p>如果二十年前的五月天听到小九的时候可能也会是这种感觉吧，这张专辑里面充满了回忆，释然和告别。好像和我们记忆中的五月天背道而驰，他们变了吗？</p>\n<p>我想是的。但我很喜欢，因为一首歌曲一张专辑本就是他们自己人生的剪影和思绪的结晶，二十年了，他们经历过为梦想奔走的疲惫和迷茫，因为服役带来的离散和不安，获奖但是不被认可的苦涩和委屈，也有鸟巢的十万人演唱会，妻女家人的温馨，终于获得的最佳作词人。</p>\n<p><img src=\"/2019/11/03/%E9%9D%92%E6%98%A5%E5%90%91%E5%B7%A6/%E8%87%AA%E4%BC%A0.png\" alt></p>\n<p>人生海海，白云苍狗，他们写了顽固，去感谢那个从不曾放弃的自己。写了转眼去安静释然的回忆过去，准备未来的离别。写了少年他的奇幻漂流描绘人心善恶。写了任意门和兄弟去回忆和感谢二十年一直陪伴的团员。也写了派对动物，人生有限公司对生活的喧闹和反抗。他们其实从不曾放弃朝气和梦想，只是多了对生活的温柔和释然。这是五月天的二十岁，团员们的四十岁，如果这也是我的四十岁，那很让我心向往之。</p>\n<p>这是他们的自传</p>\n<p>也是我们</p>\n<p>后青春期的诗</p>\n<h4 id=\"生活向右\"><a href=\"#生活向右\" class=\"headerlink\" title=\"生活向右\"></a>生活向右</h4><p>不知道为什么看完演唱会之后时常会多一些无端的情绪，会想起以前经历过的事，曾经并肩的人，那些遗憾和后悔，也会想到现在不安的生活，要到来的离别，一些迷茫和无助。或者是未来的计划，想要去的地方和可能遇见的人，淡淡的憧憬和希望。有时候觉得自己矫情，又有时候自己像个小老头，可能这就是二十岁的我们吧，绝望着迷茫着悲伤有彷徨，但也努力的快乐和憧憬。</p>\n<p><img src=\"/2019/11/03/%E9%9D%92%E6%98%A5%E5%90%91%E5%B7%A6/logo.png\" alt></p>\n<p>整理完所有东西之后，我走到阳台透了一口气。这个时候的小区一片漆黑，看着不远处街边昏黄的路灯，时不时驶过的汽车，还有耳边时不时传来的虫鸣和空气中的淡淡花香。突然有种淡淡的幸福感，我很喜欢这一刻，静谧，美好而永恒。过了一会，一阵凉风吹过。看看手表，凌晨一点了。我走回了房间，把思绪都一一封存起来。因为第二天，要开始了。</p>\n<p>青春向左</p>\n<p>但</p>\n<p>生活向右</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"青春向左\"><a href=\"#青春向左\" class=\"headerlink\" title=\"青春向左\"></a>青春向左</h2><p align=\"right\"><font color=\"#ccc\" size=\"4\"><em>——记五月天上海演唱会和零碎的情绪</em></font>\n\n</p><h4 id=\"一次久别重逢\"><a href=\"#一次久别重逢\" class=\"headerlink\" title=\"一次久别重逢\"></a>一次久别重逢</h4><p><img src=\"/2019/11/03/%E9%9D%92%E6%98%A5%E5%90%91%E5%B7%A6/%E6%BC%94%E5%94%B1%E4%BC%9A.jpg\" alt></p>\n<p>2019年11月1日 ，上海虹桥体育场。</p>\n<p>18：40</p>\n<p>演唱会七点开始,我坐在座位上一边听着告五人的热场一边和有事没来的朋友发着消息，时不时听到周围略显兴奋的谈论和打闹，大家都在共同的期待着什么。</p>\n<p>19：00</p>\n<p>吵闹中灯光突然暗了下来，两秒中的停顿之后，耳边响起了熟悉的音乐，大家都兴奋的叫了起来。看着期待中的身影渐渐出现，我心里突然有些复杂的情绪交错在一起，既有看到他们的兴奋，也有对演唱会的期待，还有一种难以言说的感慨，就像是久别的老友，大家经历着各自的人生，有着不同的际遇，但在一个阳光昏黄温暖的傍晚，在一个临街的咖啡厅里大家又坐在了一起，相视一笑</p>\n<p>嘿，你们…</p>\n<p>好久不见</p>\n<p>22：00</p>\n<p>随着最后的鞠躬和致谢，演唱会还是结束了，我站起身不紧不慢的走向出口，看着三三两两走过的身影想着他们中或千里迢迢或省吃俭用都只为了加入一场三四个小时的聚会，和周围的人一起，听着五月天的歌声然后回忆着各自的故事。临到出口的时候，我转过头再看了一眼舞台，想起阿信最后疲惫的样子和有些沙哑的声音，有些心疼</p>\n<p>原来</p>\n<p>五月天也二十岁了</p>\n<h4 id=\"五月天的故事\"><a href=\"#五月天的故事\" class=\"headerlink\" title=\"五月天的故事\"></a>五月天的故事</h4><p><img src=\"/2019/11/03/%E9%9D%92%E6%98%A5%E5%90%91%E5%B7%A6/%E4%B8%83%E5%8F%B7%E5%85%AC%E5%9B%AD.jpg\" alt></p>\n<p><strong>我们是！五月天</strong></p>\n<p>1997年，破蛋的五月天和二十岁的团员们像所有的年轻人一样，有无数多的困惑，迷茫和悲伤</p>\n<p>嘴上说着爱情万岁但歌词里面尽是一夜欢愉</p>\n<p>想要对你温柔但最后还是决定还你自由</p>\n<p>以为爱情纯真但怎么故事三个人</p>\n<p>也像所有的年轻人一样，哭完了丧完了再起来战斗，去干翻这个操蛋的世界</p>\n<p>不知道明天在哪未来何去，反正人生海海，潮落之后一定有潮起</p>\n<p>故事落尽孤独一人，就别埋头吃饭让我们一起终结孤单</p>\n<p>在世界尽头无人记得但感动永远在，再吃一颗苹果吧</p>\n<p><img src=\"/2019/11/03/%E9%9D%92%E6%98%A5%E5%90%91%E5%B7%A6/%E4%BA%BA%E7%94%9F%E6%B5%B7%E6%B5%B7.jpg\" alt></p>\n<p>他们是五月天，也是五个不知所措，迷茫又满是憧憬的年轻人，如果能坐着时光机去二十岁的他们的话，我想，会得到和我们一样回答……</p>\n<p>未来怎样？</p>\n<p>不知道呢</p>\n<p>所以，然后呢？</p>\n<p>一起走吧</p>\n<p><strong>苍狗白云</strong></p>\n<p>2017年，这一年五月天二十岁了，团员们也年过四十。一年前出了第九章专辑——《自传》，听完专辑之后有人说五月天变了少了活力，青春和梦想，不如蓝三，你们的热血呢？不甘呢？奋斗呢？你们可是五月天啊！</p>\n<p>如果二十年前的五月天听到小九的时候可能也会是这种感觉吧，这张专辑里面充满了回忆，释然和告别。好像和我们记忆中的五月天背道而驰，他们变了吗？</p>\n<p>我想是的。但我很喜欢，因为一首歌曲一张专辑本就是他们自己人生的剪影和思绪的结晶，二十年了，他们经历过为梦想奔走的疲惫和迷茫，因为服役带来的离散和不安，获奖但是不被认可的苦涩和委屈，也有鸟巢的十万人演唱会，妻女家人的温馨，终于获得的最佳作词人。</p>\n<p><img src=\"/2019/11/03/%E9%9D%92%E6%98%A5%E5%90%91%E5%B7%A6/%E8%87%AA%E4%BC%A0.png\" alt></p>\n<p>人生海海，白云苍狗，他们写了顽固，去感谢那个从不曾放弃的自己。写了转眼去安静释然的回忆过去，准备未来的离别。写了少年他的奇幻漂流描绘人心善恶。写了任意门和兄弟去回忆和感谢二十年一直陪伴的团员。也写了派对动物，人生有限公司对生活的喧闹和反抗。他们其实从不曾放弃朝气和梦想，只是多了对生活的温柔和释然。这是五月天的二十岁，团员们的四十岁，如果这也是我的四十岁，那很让我心向往之。</p>\n<p>这是他们的自传</p>\n<p>也是我们</p>\n<p>后青春期的诗</p>\n<h4 id=\"生活向右\"><a href=\"#生活向右\" class=\"headerlink\" title=\"生活向右\"></a>生活向右</h4><p>不知道为什么看完演唱会之后时常会多一些无端的情绪，会想起以前经历过的事，曾经并肩的人，那些遗憾和后悔，也会想到现在不安的生活，要到来的离别，一些迷茫和无助。或者是未来的计划，想要去的地方和可能遇见的人，淡淡的憧憬和希望。有时候觉得自己矫情，又有时候自己像个小老头，可能这就是二十岁的我们吧，绝望着迷茫着悲伤有彷徨，但也努力的快乐和憧憬。</p>\n<p><img src=\"/2019/11/03/%E9%9D%92%E6%98%A5%E5%90%91%E5%B7%A6/logo.png\" alt></p>\n<p>整理完所有东西之后，我走到阳台透了一口气。这个时候的小区一片漆黑，看着不远处街边昏黄的路灯，时不时驶过的汽车，还有耳边时不时传来的虫鸣和空气中的淡淡花香。突然有种淡淡的幸福感，我很喜欢这一刻，静谧，美好而永恒。过了一会，一阵凉风吹过。看看手表，凌晨一点了。我走回了房间，把思绪都一一封存起来。因为第二天，要开始了。</p>\n<p>青春向左</p>\n<p>但</p>\n<p>生活向右</p>\n"},{"title":"Hello Ships","date":"2019-10-06T14:45:18.000Z","_content":"\n# Hello Ships\n\n折腾了两天，终于把这个博客搭起来了，感谢过程中给我帮助的文字和人儿们\n\n\n\n第一次输入完localhost:4000看到生成的页面，突然有种很复杂的恍惚，就像是在海上常年冲浪的人找到了一个小岛，然后得到了一个海螺\n\n至此,\n\n这个海边独居的人可以把自己的思绪写成旋律\n\n吹进海螺里  \n\n偶尔有路过的航船听到\n\n鸣笛致意\n\n大家相视一笑\n\n挥挥手 \n\n然后各自离开\n\n奔赴下一场相遇\n\n我很喜欢这种感觉\n\n\n\nHello Ships~","source":"_posts/HelloShips.md","raw":"---\ntitle: Hello Ships\ndate: 2019-10-06 22:45:18\ntags:\n\t- 杂谈\n\t- Hello Ships\ncategories:\n\t- 随笔\n---\n\n# Hello Ships\n\n折腾了两天，终于把这个博客搭起来了，感谢过程中给我帮助的文字和人儿们\n\n\n\n第一次输入完localhost:4000看到生成的页面，突然有种很复杂的恍惚，就像是在海上常年冲浪的人找到了一个小岛，然后得到了一个海螺\n\n至此,\n\n这个海边独居的人可以把自己的思绪写成旋律\n\n吹进海螺里  \n\n偶尔有路过的航船听到\n\n鸣笛致意\n\n大家相视一笑\n\n挥挥手 \n\n然后各自离开\n\n奔赴下一场相遇\n\n我很喜欢这种感觉\n\n\n\nHello Ships~","slug":"HelloShips","published":1,"updated":"2020-04-20T07:58:27.717Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9cue22g00083gcsanjocchj","content":"<h1 id=\"Hello-Ships\"><a href=\"#Hello-Ships\" class=\"headerlink\" title=\"Hello Ships\"></a>Hello Ships</h1><p>折腾了两天，终于把这个博客搭起来了，感谢过程中给我帮助的文字和人儿们</p>\n<p>第一次输入完localhost:4000看到生成的页面，突然有种很复杂的恍惚，就像是在海上常年冲浪的人找到了一个小岛，然后得到了一个海螺</p>\n<p>至此,</p>\n<p>这个海边独居的人可以把自己的思绪写成旋律</p>\n<p>吹进海螺里  </p>\n<p>偶尔有路过的航船听到</p>\n<p>鸣笛致意</p>\n<p>大家相视一笑</p>\n<p>挥挥手 </p>\n<p>然后各自离开</p>\n<p>奔赴下一场相遇</p>\n<p>我很喜欢这种感觉</p>\n<p>Hello Ships~</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Hello-Ships\"><a href=\"#Hello-Ships\" class=\"headerlink\" title=\"Hello Ships\"></a>Hello Ships</h1><p>折腾了两天，终于把这个博客搭起来了，感谢过程中给我帮助的文字和人儿们</p>\n<p>第一次输入完localhost:4000看到生成的页面，突然有种很复杂的恍惚，就像是在海上常年冲浪的人找到了一个小岛，然后得到了一个海螺</p>\n<p>至此,</p>\n<p>这个海边独居的人可以把自己的思绪写成旋律</p>\n<p>吹进海螺里  </p>\n<p>偶尔有路过的航船听到</p>\n<p>鸣笛致意</p>\n<p>大家相视一笑</p>\n<p>挥挥手 </p>\n<p>然后各自离开</p>\n<p>奔赴下一场相遇</p>\n<p>我很喜欢这种感觉</p>\n<p>Hello Ships~</p>\n"},{"title":"ES6语法总结(三)","date":"2020-01-05T10:54:12.000Z","_content":"\n\n\n# ES6语法总结\n\n## 解构\n\n### 作用:\n\n从对象或数组中获取信息、并将特定数据存入本地变量\n\n### 对象解构：\n\n- **简单的解构**:先从一段代码说起\n\n  ```javascript\n  let man = {\n  age: \"23\",\n  name: \"zhoushuang\"\n  },\n  age: \"24\",\n  name = \"zs\";\n  // 使用解构来分配不同的值\n  ({ age, name } = man);//解构表达式\n  console.log(age); // \"23\"\n  console.log(name); // \"zhoushuang\"\n  ```\n<!--more-->\n  在这个例子中 age与 name 属性在声明时被初始化，而两个同名变量也被声明并初始化为不同的值。接下来一行使用了解构表达式，通过读取 man对象来更改这两个变量的值。在这里必须用**圆括号包裹解构赋值语句**，这是因为暴露的花括号会被解析为代码块语句，而块语句不允许在赋值操作符左侧出现。圆括号标示了里面的花括号并不是块语句、而应该被解释为表达式，从而允许完成赋值操作。\t\t\t\t\n\n- **设置默认值**:同上代码中的赋值语句改成\n\n  ```javascript\n  ({ age, name,type:'handsome' } = man);//解构表达式+默认值\n  ```\n\n  在赋值的时候由于man对象中并没有名为type的属性所以会使用默认值同时要注意的是凡是在解构赋值在声明构造器中查找不到同名属性时都会变成undefined\n\n- **赋值给本地变量名**：依旧是第一段代码的赋值语句改成\n\n  ```javascript\n  let { age: manage, name: manname='zs' } = man;//解构表达式+默认值+赋值给本地变量\n  ```\n\n  这样的话man里面的age和name属性分别对自定义的manage,manname进行了赋值操作， 该语法实际上与传统对象字面量语法相反，传统语法将名称放在冒号左边、值放在冒号右边；而在本例中，**名称在右边，需要进行值读取的位置被放在了左边。**\n\n- **解构嵌套对象**:\n\n  - **简单用法**：在日常开发中有时候会出现我们拿到的数据是一个多层嵌套的对象，而我们只需要获取其中的某些项的情况，这时自己写方法去遍历对象会比较麻烦，这个时候使用解构赋值会节省很多时间:\n\n  ```javascript\n  let man = {\n  name: \"zhoushuang\",\n  type: {\n  habit: {\n  sleep: true,\n  eating: true\n  },\n  \n  }\n  };\n  let { type: { habit }} = man;//嵌套解构赋值\n  console.log(habit.sleep); // true\n  console.log(habit.eating); // true\n  ```\n  在赋值结构中每当有一个冒号出现，就意味着冒号之前的标识符代表需要检查的位置，而冒号右侧则是赋值的目标。当冒号右侧存在花括号时，表示目标被嵌套在对象的更深一层中，因此`{ type: { habit }} = man`的运行顺序应该是:man->寻找type属性-> type属性需找habit属性->进行操作，每一个{}都可以简单的理解成又进行了一次简单解构赋值而这次的数据源就来自于冒号左边\n\n  - 赋值给本地变量名**:同上一行代码中的赋值语句改成\n\n    ```javascript\n    let { type: { habit:manHabit }} = man;//嵌套解构赋值+赋值给本地变量\n    ```\n\n    其实和简单赋值的形式一样把habit整个对象都赋值给了本地变量manHabit不赘述\n\n### 数组解构\n\n总体来说数组解构赋值和对象解构赋值非常的相似，因此在此也只介绍数组解构的不同之处,其他情况参考上文。\n\n- **简单解构赋值**:与对象相比语法不同’{}‘->'[]‘，并且在运行的时候不是查找同名属性而是直接按照参数的顺序进行赋值\n\n  ```javascript\n  let colors = [ \"red\", \"green\", \"blue\" ];\n  let [ first, second ] = colors;\n  console.log(first); // \"red\"\n  console.log(second); // \"green\"\n  \n  ```\n\n  在以上代码中能看到first和second分别获取了colors数组中的第一和第二个而这是根据参数各自的位置决定的，所以我们也可以使用占位符`，`来给获取指定的数据\n\n  ```javascript\n  let [,second ] = colors;\n  console.log(second); // \"green\"\n  ```\n\n  \n\n- 默认值:\n\n  ```java\n  let [ first, second= \"pink\" ] = colors;\n  ```\n\n- 参数交换:在ES6中可以运用解构赋值进行参数交换而无需中间变量\n\n  ```javascript\n  let a = 1,\n  b = 2;\n  [ a, b ] = [ b, a ];\n  console.log(a); // 2\n  console.log(b); // 1\n  ```\n\n- 嵌套解构:\n\n  ```javascript\n  let colors = [ \"red\", [ \"green\", \"lightgreen\" ], \"blue\" ];\n  // 随后\n  let [ firstColor, [ secondColor ] ] = colors;\n  console.log(firstColor); // \"red\"\n  console.log(secondColor); // \"green\"\n  ```\n\n  和对象嵌套时的原理一样,只不过在数组中不是根据属性名来查找而是根据参数的位置查找的,所以` [ firstColor, [ secondColor ] ] = colors;`也相当于进行了两次解构赋值操作,第一次`firstColor=red；[ secondColor ]= [ \"green\", \"lightgreen\" ]` ，第二次`secondColor =green`\n\n需要注意的是在数组解构的时候如果有嵌套解构的情况但是对应的数据源只要不是可转成数组的值都会报错，如果可以转成数组会先将其转化成数组在进行赋值:\n\n![](ES6语法总结三(解构、Set和Map)/数组解构赋值.png)\n\n- 剩余项赋值:因为数组中有arguments对象所以在数组解构中也可以使用\n\n  ```javascript\n  let colors = [ \"red\", \"green\", \"blue\" ];\n  let [ firstColor, ...restColors ] = colors;\n  console.log(firstColor); // \"red\"\n  console.log(restColors.length); // 2\n  console.log(restColors[0]); // \"green\"\n  console.log(restColors[1]); // \"blue\"\n  ```\n\n## 混合解构(对象+数组)\n\n这里其实就是把数组解构和对象解构的语法组合起来，只要注意逻辑和语法就行了，混合结构对于JSON格式的数据获取很有帮助\n\n```javascript\nlet node = {\ntype: \"Identifier\",\nname: \"foo\",\nloc: {\nstart: {\nline: 1,\ncolumn: 1\n},\nend: {\nline: 1,\ncolumn: 4\n}\n},\nrange: [0, 3]\n};\nlet {\nloc: { start },\nrange: [ startIndex ]\n} = node;\nconsole.log(start.line); // 1\nconsole.log(start.column); // 1\nconsole.log(startIndex); // 0\n```\n\n## Set和Map\n\n### Set(无重复值的有序列表)\n\n- **创建set并添加内容**：\n\n  使用new来创建，add方法添加项目\n\n  ```javascript\n  let set = new Set();\n  set.add(5);\n  set.add(\"5\");\n  console.log(set.size); // 2\n  ```\n\n  Set 不会使用强制类型转换来判断值是否重复。这意味着 Set 可以同时包含数值 5 与 字符串 \"5\" ，将它们都作为相对独立的项,因为这里使用的是Object.is() 方法，来判断两个值是否相等，唯一的例外是 +0 与 -0 在 Set 中被判断为是相等的）。你还可以向 Set 添加多个对象，它们也不会被合并为同一项\n\n- **Set.has()**：用来搜索目标set中是否存在某一项，并返回结果(true/false)\n\n- **Set.delete()**:用来删除目标set中的某一项，并返回结果(true/false)\n\n- **Set.clear()**:用来删除目标set中的某一项，无返回\n\n- **Set 转换为数组**：将数组转换为 Set 相当容易，因为可以将数组传递给 Set 构造器；而使用扩展运算符也能简\n  单地将 Set 转换回数组\n\n  ```javascript\n  let set = new Set([1, 2, 3, 3, 3, 4, 5]),\n  array = [...set];\n  console.log(array); // [1,2,3,4,5]\n  ```\n\n- Weak Set：\n\n  在以上转化数组的时候仔细观察就能发现，使用set转换数组时只是将set中的内容复制给了一个array而已，原set的内容中依旧还存在，对象存储在 Set 的一个实例中时，实际上相当于把对象存储在变量中。只要对于 Set 实例的引用仍然存在，所存储的对象就无法被垃圾回收机制回收，从而无法释放内存，所以为了解决这个问题也就引入了Weak Set\n\n  - 创建 Weak Set:\n\n    ```javascript\n    let set = new WeakSet(),\n    key = {};\n    // 将对象加入 set\n    set.add(key);\n    console.log(set.has(key)); // true\n    set.delete(key);\n    console.log(set.has(key)); // false\n    ```\n\n    Weak Set 使用 WeakSet 构造器来创建，同时也包含了 add() 、 has()和 delete(),没有clear，该类型只允许存储对象弱引用，而不能存储基本类型的值。对象的弱引用在它自己成为该对象的唯一引用时，不会阻止垃圾回收，\n\n  - Set 类型之间的关键差异：\n\n    - 对于 WeakSet 的实例，若调用 add() 方法时传入了非对象的参数，就会抛出错误（has() 或 delete() 则会在传入了非对象的参数时返回 false ）；\n    2. Weak Set 不可迭代，因此不能被用在 for-of 循环中；\n    - Weak Set 无法暴露出任何迭代器（例如 keys() 与 values() 方法），因此没有任何编程手段可用于判断 Weak Set 的内容；\n    4. Weak Set 没有 forEach() 方法；\n    5. Weak Set 没有 size 属性。\n\n### Map(键值对有序列表)\n\nMap中的数据以键值对的形式存在,而键和值都可以是任意类型。键的比较使用的是Object.is() ，因此你能将 5 与 \"5\" 同时作为键，因为它们类型不同。这与使用对象属性作为键的方式（指的是用对象来模拟 Map ）截然不同，因为对象的属性会被强制转换为字符串。\n\n- **Map方法**：\n  - get(),set():调用 set() 方法并给它传递一个键与一个关联的值，来给 Map 添加项；此后使用键\n    名来调用 get() 方法便能提取对应的值\n  - has(key) ：判断指定的键是否存在于 Map 中；\n  - delete(key) ：移除 Map 中的键以及对应的值；\n  - clear() ：移除 Map 中所有的键与值。\n\n- **Weak Map**:\n\n  WeakMap 类型是键值对的无序列表，其中键必须是非空的对象，值则允许是任意类型。 WeakMap 的接口与 Map 的非常相似，都使用 set() 与 get() 方法来分别添加与提取数据\n\n  - **Weak Map 的初始化**\n    为了初始化 Weak Map ，需要把一个由数组构成的数组传递给 WeakMap 构造器。就像正规Map 构造器那样，每个内部数组都应当有两个项，第一项是作为键的非空的对象，第二项则是对应的值（任意类型）\n\n  ```javascript\n  let key1 = {},\n  key2 = {},\n  map = new WeakMap([[key1, \"Hello\"], [key2, 42]]);\n  console.log(map.has(key1)); // true\n  console.log(map.get(key1)); // \"Hello\"\n  console.log(map.has(key2)); // true\n  console.log(map.get(key2)); // 42\n  ```\n  - Weak Map 的方法\n\n    has() 方法用于判断指定的键是否存在 delete() 方法则用于移除一个特定的键值对。\n\n- Weak Map 的用法与局限性\n\n  如果你只想使用对象类型的键。最好的选择就是 Weak Map 。因为它能确保额外数据在不再可用后被销毁，从而能优化内存使用并规避内存泄漏。但是 Weak Map 只为它们的内容提供了很小的可见度，因此不能使用 forEach() 方法、size 属性或 clear() 方法来管理其中的项。而在除此之外的其他情况，正常 Map是更好的选择，只是要注意对内存的使用。\n\n","source":"_posts/ES6语法总结三(解构、Set和Map).md","raw":"---\ntitle: ES6语法总结(三)\ndate: 2020-01-05 18:54:12\ntags:\n\t- 前端\n\t- ES6\ncategories:\n\t- web前端\n\t\n---\n\n\n\n# ES6语法总结\n\n## 解构\n\n### 作用:\n\n从对象或数组中获取信息、并将特定数据存入本地变量\n\n### 对象解构：\n\n- **简单的解构**:先从一段代码说起\n\n  ```javascript\n  let man = {\n  age: \"23\",\n  name: \"zhoushuang\"\n  },\n  age: \"24\",\n  name = \"zs\";\n  // 使用解构来分配不同的值\n  ({ age, name } = man);//解构表达式\n  console.log(age); // \"23\"\n  console.log(name); // \"zhoushuang\"\n  ```\n<!--more-->\n  在这个例子中 age与 name 属性在声明时被初始化，而两个同名变量也被声明并初始化为不同的值。接下来一行使用了解构表达式，通过读取 man对象来更改这两个变量的值。在这里必须用**圆括号包裹解构赋值语句**，这是因为暴露的花括号会被解析为代码块语句，而块语句不允许在赋值操作符左侧出现。圆括号标示了里面的花括号并不是块语句、而应该被解释为表达式，从而允许完成赋值操作。\t\t\t\t\n\n- **设置默认值**:同上代码中的赋值语句改成\n\n  ```javascript\n  ({ age, name,type:'handsome' } = man);//解构表达式+默认值\n  ```\n\n  在赋值的时候由于man对象中并没有名为type的属性所以会使用默认值同时要注意的是凡是在解构赋值在声明构造器中查找不到同名属性时都会变成undefined\n\n- **赋值给本地变量名**：依旧是第一段代码的赋值语句改成\n\n  ```javascript\n  let { age: manage, name: manname='zs' } = man;//解构表达式+默认值+赋值给本地变量\n  ```\n\n  这样的话man里面的age和name属性分别对自定义的manage,manname进行了赋值操作， 该语法实际上与传统对象字面量语法相反，传统语法将名称放在冒号左边、值放在冒号右边；而在本例中，**名称在右边，需要进行值读取的位置被放在了左边。**\n\n- **解构嵌套对象**:\n\n  - **简单用法**：在日常开发中有时候会出现我们拿到的数据是一个多层嵌套的对象，而我们只需要获取其中的某些项的情况，这时自己写方法去遍历对象会比较麻烦，这个时候使用解构赋值会节省很多时间:\n\n  ```javascript\n  let man = {\n  name: \"zhoushuang\",\n  type: {\n  habit: {\n  sleep: true,\n  eating: true\n  },\n  \n  }\n  };\n  let { type: { habit }} = man;//嵌套解构赋值\n  console.log(habit.sleep); // true\n  console.log(habit.eating); // true\n  ```\n  在赋值结构中每当有一个冒号出现，就意味着冒号之前的标识符代表需要检查的位置，而冒号右侧则是赋值的目标。当冒号右侧存在花括号时，表示目标被嵌套在对象的更深一层中，因此`{ type: { habit }} = man`的运行顺序应该是:man->寻找type属性-> type属性需找habit属性->进行操作，每一个{}都可以简单的理解成又进行了一次简单解构赋值而这次的数据源就来自于冒号左边\n\n  - 赋值给本地变量名**:同上一行代码中的赋值语句改成\n\n    ```javascript\n    let { type: { habit:manHabit }} = man;//嵌套解构赋值+赋值给本地变量\n    ```\n\n    其实和简单赋值的形式一样把habit整个对象都赋值给了本地变量manHabit不赘述\n\n### 数组解构\n\n总体来说数组解构赋值和对象解构赋值非常的相似，因此在此也只介绍数组解构的不同之处,其他情况参考上文。\n\n- **简单解构赋值**:与对象相比语法不同’{}‘->'[]‘，并且在运行的时候不是查找同名属性而是直接按照参数的顺序进行赋值\n\n  ```javascript\n  let colors = [ \"red\", \"green\", \"blue\" ];\n  let [ first, second ] = colors;\n  console.log(first); // \"red\"\n  console.log(second); // \"green\"\n  \n  ```\n\n  在以上代码中能看到first和second分别获取了colors数组中的第一和第二个而这是根据参数各自的位置决定的，所以我们也可以使用占位符`，`来给获取指定的数据\n\n  ```javascript\n  let [,second ] = colors;\n  console.log(second); // \"green\"\n  ```\n\n  \n\n- 默认值:\n\n  ```java\n  let [ first, second= \"pink\" ] = colors;\n  ```\n\n- 参数交换:在ES6中可以运用解构赋值进行参数交换而无需中间变量\n\n  ```javascript\n  let a = 1,\n  b = 2;\n  [ a, b ] = [ b, a ];\n  console.log(a); // 2\n  console.log(b); // 1\n  ```\n\n- 嵌套解构:\n\n  ```javascript\n  let colors = [ \"red\", [ \"green\", \"lightgreen\" ], \"blue\" ];\n  // 随后\n  let [ firstColor, [ secondColor ] ] = colors;\n  console.log(firstColor); // \"red\"\n  console.log(secondColor); // \"green\"\n  ```\n\n  和对象嵌套时的原理一样,只不过在数组中不是根据属性名来查找而是根据参数的位置查找的,所以` [ firstColor, [ secondColor ] ] = colors;`也相当于进行了两次解构赋值操作,第一次`firstColor=red；[ secondColor ]= [ \"green\", \"lightgreen\" ]` ，第二次`secondColor =green`\n\n需要注意的是在数组解构的时候如果有嵌套解构的情况但是对应的数据源只要不是可转成数组的值都会报错，如果可以转成数组会先将其转化成数组在进行赋值:\n\n![](ES6语法总结三(解构、Set和Map)/数组解构赋值.png)\n\n- 剩余项赋值:因为数组中有arguments对象所以在数组解构中也可以使用\n\n  ```javascript\n  let colors = [ \"red\", \"green\", \"blue\" ];\n  let [ firstColor, ...restColors ] = colors;\n  console.log(firstColor); // \"red\"\n  console.log(restColors.length); // 2\n  console.log(restColors[0]); // \"green\"\n  console.log(restColors[1]); // \"blue\"\n  ```\n\n## 混合解构(对象+数组)\n\n这里其实就是把数组解构和对象解构的语法组合起来，只要注意逻辑和语法就行了，混合结构对于JSON格式的数据获取很有帮助\n\n```javascript\nlet node = {\ntype: \"Identifier\",\nname: \"foo\",\nloc: {\nstart: {\nline: 1,\ncolumn: 1\n},\nend: {\nline: 1,\ncolumn: 4\n}\n},\nrange: [0, 3]\n};\nlet {\nloc: { start },\nrange: [ startIndex ]\n} = node;\nconsole.log(start.line); // 1\nconsole.log(start.column); // 1\nconsole.log(startIndex); // 0\n```\n\n## Set和Map\n\n### Set(无重复值的有序列表)\n\n- **创建set并添加内容**：\n\n  使用new来创建，add方法添加项目\n\n  ```javascript\n  let set = new Set();\n  set.add(5);\n  set.add(\"5\");\n  console.log(set.size); // 2\n  ```\n\n  Set 不会使用强制类型转换来判断值是否重复。这意味着 Set 可以同时包含数值 5 与 字符串 \"5\" ，将它们都作为相对独立的项,因为这里使用的是Object.is() 方法，来判断两个值是否相等，唯一的例外是 +0 与 -0 在 Set 中被判断为是相等的）。你还可以向 Set 添加多个对象，它们也不会被合并为同一项\n\n- **Set.has()**：用来搜索目标set中是否存在某一项，并返回结果(true/false)\n\n- **Set.delete()**:用来删除目标set中的某一项，并返回结果(true/false)\n\n- **Set.clear()**:用来删除目标set中的某一项，无返回\n\n- **Set 转换为数组**：将数组转换为 Set 相当容易，因为可以将数组传递给 Set 构造器；而使用扩展运算符也能简\n  单地将 Set 转换回数组\n\n  ```javascript\n  let set = new Set([1, 2, 3, 3, 3, 4, 5]),\n  array = [...set];\n  console.log(array); // [1,2,3,4,5]\n  ```\n\n- Weak Set：\n\n  在以上转化数组的时候仔细观察就能发现，使用set转换数组时只是将set中的内容复制给了一个array而已，原set的内容中依旧还存在，对象存储在 Set 的一个实例中时，实际上相当于把对象存储在变量中。只要对于 Set 实例的引用仍然存在，所存储的对象就无法被垃圾回收机制回收，从而无法释放内存，所以为了解决这个问题也就引入了Weak Set\n\n  - 创建 Weak Set:\n\n    ```javascript\n    let set = new WeakSet(),\n    key = {};\n    // 将对象加入 set\n    set.add(key);\n    console.log(set.has(key)); // true\n    set.delete(key);\n    console.log(set.has(key)); // false\n    ```\n\n    Weak Set 使用 WeakSet 构造器来创建，同时也包含了 add() 、 has()和 delete(),没有clear，该类型只允许存储对象弱引用，而不能存储基本类型的值。对象的弱引用在它自己成为该对象的唯一引用时，不会阻止垃圾回收，\n\n  - Set 类型之间的关键差异：\n\n    - 对于 WeakSet 的实例，若调用 add() 方法时传入了非对象的参数，就会抛出错误（has() 或 delete() 则会在传入了非对象的参数时返回 false ）；\n    2. Weak Set 不可迭代，因此不能被用在 for-of 循环中；\n    - Weak Set 无法暴露出任何迭代器（例如 keys() 与 values() 方法），因此没有任何编程手段可用于判断 Weak Set 的内容；\n    4. Weak Set 没有 forEach() 方法；\n    5. Weak Set 没有 size 属性。\n\n### Map(键值对有序列表)\n\nMap中的数据以键值对的形式存在,而键和值都可以是任意类型。键的比较使用的是Object.is() ，因此你能将 5 与 \"5\" 同时作为键，因为它们类型不同。这与使用对象属性作为键的方式（指的是用对象来模拟 Map ）截然不同，因为对象的属性会被强制转换为字符串。\n\n- **Map方法**：\n  - get(),set():调用 set() 方法并给它传递一个键与一个关联的值，来给 Map 添加项；此后使用键\n    名来调用 get() 方法便能提取对应的值\n  - has(key) ：判断指定的键是否存在于 Map 中；\n  - delete(key) ：移除 Map 中的键以及对应的值；\n  - clear() ：移除 Map 中所有的键与值。\n\n- **Weak Map**:\n\n  WeakMap 类型是键值对的无序列表，其中键必须是非空的对象，值则允许是任意类型。 WeakMap 的接口与 Map 的非常相似，都使用 set() 与 get() 方法来分别添加与提取数据\n\n  - **Weak Map 的初始化**\n    为了初始化 Weak Map ，需要把一个由数组构成的数组传递给 WeakMap 构造器。就像正规Map 构造器那样，每个内部数组都应当有两个项，第一项是作为键的非空的对象，第二项则是对应的值（任意类型）\n\n  ```javascript\n  let key1 = {},\n  key2 = {},\n  map = new WeakMap([[key1, \"Hello\"], [key2, 42]]);\n  console.log(map.has(key1)); // true\n  console.log(map.get(key1)); // \"Hello\"\n  console.log(map.has(key2)); // true\n  console.log(map.get(key2)); // 42\n  ```\n  - Weak Map 的方法\n\n    has() 方法用于判断指定的键是否存在 delete() 方法则用于移除一个特定的键值对。\n\n- Weak Map 的用法与局限性\n\n  如果你只想使用对象类型的键。最好的选择就是 Weak Map 。因为它能确保额外数据在不再可用后被销毁，从而能优化内存使用并规避内存泄漏。但是 Weak Map 只为它们的内容提供了很小的可见度，因此不能使用 forEach() 方法、size 属性或 clear() 方法来管理其中的项。而在除此之外的其他情况，正常 Map是更好的选择，只是要注意对内存的使用。\n\n","slug":"ES6语法总结三(解构、Set和Map)","published":1,"updated":"2020-04-22T03:44:20.879Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9cue22w00153gcs3j4d0tda","content":"<h1 id=\"ES6语法总结\"><a href=\"#ES6语法总结\" class=\"headerlink\" title=\"ES6语法总结\"></a>ES6语法总结</h1><h2 id=\"解构\"><a href=\"#解构\" class=\"headerlink\" title=\"解构\"></a>解构</h2><h3 id=\"作用\"><a href=\"#作用\" class=\"headerlink\" title=\"作用:\"></a>作用:</h3><p>从对象或数组中获取信息、并将特定数据存入本地变量</p>\n<h3 id=\"对象解构：\"><a href=\"#对象解构：\" class=\"headerlink\" title=\"对象解构：\"></a>对象解构：</h3><ul>\n<li><p><strong>简单的解构</strong>:先从一段代码说起</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> man = &#123;</span><br><span class=\"line\">age: <span class=\"string\">\"23\"</span>,</span><br><span class=\"line\">name: <span class=\"string\">\"zhoushuang\"</span></span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">age: <span class=\"string\">\"24\"</span>,</span><br><span class=\"line\">name = <span class=\"string\">\"zs\"</span>;</span><br><span class=\"line\"><span class=\"comment\">// 使用解构来分配不同的值</span></span><br><span class=\"line\">(&#123; age, name &#125; = man);<span class=\"comment\">//解构表达式</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(age); <span class=\"comment\">// \"23\"</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(name); <span class=\"comment\">// \"zhoushuang\"</span></span><br></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<p>在这个例子中 age与 name 属性在声明时被初始化，而两个同名变量也被声明并初始化为不同的值。接下来一行使用了解构表达式，通过读取 man对象来更改这两个变量的值。在这里必须用<strong>圆括号包裹解构赋值语句</strong>，这是因为暴露的花括号会被解析为代码块语句，而块语句不允许在赋值操作符左侧出现。圆括号标示了里面的花括号并不是块语句、而应该被解释为表达式，从而允许完成赋值操作。                </p>\n</li>\n<li><p><strong>设置默认值</strong>:同上代码中的赋值语句改成</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(&#123; age, name,<span class=\"attr\">type</span>:<span class=\"string\">'handsome'</span> &#125; = man);<span class=\"comment\">//解构表达式+默认值</span></span><br></pre></td></tr></table></figure>\n\n<p>在赋值的时候由于man对象中并没有名为type的属性所以会使用默认值同时要注意的是凡是在解构赋值在声明构造器中查找不到同名属性时都会变成undefined</p>\n</li>\n<li><p><strong>赋值给本地变量名</strong>：依旧是第一段代码的赋值语句改成</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> &#123; <span class=\"attr\">age</span>: manage, <span class=\"attr\">name</span>: manname=<span class=\"string\">'zs'</span> &#125; = man;<span class=\"comment\">//解构表达式+默认值+赋值给本地变量</span></span><br></pre></td></tr></table></figure>\n\n<p>这样的话man里面的age和name属性分别对自定义的manage,manname进行了赋值操作， 该语法实际上与传统对象字面量语法相反，传统语法将名称放在冒号左边、值放在冒号右边；而在本例中，<strong>名称在右边，需要进行值读取的位置被放在了左边。</strong></p>\n</li>\n<li><p><strong>解构嵌套对象</strong>:</p>\n<ul>\n<li><strong>简单用法</strong>：在日常开发中有时候会出现我们拿到的数据是一个多层嵌套的对象，而我们只需要获取其中的某些项的情况，这时自己写方法去遍历对象会比较麻烦，这个时候使用解构赋值会节省很多时间:</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> man = &#123;</span><br><span class=\"line\">name: <span class=\"string\">\"zhoushuang\"</span>,</span><br><span class=\"line\">type: &#123;</span><br><span class=\"line\">habit: &#123;</span><br><span class=\"line\">sleep: <span class=\"literal\">true</span>,</span><br><span class=\"line\">eating: <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">let</span> &#123; <span class=\"attr\">type</span>: &#123; habit &#125;&#125; = man;<span class=\"comment\">//嵌套解构赋值</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(habit.sleep); <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(habit.eating); <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n<p>在赋值结构中每当有一个冒号出现，就意味着冒号之前的标识符代表需要检查的位置，而冒号右侧则是赋值的目标。当冒号右侧存在花括号时，表示目标被嵌套在对象的更深一层中，因此<code>{ type: { habit }} = man</code>的运行顺序应该是:man-&gt;寻找type属性-&gt; type属性需找habit属性-&gt;进行操作，每一个{}都可以简单的理解成又进行了一次简单解构赋值而这次的数据源就来自于冒号左边</p>\n<ul>\n<li><p>赋值给本地变量名**:同上一行代码中的赋值语句改成</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> &#123; <span class=\"attr\">type</span>: &#123; <span class=\"attr\">habit</span>:manHabit &#125;&#125; = man;<span class=\"comment\">//嵌套解构赋值+赋值给本地变量</span></span><br></pre></td></tr></table></figure>\n\n<p>其实和简单赋值的形式一样把habit整个对象都赋值给了本地变量manHabit不赘述</p>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"数组解构\"><a href=\"#数组解构\" class=\"headerlink\" title=\"数组解构\"></a>数组解构</h3><p>总体来说数组解构赋值和对象解构赋值非常的相似，因此在此也只介绍数组解构的不同之处,其他情况参考上文。</p>\n<ul>\n<li><p><strong>简单解构赋值</strong>:与对象相比语法不同’{}‘-&gt;’[]‘，并且在运行的时候不是查找同名属性而是直接按照参数的顺序进行赋值</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> colors = [ <span class=\"string\">\"red\"</span>, <span class=\"string\">\"green\"</span>, <span class=\"string\">\"blue\"</span> ];</span><br><span class=\"line\"><span class=\"keyword\">let</span> [ first, second ] = colors;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(first); <span class=\"comment\">// \"red\"</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(second); <span class=\"comment\">// \"green\"</span></span><br></pre></td></tr></table></figure>\n\n<p>在以上代码中能看到first和second分别获取了colors数组中的第一和第二个而这是根据参数各自的位置决定的，所以我们也可以使用占位符<code>，</code>来给获取指定的数据</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> [,second ] = colors;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(second); <span class=\"comment\">// \"green\"</span></span><br></pre></td></tr></table></figure>\n\n\n\n</li>\n</ul>\n<ul>\n<li><p>默认值:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let [ first, second= <span class=\"string\">\"pink\"</span> ] = colors;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>参数交换:在ES6中可以运用解构赋值进行参数交换而无需中间变量</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> a = <span class=\"number\">1</span>,</span><br><span class=\"line\">b = <span class=\"number\">2</span>;</span><br><span class=\"line\">[ a, b ] = [ b, a ];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a); <span class=\"comment\">// 2</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(b); <span class=\"comment\">// 1</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>嵌套解构:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> colors = [ <span class=\"string\">\"red\"</span>, [ <span class=\"string\">\"green\"</span>, <span class=\"string\">\"lightgreen\"</span> ], <span class=\"string\">\"blue\"</span> ];</span><br><span class=\"line\"><span class=\"comment\">// 随后</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> [ firstColor, [ secondColor ] ] = colors;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(firstColor); <span class=\"comment\">// \"red\"</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(secondColor); <span class=\"comment\">// \"green\"</span></span><br></pre></td></tr></table></figure>\n\n<p>和对象嵌套时的原理一样,只不过在数组中不是根据属性名来查找而是根据参数的位置查找的,所以<code>[ firstColor, [ secondColor ] ] = colors;</code>也相当于进行了两次解构赋值操作,第一次<code>firstColor=red；[ secondColor ]= [ &quot;green&quot;, &quot;lightgreen&quot; ]</code> ，第二次<code>secondColor =green</code></p>\n</li>\n</ul>\n<p>需要注意的是在数组解构的时候如果有嵌套解构的情况但是对应的数据源只要不是可转成数组的值都会报错，如果可以转成数组会先将其转化成数组在进行赋值:</p>\n<p><img src=\"/2020/01/05/ES6%E8%AF%AD%E6%B3%95%E6%80%BB%E7%BB%93%E4%B8%89(%E8%A7%A3%E6%9E%84%E3%80%81Set%E5%92%8CMap)/%E6%95%B0%E7%BB%84%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC.png\" alt></p>\n<ul>\n<li><p>剩余项赋值:因为数组中有arguments对象所以在数组解构中也可以使用</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> colors = [ <span class=\"string\">\"red\"</span>, <span class=\"string\">\"green\"</span>, <span class=\"string\">\"blue\"</span> ];</span><br><span class=\"line\"><span class=\"keyword\">let</span> [ firstColor, ...restColors ] = colors;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(firstColor); <span class=\"comment\">// \"red\"</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(restColors.length); <span class=\"comment\">// 2</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(restColors[<span class=\"number\">0</span>]); <span class=\"comment\">// \"green\"</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(restColors[<span class=\"number\">1</span>]); <span class=\"comment\">// \"blue\"</span></span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h2 id=\"混合解构-对象-数组\"><a href=\"#混合解构-对象-数组\" class=\"headerlink\" title=\"混合解构(对象+数组)\"></a>混合解构(对象+数组)</h2><p>这里其实就是把数组解构和对象解构的语法组合起来，只要注意逻辑和语法就行了，混合结构对于JSON格式的数据获取很有帮助</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> node = &#123;</span><br><span class=\"line\">type: <span class=\"string\">\"Identifier\"</span>,</span><br><span class=\"line\">name: <span class=\"string\">\"foo\"</span>,</span><br><span class=\"line\">loc: &#123;</span><br><span class=\"line\">start: &#123;</span><br><span class=\"line\">line: <span class=\"number\">1</span>,</span><br><span class=\"line\">column: <span class=\"number\">1</span></span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">end: &#123;</span><br><span class=\"line\">line: <span class=\"number\">1</span>,</span><br><span class=\"line\">column: <span class=\"number\">4</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">range: [<span class=\"number\">0</span>, <span class=\"number\">3</span>]</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">let</span> &#123;</span><br><span class=\"line\">loc: &#123; start &#125;,</span><br><span class=\"line\">range: [ startIndex ]</span><br><span class=\"line\">&#125; = node;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(start.line); <span class=\"comment\">// 1</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(start.column); <span class=\"comment\">// 1</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(startIndex); <span class=\"comment\">// 0</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Set和Map\"><a href=\"#Set和Map\" class=\"headerlink\" title=\"Set和Map\"></a>Set和Map</h2><h3 id=\"Set-无重复值的有序列表\"><a href=\"#Set-无重复值的有序列表\" class=\"headerlink\" title=\"Set(无重复值的有序列表)\"></a>Set(无重复值的有序列表)</h3><ul>\n<li><p><strong>创建set并添加内容</strong>：</p>\n<p>使用new来创建，add方法添加项目</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"keyword\">set</span> = new Set();</span><br><span class=\"line\"><span class=\"keyword\">set</span>.add(5);</span><br><span class=\"line\"><span class=\"keyword\">set</span>.add(\"5\");</span><br><span class=\"line\">console.log(<span class=\"keyword\">set</span>.size); // 2</span><br></pre></td></tr></table></figure>\n\n<p>Set 不会使用强制类型转换来判断值是否重复。这意味着 Set 可以同时包含数值 5 与 字符串 “5” ，将它们都作为相对独立的项,因为这里使用的是Object.is() 方法，来判断两个值是否相等，唯一的例外是 +0 与 -0 在 Set 中被判断为是相等的）。你还可以向 Set 添加多个对象，它们也不会被合并为同一项</p>\n</li>\n<li><p><strong>Set.has()</strong>：用来搜索目标set中是否存在某一项，并返回结果(true/false)</p>\n</li>\n<li><p><strong>Set.delete()</strong>:用来删除目标set中的某一项，并返回结果(true/false)</p>\n</li>\n<li><p><strong>Set.clear()</strong>:用来删除目标set中的某一项，无返回</p>\n</li>\n<li><p><strong>Set 转换为数组</strong>：将数组转换为 Set 相当容易，因为可以将数组传递给 Set 构造器；而使用扩展运算符也能简<br>单地将 Set 转换回数组</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"keyword\">set</span> = new Set([1, 2, 3, 3, 3, 4, 5]),</span><br><span class=\"line\">array = [...<span class=\"keyword\">set</span>];</span><br><span class=\"line\">console.log(array); // [1,2,3,4,5]</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Weak Set：</p>\n<p>在以上转化数组的时候仔细观察就能发现，使用set转换数组时只是将set中的内容复制给了一个array而已，原set的内容中依旧还存在，对象存储在 Set 的一个实例中时，实际上相当于把对象存储在变量中。只要对于 Set 实例的引用仍然存在，所存储的对象就无法被垃圾回收机制回收，从而无法释放内存，所以为了解决这个问题也就引入了Weak Set</p>\n<ul>\n<li><p>创建 Weak Set:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"keyword\">set</span> = new WeakSet(),</span><br><span class=\"line\">key = &#123;&#125;;</span><br><span class=\"line\"><span class=\"comment\">// 将对象加入 set</span></span><br><span class=\"line\"><span class=\"keyword\">set</span>.add(key);</span><br><span class=\"line\">console.log(<span class=\"keyword\">set</span>.has(key)); // true</span><br><span class=\"line\"><span class=\"keyword\">set</span>.delete(key);</span><br><span class=\"line\">console.log(<span class=\"keyword\">set</span>.has(key)); // false</span><br></pre></td></tr></table></figure>\n\n<p>Weak Set 使用 WeakSet 构造器来创建，同时也包含了 add() 、 has()和 delete(),没有clear，该类型只允许存储对象弱引用，而不能存储基本类型的值。对象的弱引用在它自己成为该对象的唯一引用时，不会阻止垃圾回收，</p>\n</li>\n<li><p>Set 类型之间的关键差异：</p>\n<ul>\n<li>对于 WeakSet 的实例，若调用 add() 方法时传入了非对象的参数，就会抛出错误（has() 或 delete() 则会在传入了非对象的参数时返回 false ）；</li>\n</ul>\n<ol start=\"2\">\n<li>Weak Set 不可迭代，因此不能被用在 for-of 循环中；</li>\n</ol>\n<ul>\n<li>Weak Set 无法暴露出任何迭代器（例如 keys() 与 values() 方法），因此没有任何编程手段可用于判断 Weak Set 的内容；</li>\n</ul>\n<ol start=\"4\">\n<li>Weak Set 没有 forEach() 方法；</li>\n<li>Weak Set 没有 size 属性。</li>\n</ol>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Map-键值对有序列表\"><a href=\"#Map-键值对有序列表\" class=\"headerlink\" title=\"Map(键值对有序列表)\"></a>Map(键值对有序列表)</h3><p>Map中的数据以键值对的形式存在,而键和值都可以是任意类型。键的比较使用的是Object.is() ，因此你能将 5 与 “5” 同时作为键，因为它们类型不同。这与使用对象属性作为键的方式（指的是用对象来模拟 Map ）截然不同，因为对象的属性会被强制转换为字符串。</p>\n<ul>\n<li><p><strong>Map方法</strong>：</p>\n<ul>\n<li>get(),set():调用 set() 方法并给它传递一个键与一个关联的值，来给 Map 添加项；此后使用键<br>名来调用 get() 方法便能提取对应的值</li>\n<li>has(key) ：判断指定的键是否存在于 Map 中；</li>\n<li>delete(key) ：移除 Map 中的键以及对应的值；</li>\n<li>clear() ：移除 Map 中所有的键与值。</li>\n</ul>\n</li>\n<li><p><strong>Weak Map</strong>:</p>\n<p>WeakMap 类型是键值对的无序列表，其中键必须是非空的对象，值则允许是任意类型。 WeakMap 的接口与 Map 的非常相似，都使用 set() 与 get() 方法来分别添加与提取数据</p>\n<ul>\n<li><strong>Weak Map 的初始化</strong><br>为了初始化 Weak Map ，需要把一个由数组构成的数组传递给 WeakMap 构造器。就像正规Map 构造器那样，每个内部数组都应当有两个项，第一项是作为键的非空的对象，第二项则是对应的值（任意类型）</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> key1 = &#123;&#125;,</span><br><span class=\"line\">key2 = &#123;&#125;,</span><br><span class=\"line\">map = <span class=\"keyword\">new</span> <span class=\"built_in\">WeakMap</span>([[key1, <span class=\"string\">\"Hello\"</span>], [key2, <span class=\"number\">42</span>]]);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(map.has(key1)); <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(map.get(key1)); <span class=\"comment\">// \"Hello\"</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(map.has(key2)); <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(map.get(key2)); <span class=\"comment\">// 42</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>Weak Map 的方法</p>\n<p>has() 方法用于判断指定的键是否存在 delete() 方法则用于移除一个特定的键值对。</p>\n</li>\n</ul>\n</li>\n<li><p>Weak Map 的用法与局限性</p>\n<p>如果你只想使用对象类型的键。最好的选择就是 Weak Map 。因为它能确保额外数据在不再可用后被销毁，从而能优化内存使用并规避内存泄漏。但是 Weak Map 只为它们的内容提供了很小的可见度，因此不能使用 forEach() 方法、size 属性或 clear() 方法来管理其中的项。而在除此之外的其他情况，正常 Map是更好的选择，只是要注意对内存的使用。</p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"<h1 id=\"ES6语法总结\"><a href=\"#ES6语法总结\" class=\"headerlink\" title=\"ES6语法总结\"></a>ES6语法总结</h1><h2 id=\"解构\"><a href=\"#解构\" class=\"headerlink\" title=\"解构\"></a>解构</h2><h3 id=\"作用\"><a href=\"#作用\" class=\"headerlink\" title=\"作用:\"></a>作用:</h3><p>从对象或数组中获取信息、并将特定数据存入本地变量</p>\n<h3 id=\"对象解构：\"><a href=\"#对象解构：\" class=\"headerlink\" title=\"对象解构：\"></a>对象解构：</h3><ul>\n<li><p><strong>简单的解构</strong>:先从一段代码说起</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> man = &#123;</span><br><span class=\"line\">age: <span class=\"string\">\"23\"</span>,</span><br><span class=\"line\">name: <span class=\"string\">\"zhoushuang\"</span></span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">age: <span class=\"string\">\"24\"</span>,</span><br><span class=\"line\">name = <span class=\"string\">\"zs\"</span>;</span><br><span class=\"line\"><span class=\"comment\">// 使用解构来分配不同的值</span></span><br><span class=\"line\">(&#123; age, name &#125; = man);<span class=\"comment\">//解构表达式</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(age); <span class=\"comment\">// \"23\"</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(name); <span class=\"comment\">// \"zhoushuang\"</span></span><br></pre></td></tr></table></figure></li></ul>","more":"<p>在这个例子中 age与 name 属性在声明时被初始化，而两个同名变量也被声明并初始化为不同的值。接下来一行使用了解构表达式，通过读取 man对象来更改这两个变量的值。在这里必须用<strong>圆括号包裹解构赋值语句</strong>，这是因为暴露的花括号会被解析为代码块语句，而块语句不允许在赋值操作符左侧出现。圆括号标示了里面的花括号并不是块语句、而应该被解释为表达式，从而允许完成赋值操作。                </p>\n\n<li><p><strong>设置默认值</strong>:同上代码中的赋值语句改成</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(&#123; age, name,<span class=\"attr\">type</span>:<span class=\"string\">'handsome'</span> &#125; = man);<span class=\"comment\">//解构表达式+默认值</span></span><br></pre></td></tr></table></figure>\n\n<p>在赋值的时候由于man对象中并没有名为type的属性所以会使用默认值同时要注意的是凡是在解构赋值在声明构造器中查找不到同名属性时都会变成undefined</p>\n</li>\n<li><p><strong>赋值给本地变量名</strong>：依旧是第一段代码的赋值语句改成</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> &#123; <span class=\"attr\">age</span>: manage, <span class=\"attr\">name</span>: manname=<span class=\"string\">'zs'</span> &#125; = man;<span class=\"comment\">//解构表达式+默认值+赋值给本地变量</span></span><br></pre></td></tr></table></figure>\n\n<p>这样的话man里面的age和name属性分别对自定义的manage,manname进行了赋值操作， 该语法实际上与传统对象字面量语法相反，传统语法将名称放在冒号左边、值放在冒号右边；而在本例中，<strong>名称在右边，需要进行值读取的位置被放在了左边。</strong></p>\n</li>\n<li><p><strong>解构嵌套对象</strong>:</p>\n<ul>\n<li><strong>简单用法</strong>：在日常开发中有时候会出现我们拿到的数据是一个多层嵌套的对象，而我们只需要获取其中的某些项的情况，这时自己写方法去遍历对象会比较麻烦，这个时候使用解构赋值会节省很多时间:</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> man = &#123;</span><br><span class=\"line\">name: <span class=\"string\">\"zhoushuang\"</span>,</span><br><span class=\"line\">type: &#123;</span><br><span class=\"line\">habit: &#123;</span><br><span class=\"line\">sleep: <span class=\"literal\">true</span>,</span><br><span class=\"line\">eating: <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">let</span> &#123; <span class=\"attr\">type</span>: &#123; habit &#125;&#125; = man;<span class=\"comment\">//嵌套解构赋值</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(habit.sleep); <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(habit.eating); <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n<p>在赋值结构中每当有一个冒号出现，就意味着冒号之前的标识符代表需要检查的位置，而冒号右侧则是赋值的目标。当冒号右侧存在花括号时，表示目标被嵌套在对象的更深一层中，因此<code>{ type: { habit }} = man</code>的运行顺序应该是:man-&gt;寻找type属性-&gt; type属性需找habit属性-&gt;进行操作，每一个{}都可以简单的理解成又进行了一次简单解构赋值而这次的数据源就来自于冒号左边</p>\n<ul>\n<li><p>赋值给本地变量名**:同上一行代码中的赋值语句改成</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> &#123; <span class=\"attr\">type</span>: &#123; <span class=\"attr\">habit</span>:manHabit &#125;&#125; = man;<span class=\"comment\">//嵌套解构赋值+赋值给本地变量</span></span><br></pre></td></tr></table></figure>\n\n<p>其实和简单赋值的形式一样把habit整个对象都赋值给了本地变量manHabit不赘述</p>\n</li>\n</ul>\n</li>\n\n<h3 id=\"数组解构\"><a href=\"#数组解构\" class=\"headerlink\" title=\"数组解构\"></a>数组解构</h3><p>总体来说数组解构赋值和对象解构赋值非常的相似，因此在此也只介绍数组解构的不同之处,其他情况参考上文。</p>\n<ul>\n<li><p><strong>简单解构赋值</strong>:与对象相比语法不同’{}‘-&gt;’[]‘，并且在运行的时候不是查找同名属性而是直接按照参数的顺序进行赋值</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> colors = [ <span class=\"string\">\"red\"</span>, <span class=\"string\">\"green\"</span>, <span class=\"string\">\"blue\"</span> ];</span><br><span class=\"line\"><span class=\"keyword\">let</span> [ first, second ] = colors;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(first); <span class=\"comment\">// \"red\"</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(second); <span class=\"comment\">// \"green\"</span></span><br></pre></td></tr></table></figure>\n\n<p>在以上代码中能看到first和second分别获取了colors数组中的第一和第二个而这是根据参数各自的位置决定的，所以我们也可以使用占位符<code>，</code>来给获取指定的数据</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> [,second ] = colors;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(second); <span class=\"comment\">// \"green\"</span></span><br></pre></td></tr></table></figure>\n\n\n\n</li>\n</ul>\n<ul>\n<li><p>默认值:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let [ first, second= <span class=\"string\">\"pink\"</span> ] = colors;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>参数交换:在ES6中可以运用解构赋值进行参数交换而无需中间变量</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> a = <span class=\"number\">1</span>,</span><br><span class=\"line\">b = <span class=\"number\">2</span>;</span><br><span class=\"line\">[ a, b ] = [ b, a ];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a); <span class=\"comment\">// 2</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(b); <span class=\"comment\">// 1</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>嵌套解构:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> colors = [ <span class=\"string\">\"red\"</span>, [ <span class=\"string\">\"green\"</span>, <span class=\"string\">\"lightgreen\"</span> ], <span class=\"string\">\"blue\"</span> ];</span><br><span class=\"line\"><span class=\"comment\">// 随后</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> [ firstColor, [ secondColor ] ] = colors;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(firstColor); <span class=\"comment\">// \"red\"</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(secondColor); <span class=\"comment\">// \"green\"</span></span><br></pre></td></tr></table></figure>\n\n<p>和对象嵌套时的原理一样,只不过在数组中不是根据属性名来查找而是根据参数的位置查找的,所以<code>[ firstColor, [ secondColor ] ] = colors;</code>也相当于进行了两次解构赋值操作,第一次<code>firstColor=red；[ secondColor ]= [ &quot;green&quot;, &quot;lightgreen&quot; ]</code> ，第二次<code>secondColor =green</code></p>\n</li>\n</ul>\n<p>需要注意的是在数组解构的时候如果有嵌套解构的情况但是对应的数据源只要不是可转成数组的值都会报错，如果可以转成数组会先将其转化成数组在进行赋值:</p>\n<p><img src=\"/2020/01/05/ES6%E8%AF%AD%E6%B3%95%E6%80%BB%E7%BB%93%E4%B8%89(%E8%A7%A3%E6%9E%84%E3%80%81Set%E5%92%8CMap)/%E6%95%B0%E7%BB%84%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC.png\" alt></p>\n<ul>\n<li><p>剩余项赋值:因为数组中有arguments对象所以在数组解构中也可以使用</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> colors = [ <span class=\"string\">\"red\"</span>, <span class=\"string\">\"green\"</span>, <span class=\"string\">\"blue\"</span> ];</span><br><span class=\"line\"><span class=\"keyword\">let</span> [ firstColor, ...restColors ] = colors;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(firstColor); <span class=\"comment\">// \"red\"</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(restColors.length); <span class=\"comment\">// 2</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(restColors[<span class=\"number\">0</span>]); <span class=\"comment\">// \"green\"</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(restColors[<span class=\"number\">1</span>]); <span class=\"comment\">// \"blue\"</span></span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h2 id=\"混合解构-对象-数组\"><a href=\"#混合解构-对象-数组\" class=\"headerlink\" title=\"混合解构(对象+数组)\"></a>混合解构(对象+数组)</h2><p>这里其实就是把数组解构和对象解构的语法组合起来，只要注意逻辑和语法就行了，混合结构对于JSON格式的数据获取很有帮助</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> node = &#123;</span><br><span class=\"line\">type: <span class=\"string\">\"Identifier\"</span>,</span><br><span class=\"line\">name: <span class=\"string\">\"foo\"</span>,</span><br><span class=\"line\">loc: &#123;</span><br><span class=\"line\">start: &#123;</span><br><span class=\"line\">line: <span class=\"number\">1</span>,</span><br><span class=\"line\">column: <span class=\"number\">1</span></span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">end: &#123;</span><br><span class=\"line\">line: <span class=\"number\">1</span>,</span><br><span class=\"line\">column: <span class=\"number\">4</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">range: [<span class=\"number\">0</span>, <span class=\"number\">3</span>]</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">let</span> &#123;</span><br><span class=\"line\">loc: &#123; start &#125;,</span><br><span class=\"line\">range: [ startIndex ]</span><br><span class=\"line\">&#125; = node;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(start.line); <span class=\"comment\">// 1</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(start.column); <span class=\"comment\">// 1</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(startIndex); <span class=\"comment\">// 0</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Set和Map\"><a href=\"#Set和Map\" class=\"headerlink\" title=\"Set和Map\"></a>Set和Map</h2><h3 id=\"Set-无重复值的有序列表\"><a href=\"#Set-无重复值的有序列表\" class=\"headerlink\" title=\"Set(无重复值的有序列表)\"></a>Set(无重复值的有序列表)</h3><ul>\n<li><p><strong>创建set并添加内容</strong>：</p>\n<p>使用new来创建，add方法添加项目</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"keyword\">set</span> = new Set();</span><br><span class=\"line\"><span class=\"keyword\">set</span>.add(5);</span><br><span class=\"line\"><span class=\"keyword\">set</span>.add(\"5\");</span><br><span class=\"line\">console.log(<span class=\"keyword\">set</span>.size); // 2</span><br></pre></td></tr></table></figure>\n\n<p>Set 不会使用强制类型转换来判断值是否重复。这意味着 Set 可以同时包含数值 5 与 字符串 “5” ，将它们都作为相对独立的项,因为这里使用的是Object.is() 方法，来判断两个值是否相等，唯一的例外是 +0 与 -0 在 Set 中被判断为是相等的）。你还可以向 Set 添加多个对象，它们也不会被合并为同一项</p>\n</li>\n<li><p><strong>Set.has()</strong>：用来搜索目标set中是否存在某一项，并返回结果(true/false)</p>\n</li>\n<li><p><strong>Set.delete()</strong>:用来删除目标set中的某一项，并返回结果(true/false)</p>\n</li>\n<li><p><strong>Set.clear()</strong>:用来删除目标set中的某一项，无返回</p>\n</li>\n<li><p><strong>Set 转换为数组</strong>：将数组转换为 Set 相当容易，因为可以将数组传递给 Set 构造器；而使用扩展运算符也能简<br>单地将 Set 转换回数组</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"keyword\">set</span> = new Set([1, 2, 3, 3, 3, 4, 5]),</span><br><span class=\"line\">array = [...<span class=\"keyword\">set</span>];</span><br><span class=\"line\">console.log(array); // [1,2,3,4,5]</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Weak Set：</p>\n<p>在以上转化数组的时候仔细观察就能发现，使用set转换数组时只是将set中的内容复制给了一个array而已，原set的内容中依旧还存在，对象存储在 Set 的一个实例中时，实际上相当于把对象存储在变量中。只要对于 Set 实例的引用仍然存在，所存储的对象就无法被垃圾回收机制回收，从而无法释放内存，所以为了解决这个问题也就引入了Weak Set</p>\n<ul>\n<li><p>创建 Weak Set:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"keyword\">set</span> = new WeakSet(),</span><br><span class=\"line\">key = &#123;&#125;;</span><br><span class=\"line\"><span class=\"comment\">// 将对象加入 set</span></span><br><span class=\"line\"><span class=\"keyword\">set</span>.add(key);</span><br><span class=\"line\">console.log(<span class=\"keyword\">set</span>.has(key)); // true</span><br><span class=\"line\"><span class=\"keyword\">set</span>.delete(key);</span><br><span class=\"line\">console.log(<span class=\"keyword\">set</span>.has(key)); // false</span><br></pre></td></tr></table></figure>\n\n<p>Weak Set 使用 WeakSet 构造器来创建，同时也包含了 add() 、 has()和 delete(),没有clear，该类型只允许存储对象弱引用，而不能存储基本类型的值。对象的弱引用在它自己成为该对象的唯一引用时，不会阻止垃圾回收，</p>\n</li>\n<li><p>Set 类型之间的关键差异：</p>\n<ul>\n<li>对于 WeakSet 的实例，若调用 add() 方法时传入了非对象的参数，就会抛出错误（has() 或 delete() 则会在传入了非对象的参数时返回 false ）；</li>\n</ul>\n<ol start=\"2\">\n<li>Weak Set 不可迭代，因此不能被用在 for-of 循环中；</li>\n</ol>\n<ul>\n<li>Weak Set 无法暴露出任何迭代器（例如 keys() 与 values() 方法），因此没有任何编程手段可用于判断 Weak Set 的内容；</li>\n</ul>\n<ol start=\"4\">\n<li>Weak Set 没有 forEach() 方法；</li>\n<li>Weak Set 没有 size 属性。</li>\n</ol>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Map-键值对有序列表\"><a href=\"#Map-键值对有序列表\" class=\"headerlink\" title=\"Map(键值对有序列表)\"></a>Map(键值对有序列表)</h3><p>Map中的数据以键值对的形式存在,而键和值都可以是任意类型。键的比较使用的是Object.is() ，因此你能将 5 与 “5” 同时作为键，因为它们类型不同。这与使用对象属性作为键的方式（指的是用对象来模拟 Map ）截然不同，因为对象的属性会被强制转换为字符串。</p>\n<ul>\n<li><p><strong>Map方法</strong>：</p>\n<ul>\n<li>get(),set():调用 set() 方法并给它传递一个键与一个关联的值，来给 Map 添加项；此后使用键<br>名来调用 get() 方法便能提取对应的值</li>\n<li>has(key) ：判断指定的键是否存在于 Map 中；</li>\n<li>delete(key) ：移除 Map 中的键以及对应的值；</li>\n<li>clear() ：移除 Map 中所有的键与值。</li>\n</ul>\n</li>\n<li><p><strong>Weak Map</strong>:</p>\n<p>WeakMap 类型是键值对的无序列表，其中键必须是非空的对象，值则允许是任意类型。 WeakMap 的接口与 Map 的非常相似，都使用 set() 与 get() 方法来分别添加与提取数据</p>\n<ul>\n<li><strong>Weak Map 的初始化</strong><br>为了初始化 Weak Map ，需要把一个由数组构成的数组传递给 WeakMap 构造器。就像正规Map 构造器那样，每个内部数组都应当有两个项，第一项是作为键的非空的对象，第二项则是对应的值（任意类型）</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> key1 = &#123;&#125;,</span><br><span class=\"line\">key2 = &#123;&#125;,</span><br><span class=\"line\">map = <span class=\"keyword\">new</span> <span class=\"built_in\">WeakMap</span>([[key1, <span class=\"string\">\"Hello\"</span>], [key2, <span class=\"number\">42</span>]]);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(map.has(key1)); <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(map.get(key1)); <span class=\"comment\">// \"Hello\"</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(map.has(key2)); <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(map.get(key2)); <span class=\"comment\">// 42</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>Weak Map 的方法</p>\n<p>has() 方法用于判断指定的键是否存在 delete() 方法则用于移除一个特定的键值对。</p>\n</li>\n</ul>\n</li>\n<li><p>Weak Map 的用法与局限性</p>\n<p>如果你只想使用对象类型的键。最好的选择就是 Weak Map 。因为它能确保额外数据在不再可用后被销毁，从而能优化内存使用并规避内存泄漏。但是 Weak Map 只为它们的内容提供了很小的可见度，因此不能使用 forEach() 方法、size 属性或 clear() 方法来管理其中的项。而在除此之外的其他情况，正常 Map是更好的选择，只是要注意对内存的使用。</p>\n</li>\n</ul>"},{"title":"ES6语法总结(四)","date":"2020-01-20T10:54:12.000Z","_content":"\n\n\n# ES6语法总结\n\n## Promise与异步\n\n### Promise诞生的原因\n\n前端和后端各种多样化交互才使各种程序拥有了使用的实际价值，而前后端交互绝大部分都属于异步编程，所以了解异步是对于前端来说是异常重要的一步，接下来先看一下传统的异步\n\n- **传统的异步**：\n\n  - 事件模型\n\n  ```javascript\n  let button = document.getElementById(\"btn\");\n      button.onclick = function(event) {\n      console.log(\"Clicked\");\n  }\n  ```\n<!--more-->\n  在这段代码中就是事件模型的一种，给id为`btn`的dom元素绑定了一个点击方法，但是它只会被编译而不会被执行，只有当该元素被点击之后才会js引擎才会把click的方法加入到作业队列的末尾，而所有类似这种绑定特定事件只有在特定条件下才会执行的模式叫做事件模式，这也是异步的一种。\n\n  - 问题：对于这种模式来说当需要简单的交互时简单好用但是又两个问题\n    - 每一个事件模型都需要追踪事件对象，有一百个点击事件就要监控一百个对象很麻烦\n    - 未必能够完成绑定因为也可能绑定事件的时候dom还不存在\n  - 回调模式\n\n  ```javascript\n  readFile(\"example.txt\", function(err, contents) {\n      if (err) {\n     \t\t throw err;\n     \t }\n     \t\tconsole.log(contents);\n     });\n  console.log(\"Hi!\");\n  ```\n\n  `readFile()` 函数用于读取磁盘中的文件（由第一个参数指定），并在读取完毕后执行回调函数（即第二个参数）。如果存在错误，回调函数的 err 参数会是一个错误对象；否则 contents 参数就会以字符串形式包含文件内容。使用回调函数模式， `readFile()` 会立即开始执行，并在开始读取磁盘时暂停。这意味着`console.log(\"Hi!\") `会在 `readFile()` 被调用后立即进行输出，要早于`console.log(contents) `的打印操作。当 `readFile() `结束操作后，它会将回调函数以及相关参数作为一个新的作业添加到作业队列的尾部。在之前的作业全部结束后，该作业才会执行,在这种情况下如果要进行异步串联就容易得多，但是会出现**回调地狱**的情况\n\n```javascript\nmethod1(function(err, result) {\n       if (err) {\n         throw err\n       \t }\n       method2(function(err, result) {\n         if (err) {\n           throw err\n         }\n         method3(function(err, result) {\n           if (err) {\n             throw err\n           }\n           method4(function(err, result) {\n             if (err) {\n               throw err\n             }\n             method5(result)\n           })\n         })\n       })\n     })\n```\n\n​\t是不是看了就很想死...不但代码复杂高度耦合而且当你需要两个异步并行操作或者想同时开始两个异步的时候就\t特别麻烦了，所以才有了Promise\n\n- ### Promise\n\n  #### Promise 生命周期\n\n  ![1585030576405](ES6语法总结四(迭代生成器、Promise和异步)/Promise生命周期.png)\n\n  在这里把几个意思都解释一下：\n\n  1. 程序整体状态：\n     - unsettled(未决):就是挂起状态，但是这个状态是用来描述程序的整体状况\n     - settled(已决):程序已经执行完成\n     - resolve(决议):推进为程序执行状态为已决\n  2. 程序具体状态:\n     - pending(挂起):异步程序尚未结束，等待结果中\n     - fulfilled(完成):异步程序结束，操作完成\n     - rejected(拒绝):异步程序结束，操作失败\n  3. 推进状态操作函数\n     - resolve():调用resolve()更改程序状态为已完成\n     - reject():调用resolve()更改程序状态为已失败\n  4. 状态完成函数\n     - fulfillment handler:成功决议之后调用的函数\n     - rejection handler :失败之后调用的函数\n\n  在以上描述中描述程序具体状态的值会被设置在Promise对象的`PromiseState`属性中但是这个属性没有暴露所以不能访问，因此才需要`.then()`方法来对Promise的不同情况进行想要的操作\n\n  **then()方法**：\n\n  ​\t在Promise状态为settled的时候会被调用，接收两个可选参数（都是回调函数的形式）,第一个是成功的回调函数，第二个是失败的回调函数，在失败的时候会默认传递一个包含有错误信息的对象进去。\n\n  **catch()方法**:\n\n  ​\t 在这里的`promise.catch(function...)`<=>`promise.then(null,function..)`,默认传递rejection handler\n\n​\t\t\t**当没有写入都有的错误都会静默发生所以最好给promise都写一个默认的日志**\n\n#### 创建Promise\n\n##### 创建未决Promise\n\n​\t使用 Promise 构造器来创建。此构造器接受单个参数：执行器(executor)函数，包含初始化 Promise 的代码。该执行器会被传递两个名为 resolve()与 reject() 的函数作为参数\n\n```javascript\nlet promise = new Promise(function(resolve, reject) {\n    console.log(\"啊啊啊\");\n    resolve();\n    if(err){\n       reject();\n\t}\n});\nconsole.log(\"哦哦哦\");\n//啊啊啊\n//哦哦哦\n```\n\n​\t构造器会在promise实例化的时候立刻执行。然后才会发生而里面 resolve() 或 reject() 在执行器内部被调用\t      时，一个作业被添加到作业队列中，以便决议（ resolve ）这个 Promise 。这也称为作业调度( job scheduling )，要注意一下被调度的作业会被放到队列的末尾最后执行\n\n##### 创建已决Promise\n\n​\tPromise.resolve()和Promise.reject()的使用方式一样的所以只列举一个，另外一个照搬就行了\n\n```javascript\nlet promise = Promise.resolve(42);\n    promise.then(function(value) {\n    console.log(value); // 42\n});\t\n```\n\n​\t接受单个参数并返回一个处于完成态的 Promise 。没有任何作业调度会发生，并且需要向 Promise 添加一个或更多的完成处理函数来提取这个参数值。\n\n##### 执行器错误\n\n​\t如果在执行器内部抛出了错误， Promise 的拒绝处理函数就会被调用，如果没有错误就会静默\n\n#####全局的 Promise 拒绝处理\n\n​\tPromise有一个问题就是报错静默：当没有指定报错处理时发生的所有错误都不会被暴露和抛出而且你没有什么直观的办法去判断Promise的处理结果，而且你也不知道一个Promise对象什么时候会被处理\n\n ```javascript\nlet rejected = Promise.reject(42);\n\n// 一段时间后……\n\trejected.catch(function(value) {\n// rejected 被处理\n\tconsole.log(value);\n});\n\n ```\n\n​\t但是不用担心浏览器已经有了解决方案：\n\n​\t**浏览器的拒绝处理**：\n\n当有有未处理的拒绝 时window 对象会触发两个事件：\t\t\t\n\n> `unhandledrejection` ：当一个 Promise 被拒绝、而在事件循环的一个轮次中没有任何拒绝处理函数被调用，该事件就会被触发；\n> `rejectionHandled` ：若一个 Promise 被拒绝、并在事件循环的一个轮次之后再有拒绝处理函数被调用，该事件就会被触发。\n\n以上两个浏览器事件的处理函数会接收到含下列属性的一个对象：\n\n> type ： 事件的名称（ \"unhandledrejection\" 或 \"rejectionhandled\" ）；\n> promise ：被拒绝的 Promise 对象；\n> reason ： Promise 中的拒绝值（拒绝原因）。\n\n#### 串联 Promise(Promise链)\n\n```javascript\nlet p1 = new Promise(function(resolve, reject) {\n\tresolve(42);\n});\np1.then(function(value) {\n\tconsole.log(value);\n\t}).then(function() {\n\tconsole.log(\"Finished\");\n});\n\n```\n\n对 p1.then() 的调用返回了第二个 Promise ，又在这之上调用了 then() 。仅当第一个Promise 已被决议后，第二个 then() 的完成处理函数才会被调用,每一次的加入作业队列时都会新生成一个promise\n\n- **捕获错误**\n  \n  - Promise 链允许捕获上一个 Promise 的完成或拒绝处理函数中发生的错误\n  \n  ```javascript\n  let p1 = new Promise(function(resolve, reject) {\n  \tresolve(42);\n  });\n  p1.then(function(value) {\n  \tthrow new Error(\"Boom!\");\n  }).catch(function(error) {\n  \tconsole.log(error.message); // \"Boom!\"\n  });\n  ```\n  \n  在以上代码中， p1 的完成处理函数抛出了一个错误，链式调用指向了第二个 Promise 上的catch() 方法，能通过此拒绝处理函数接收前面的错误，前面如果是拒绝函数的话也是一样的。\n\n- 在 Promise 链中返回值\n\n  Promise 链的另一重要方面是能从一个 Promise 传递数据给下一个 Promise 的能力。传递给\n  执行器中的 resolve() 处理函数的参数，会被传递给对应 Promise 的完成处理函数，\n\n  ```javascript\n  let p1 = new Promise(function(resolve, reject) {\n  \tresolve(42);\n  });\n  p1.then(function(value) {\n  \t\tconsole.log(value); // \"42\"\n  \t\treturn value + 1;\n  \t}).then(function(value) {\n  \t\tconsole.log(value); // \"43\"\n  });\n  \n  ```\n\n  p1 的完成处理函数在被执行时返回了 value + 1 。由于 value 的值为 42 （来自执行\n  器），此完成处理函数就返回了 43 。这个值随后被传递给第二个 Promise 的完成处理函数，\n\n- 在 Promise 链中返回 Promise\n\n  ```javascript\n  let p1 = new Promise(function(resolve, reject) {\n  \tresolve(42);\n  });\n  let p2 = new Promise(function(resolve, reject) {\n  \tresolve(43);\n  });\n  p1.then(function(value) {\n  \t\t// 第一个完成处理函数\n          console.log(value); // 42\n          return p2;\n  \t}).then(function(value) {\n  \t// 第二个完成处理函数\n  \tconsole.log(value); // 43\n  });\n  ```\n\n  在以上例子中如果p2执行出错的话会导致第二个完成处理函数永不被调用，这是因为在promise链中每当一个promise完成后下一个promise才会被加入作业队列，并且同时会很创建一个新的promise对象获取上一个对象的数据，  因此这以上代码中存在四个promise对象也就是\n\n  ```javascript\n  let p1 = new Promise(function(resolve, reject) {\n  resolve(42);//第一个\n  });\n  let p2 = new Promise(function(resolve, reject) {\n  resolve(43);//第二个\n  });\n  let p3 = p1.then(function(value) {\n  // 第一个完成处理函数\n  console.log(value); // 42\n  return p2;\n  });//第三个\n  \tp3.then(function(value) {\n  // 第二个完成处理函数\n  console.log(value); // 43\n  });//第四个对象\n  ```\n\n  所以当p2报错时p3应当调用的是then()方法的第二个参数也就是拒绝函数而永不调用成功函数\n\n#### 响应多个 Promise\n\n- **Promise.all()**：\n- **Promise.race() 方法**：","source":"_posts/ES6语法总结四(迭代生成器、Promise和异步).md","raw":"---\ntitle: ES6语法总结(四)\ndate: 2020-01-20 18:54:12\ntags:\n\t- 前端\n\t- ES6\ncategories:\n\t- web前端\n\t\n---\n\n\n\n# ES6语法总结\n\n## Promise与异步\n\n### Promise诞生的原因\n\n前端和后端各种多样化交互才使各种程序拥有了使用的实际价值，而前后端交互绝大部分都属于异步编程，所以了解异步是对于前端来说是异常重要的一步，接下来先看一下传统的异步\n\n- **传统的异步**：\n\n  - 事件模型\n\n  ```javascript\n  let button = document.getElementById(\"btn\");\n      button.onclick = function(event) {\n      console.log(\"Clicked\");\n  }\n  ```\n<!--more-->\n  在这段代码中就是事件模型的一种，给id为`btn`的dom元素绑定了一个点击方法，但是它只会被编译而不会被执行，只有当该元素被点击之后才会js引擎才会把click的方法加入到作业队列的末尾，而所有类似这种绑定特定事件只有在特定条件下才会执行的模式叫做事件模式，这也是异步的一种。\n\n  - 问题：对于这种模式来说当需要简单的交互时简单好用但是又两个问题\n    - 每一个事件模型都需要追踪事件对象，有一百个点击事件就要监控一百个对象很麻烦\n    - 未必能够完成绑定因为也可能绑定事件的时候dom还不存在\n  - 回调模式\n\n  ```javascript\n  readFile(\"example.txt\", function(err, contents) {\n      if (err) {\n     \t\t throw err;\n     \t }\n     \t\tconsole.log(contents);\n     });\n  console.log(\"Hi!\");\n  ```\n\n  `readFile()` 函数用于读取磁盘中的文件（由第一个参数指定），并在读取完毕后执行回调函数（即第二个参数）。如果存在错误，回调函数的 err 参数会是一个错误对象；否则 contents 参数就会以字符串形式包含文件内容。使用回调函数模式， `readFile()` 会立即开始执行，并在开始读取磁盘时暂停。这意味着`console.log(\"Hi!\") `会在 `readFile()` 被调用后立即进行输出，要早于`console.log(contents) `的打印操作。当 `readFile() `结束操作后，它会将回调函数以及相关参数作为一个新的作业添加到作业队列的尾部。在之前的作业全部结束后，该作业才会执行,在这种情况下如果要进行异步串联就容易得多，但是会出现**回调地狱**的情况\n\n```javascript\nmethod1(function(err, result) {\n       if (err) {\n         throw err\n       \t }\n       method2(function(err, result) {\n         if (err) {\n           throw err\n         }\n         method3(function(err, result) {\n           if (err) {\n             throw err\n           }\n           method4(function(err, result) {\n             if (err) {\n               throw err\n             }\n             method5(result)\n           })\n         })\n       })\n     })\n```\n\n​\t是不是看了就很想死...不但代码复杂高度耦合而且当你需要两个异步并行操作或者想同时开始两个异步的时候就\t特别麻烦了，所以才有了Promise\n\n- ### Promise\n\n  #### Promise 生命周期\n\n  ![1585030576405](ES6语法总结四(迭代生成器、Promise和异步)/Promise生命周期.png)\n\n  在这里把几个意思都解释一下：\n\n  1. 程序整体状态：\n     - unsettled(未决):就是挂起状态，但是这个状态是用来描述程序的整体状况\n     - settled(已决):程序已经执行完成\n     - resolve(决议):推进为程序执行状态为已决\n  2. 程序具体状态:\n     - pending(挂起):异步程序尚未结束，等待结果中\n     - fulfilled(完成):异步程序结束，操作完成\n     - rejected(拒绝):异步程序结束，操作失败\n  3. 推进状态操作函数\n     - resolve():调用resolve()更改程序状态为已完成\n     - reject():调用resolve()更改程序状态为已失败\n  4. 状态完成函数\n     - fulfillment handler:成功决议之后调用的函数\n     - rejection handler :失败之后调用的函数\n\n  在以上描述中描述程序具体状态的值会被设置在Promise对象的`PromiseState`属性中但是这个属性没有暴露所以不能访问，因此才需要`.then()`方法来对Promise的不同情况进行想要的操作\n\n  **then()方法**：\n\n  ​\t在Promise状态为settled的时候会被调用，接收两个可选参数（都是回调函数的形式）,第一个是成功的回调函数，第二个是失败的回调函数，在失败的时候会默认传递一个包含有错误信息的对象进去。\n\n  **catch()方法**:\n\n  ​\t 在这里的`promise.catch(function...)`<=>`promise.then(null,function..)`,默认传递rejection handler\n\n​\t\t\t**当没有写入都有的错误都会静默发生所以最好给promise都写一个默认的日志**\n\n#### 创建Promise\n\n##### 创建未决Promise\n\n​\t使用 Promise 构造器来创建。此构造器接受单个参数：执行器(executor)函数，包含初始化 Promise 的代码。该执行器会被传递两个名为 resolve()与 reject() 的函数作为参数\n\n```javascript\nlet promise = new Promise(function(resolve, reject) {\n    console.log(\"啊啊啊\");\n    resolve();\n    if(err){\n       reject();\n\t}\n});\nconsole.log(\"哦哦哦\");\n//啊啊啊\n//哦哦哦\n```\n\n​\t构造器会在promise实例化的时候立刻执行。然后才会发生而里面 resolve() 或 reject() 在执行器内部被调用\t      时，一个作业被添加到作业队列中，以便决议（ resolve ）这个 Promise 。这也称为作业调度( job scheduling )，要注意一下被调度的作业会被放到队列的末尾最后执行\n\n##### 创建已决Promise\n\n​\tPromise.resolve()和Promise.reject()的使用方式一样的所以只列举一个，另外一个照搬就行了\n\n```javascript\nlet promise = Promise.resolve(42);\n    promise.then(function(value) {\n    console.log(value); // 42\n});\t\n```\n\n​\t接受单个参数并返回一个处于完成态的 Promise 。没有任何作业调度会发生，并且需要向 Promise 添加一个或更多的完成处理函数来提取这个参数值。\n\n##### 执行器错误\n\n​\t如果在执行器内部抛出了错误， Promise 的拒绝处理函数就会被调用，如果没有错误就会静默\n\n#####全局的 Promise 拒绝处理\n\n​\tPromise有一个问题就是报错静默：当没有指定报错处理时发生的所有错误都不会被暴露和抛出而且你没有什么直观的办法去判断Promise的处理结果，而且你也不知道一个Promise对象什么时候会被处理\n\n ```javascript\nlet rejected = Promise.reject(42);\n\n// 一段时间后……\n\trejected.catch(function(value) {\n// rejected 被处理\n\tconsole.log(value);\n});\n\n ```\n\n​\t但是不用担心浏览器已经有了解决方案：\n\n​\t**浏览器的拒绝处理**：\n\n当有有未处理的拒绝 时window 对象会触发两个事件：\t\t\t\n\n> `unhandledrejection` ：当一个 Promise 被拒绝、而在事件循环的一个轮次中没有任何拒绝处理函数被调用，该事件就会被触发；\n> `rejectionHandled` ：若一个 Promise 被拒绝、并在事件循环的一个轮次之后再有拒绝处理函数被调用，该事件就会被触发。\n\n以上两个浏览器事件的处理函数会接收到含下列属性的一个对象：\n\n> type ： 事件的名称（ \"unhandledrejection\" 或 \"rejectionhandled\" ）；\n> promise ：被拒绝的 Promise 对象；\n> reason ： Promise 中的拒绝值（拒绝原因）。\n\n#### 串联 Promise(Promise链)\n\n```javascript\nlet p1 = new Promise(function(resolve, reject) {\n\tresolve(42);\n});\np1.then(function(value) {\n\tconsole.log(value);\n\t}).then(function() {\n\tconsole.log(\"Finished\");\n});\n\n```\n\n对 p1.then() 的调用返回了第二个 Promise ，又在这之上调用了 then() 。仅当第一个Promise 已被决议后，第二个 then() 的完成处理函数才会被调用,每一次的加入作业队列时都会新生成一个promise\n\n- **捕获错误**\n  \n  - Promise 链允许捕获上一个 Promise 的完成或拒绝处理函数中发生的错误\n  \n  ```javascript\n  let p1 = new Promise(function(resolve, reject) {\n  \tresolve(42);\n  });\n  p1.then(function(value) {\n  \tthrow new Error(\"Boom!\");\n  }).catch(function(error) {\n  \tconsole.log(error.message); // \"Boom!\"\n  });\n  ```\n  \n  在以上代码中， p1 的完成处理函数抛出了一个错误，链式调用指向了第二个 Promise 上的catch() 方法，能通过此拒绝处理函数接收前面的错误，前面如果是拒绝函数的话也是一样的。\n\n- 在 Promise 链中返回值\n\n  Promise 链的另一重要方面是能从一个 Promise 传递数据给下一个 Promise 的能力。传递给\n  执行器中的 resolve() 处理函数的参数，会被传递给对应 Promise 的完成处理函数，\n\n  ```javascript\n  let p1 = new Promise(function(resolve, reject) {\n  \tresolve(42);\n  });\n  p1.then(function(value) {\n  \t\tconsole.log(value); // \"42\"\n  \t\treturn value + 1;\n  \t}).then(function(value) {\n  \t\tconsole.log(value); // \"43\"\n  });\n  \n  ```\n\n  p1 的完成处理函数在被执行时返回了 value + 1 。由于 value 的值为 42 （来自执行\n  器），此完成处理函数就返回了 43 。这个值随后被传递给第二个 Promise 的完成处理函数，\n\n- 在 Promise 链中返回 Promise\n\n  ```javascript\n  let p1 = new Promise(function(resolve, reject) {\n  \tresolve(42);\n  });\n  let p2 = new Promise(function(resolve, reject) {\n  \tresolve(43);\n  });\n  p1.then(function(value) {\n  \t\t// 第一个完成处理函数\n          console.log(value); // 42\n          return p2;\n  \t}).then(function(value) {\n  \t// 第二个完成处理函数\n  \tconsole.log(value); // 43\n  });\n  ```\n\n  在以上例子中如果p2执行出错的话会导致第二个完成处理函数永不被调用，这是因为在promise链中每当一个promise完成后下一个promise才会被加入作业队列，并且同时会很创建一个新的promise对象获取上一个对象的数据，  因此这以上代码中存在四个promise对象也就是\n\n  ```javascript\n  let p1 = new Promise(function(resolve, reject) {\n  resolve(42);//第一个\n  });\n  let p2 = new Promise(function(resolve, reject) {\n  resolve(43);//第二个\n  });\n  let p3 = p1.then(function(value) {\n  // 第一个完成处理函数\n  console.log(value); // 42\n  return p2;\n  });//第三个\n  \tp3.then(function(value) {\n  // 第二个完成处理函数\n  console.log(value); // 43\n  });//第四个对象\n  ```\n\n  所以当p2报错时p3应当调用的是then()方法的第二个参数也就是拒绝函数而永不调用成功函数\n\n#### 响应多个 Promise\n\n- **Promise.all()**：\n- **Promise.race() 方法**：","slug":"ES6语法总结四(迭代生成器、Promise和异步)","published":1,"updated":"2020-04-22T03:45:08.409Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9cue22x00163gcsdiqdgzax","content":"<h1 id=\"ES6语法总结\"><a href=\"#ES6语法总结\" class=\"headerlink\" title=\"ES6语法总结\"></a>ES6语法总结</h1><h2 id=\"Promise与异步\"><a href=\"#Promise与异步\" class=\"headerlink\" title=\"Promise与异步\"></a>Promise与异步</h2><h3 id=\"Promise诞生的原因\"><a href=\"#Promise诞生的原因\" class=\"headerlink\" title=\"Promise诞生的原因\"></a>Promise诞生的原因</h3><p>前端和后端各种多样化交互才使各种程序拥有了使用的实际价值，而前后端交互绝大部分都属于异步编程，所以了解异步是对于前端来说是异常重要的一步，接下来先看一下传统的异步</p>\n<ul>\n<li><p><strong>传统的异步</strong>：</p>\n<ul>\n<li>事件模型</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> button = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"btn\"</span>);</span><br><span class=\"line\">    button.onclick = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">event</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Clicked\"</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<p>在这段代码中就是事件模型的一种，给id为<code>btn</code>的dom元素绑定了一个点击方法，但是它只会被编译而不会被执行，只有当该元素被点击之后才会js引擎才会把click的方法加入到作业队列的末尾，而所有类似这种绑定特定事件只有在特定条件下才会执行的模式叫做事件模式，这也是异步的一种。</p>\n<ul>\n<li>问题：对于这种模式来说当需要简单的交互时简单好用但是又两个问题<ul>\n<li>每一个事件模型都需要追踪事件对象，有一百个点击事件就要监控一百个对象很麻烦</li>\n<li>未必能够完成绑定因为也可能绑定事件的时候dom还不存在</li>\n</ul>\n</li>\n<li>回调模式</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">readFile(<span class=\"string\">\"example.txt\"</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err, contents</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (err) &#123;</span><br><span class=\"line\">   \t\t <span class=\"keyword\">throw</span> err;</span><br><span class=\"line\">   \t &#125;</span><br><span class=\"line\">   \t\t<span class=\"built_in\">console</span>.log(contents);</span><br><span class=\"line\">   &#125;);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"Hi!\"</span>);</span><br></pre></td></tr></table></figure>\n\n<p><code>readFile()</code> 函数用于读取磁盘中的文件（由第一个参数指定），并在读取完毕后执行回调函数（即第二个参数）。如果存在错误，回调函数的 err 参数会是一个错误对象；否则 contents 参数就会以字符串形式包含文件内容。使用回调函数模式， <code>readFile()</code> 会立即开始执行，并在开始读取磁盘时暂停。这意味着<code>console.log(&quot;Hi!&quot;)</code>会在 <code>readFile()</code> 被调用后立即进行输出，要早于<code>console.log(contents)</code>的打印操作。当 <code>readFile()</code>结束操作后，它会将回调函数以及相关参数作为一个新的作业添加到作业队列的尾部。在之前的作业全部结束后，该作业才会执行,在这种情况下如果要进行异步串联就容易得多，但是会出现<strong>回调地狱</strong>的情况</p>\n</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">method1(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err, result</span>) </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">if</span> (err) &#123;</span><br><span class=\"line\">         <span class=\"keyword\">throw</span> err</span><br><span class=\"line\">       \t &#125;</span><br><span class=\"line\">       method2(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err, result</span>) </span>&#123;</span><br><span class=\"line\">         <span class=\"keyword\">if</span> (err) &#123;</span><br><span class=\"line\">           <span class=\"keyword\">throw</span> err</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">         method3(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err, result</span>) </span>&#123;</span><br><span class=\"line\">           <span class=\"keyword\">if</span> (err) &#123;</span><br><span class=\"line\">             <span class=\"keyword\">throw</span> err</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">           method4(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err, result</span>) </span>&#123;</span><br><span class=\"line\">             <span class=\"keyword\">if</span> (err) &#123;</span><br><span class=\"line\">               <span class=\"keyword\">throw</span> err</span><br><span class=\"line\">             &#125;</span><br><span class=\"line\">             method5(result)</span><br><span class=\"line\">           &#125;)</span><br><span class=\"line\">         &#125;)</span><br><span class=\"line\">       &#125;)</span><br><span class=\"line\">     &#125;)</span><br></pre></td></tr></table></figure>\n\n<p>​    是不是看了就很想死…不但代码复杂高度耦合而且当你需要两个异步并行操作或者想同时开始两个异步的时候就    特别麻烦了，所以才有了Promise</p>\n<ul>\n<li><h3 id=\"Promise\"><a href=\"#Promise\" class=\"headerlink\" title=\"Promise\"></a>Promise</h3><h4 id=\"Promise-生命周期\"><a href=\"#Promise-生命周期\" class=\"headerlink\" title=\"Promise 生命周期\"></a>Promise 生命周期</h4><p><img src=\"/2020/01/20/ES6%E8%AF%AD%E6%B3%95%E6%80%BB%E7%BB%93%E5%9B%9B(%E8%BF%AD%E4%BB%A3%E7%94%9F%E6%88%90%E5%99%A8%E3%80%81Promise%E5%92%8C%E5%BC%82%E6%AD%A5)/Promise%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png\" alt=\"1585030576405\"></p>\n<p>在这里把几个意思都解释一下：</p>\n<ol>\n<li>程序整体状态：<ul>\n<li>unsettled(未决):就是挂起状态，但是这个状态是用来描述程序的整体状况</li>\n<li>settled(已决):程序已经执行完成</li>\n<li>resolve(决议):推进为程序执行状态为已决</li>\n</ul>\n</li>\n<li>程序具体状态:<ul>\n<li>pending(挂起):异步程序尚未结束，等待结果中</li>\n<li>fulfilled(完成):异步程序结束，操作完成</li>\n<li>rejected(拒绝):异步程序结束，操作失败</li>\n</ul>\n</li>\n<li>推进状态操作函数<ul>\n<li>resolve():调用resolve()更改程序状态为已完成</li>\n<li>reject():调用resolve()更改程序状态为已失败</li>\n</ul>\n</li>\n<li>状态完成函数<ul>\n<li>fulfillment handler:成功决议之后调用的函数</li>\n<li>rejection handler :失败之后调用的函数</li>\n</ul>\n</li>\n</ol>\n<p>在以上描述中描述程序具体状态的值会被设置在Promise对象的<code>PromiseState</code>属性中但是这个属性没有暴露所以不能访问，因此才需要<code>.then()</code>方法来对Promise的不同情况进行想要的操作</p>\n<p><strong>then()方法</strong>：</p>\n<p>​    在Promise状态为settled的时候会被调用，接收两个可选参数（都是回调函数的形式）,第一个是成功的回调函数，第二个是失败的回调函数，在失败的时候会默认传递一个包含有错误信息的对象进去。</p>\n<p><strong>catch()方法</strong>:</p>\n<p>​     在这里的<code>promise.catch(function...)</code>&lt;=&gt;<code>promise.then(null,function..)</code>,默认传递rejection handler</p>\n</li>\n</ul>\n<p>​            <strong>当没有写入都有的错误都会静默发生所以最好给promise都写一个默认的日志</strong></p>\n<h4 id=\"创建Promise\"><a href=\"#创建Promise\" class=\"headerlink\" title=\"创建Promise\"></a>创建Promise</h4><h5 id=\"创建未决Promise\"><a href=\"#创建未决Promise\" class=\"headerlink\" title=\"创建未决Promise\"></a>创建未决Promise</h5><p>​    使用 Promise 构造器来创建。此构造器接受单个参数：执行器(executor)函数，包含初始化 Promise 的代码。该执行器会被传递两个名为 resolve()与 reject() 的函数作为参数</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> promise = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"啊啊啊\"</span>);</span><br><span class=\"line\">    resolve();</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(err)&#123;</span><br><span class=\"line\">       reject();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"哦哦哦\"</span>);</span><br><span class=\"line\"><span class=\"comment\">//啊啊啊</span></span><br><span class=\"line\"><span class=\"comment\">//哦哦哦</span></span><br></pre></td></tr></table></figure>\n\n<p>​    构造器会在promise实例化的时候立刻执行。然后才会发生而里面 resolve() 或 reject() 在执行器内部被调用          时，一个作业被添加到作业队列中，以便决议（ resolve ）这个 Promise 。这也称为作业调度( job scheduling )，要注意一下被调度的作业会被放到队列的末尾最后执行</p>\n<h5 id=\"创建已决Promise\"><a href=\"#创建已决Promise\" class=\"headerlink\" title=\"创建已决Promise\"></a>创建已决Promise</h5><p>​    Promise.resolve()和Promise.reject()的使用方式一样的所以只列举一个，另外一个照搬就行了</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> promise = <span class=\"built_in\">Promise</span>.resolve(<span class=\"number\">42</span>);</span><br><span class=\"line\">    promise.then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(value); <span class=\"comment\">// 42</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>​    接受单个参数并返回一个处于完成态的 Promise 。没有任何作业调度会发生，并且需要向 Promise 添加一个或更多的完成处理函数来提取这个参数值。</p>\n<h5 id=\"执行器错误\"><a href=\"#执行器错误\" class=\"headerlink\" title=\"执行器错误\"></a>执行器错误</h5><p>​    如果在执行器内部抛出了错误， Promise 的拒绝处理函数就会被调用，如果没有错误就会静默</p>\n<p>#####全局的 Promise 拒绝处理</p>\n<p>​    Promise有一个问题就是报错静默：当没有指定报错处理时发生的所有错误都不会被暴露和抛出而且你没有什么直观的办法去判断Promise的处理结果，而且你也不知道一个Promise对象什么时候会被处理</p>\n <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> rejected = <span class=\"built_in\">Promise</span>.reject(<span class=\"number\">42</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 一段时间后……</span></span><br><span class=\"line\">\trejected.catch(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\"><span class=\"comment\">// rejected 被处理</span></span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(value);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>​    但是不用担心浏览器已经有了解决方案：</p>\n<p>​    <strong>浏览器的拒绝处理</strong>：</p>\n<p>当有有未处理的拒绝 时window 对象会触发两个事件：            </p>\n<blockquote>\n<p><code>unhandledrejection</code> ：当一个 Promise 被拒绝、而在事件循环的一个轮次中没有任何拒绝处理函数被调用，该事件就会被触发；<br><code>rejectionHandled</code> ：若一个 Promise 被拒绝、并在事件循环的一个轮次之后再有拒绝处理函数被调用，该事件就会被触发。</p>\n</blockquote>\n<p>以上两个浏览器事件的处理函数会接收到含下列属性的一个对象：</p>\n<blockquote>\n<p>type ： 事件的名称（ “unhandledrejection” 或 “rejectionhandled” ）；<br>promise ：被拒绝的 Promise 对象；<br>reason ： Promise 中的拒绝值（拒绝原因）。</p>\n</blockquote>\n<h4 id=\"串联-Promise-Promise链\"><a href=\"#串联-Promise-Promise链\" class=\"headerlink\" title=\"串联 Promise(Promise链)\"></a>串联 Promise(Promise链)</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> p1 = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">\tresolve(<span class=\"number\">42</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">p1.then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(value);</span><br><span class=\"line\">\t&#125;).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(<span class=\"string\">\"Finished\"</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>对 p1.then() 的调用返回了第二个 Promise ，又在这之上调用了 then() 。仅当第一个Promise 已被决议后，第二个 then() 的完成处理函数才会被调用,每一次的加入作业队列时都会新生成一个promise</p>\n<ul>\n<li><p><strong>捕获错误</strong></p>\n<ul>\n<li>Promise 链允许捕获上一个 Promise 的完成或拒绝处理函数中发生的错误</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> p1 = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">\tresolve(<span class=\"number\">42</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">p1.then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">\"Boom!\"</span>);</span><br><span class=\"line\">&#125;).catch(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">error</span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(error.message); <span class=\"comment\">// \"Boom!\"</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>在以上代码中， p1 的完成处理函数抛出了一个错误，链式调用指向了第二个 Promise 上的catch() 方法，能通过此拒绝处理函数接收前面的错误，前面如果是拒绝函数的话也是一样的。</p>\n</li>\n<li><p>在 Promise 链中返回值</p>\n<p>Promise 链的另一重要方面是能从一个 Promise 传递数据给下一个 Promise 的能力。传递给<br>执行器中的 resolve() 处理函数的参数，会被传递给对应 Promise 的完成处理函数，</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> p1 = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">\tresolve(<span class=\"number\">42</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">p1.then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">console</span>.log(value); <span class=\"comment\">// \"42\"</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> value + <span class=\"number\">1</span>;</span><br><span class=\"line\">\t&#125;).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">console</span>.log(value); <span class=\"comment\">// \"43\"</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>p1 的完成处理函数在被执行时返回了 value + 1 。由于 value 的值为 42 （来自执行<br>器），此完成处理函数就返回了 43 。这个值随后被传递给第二个 Promise 的完成处理函数，</p>\n</li>\n<li><p>在 Promise 链中返回 Promise</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> p1 = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">\tresolve(<span class=\"number\">42</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"keyword\">let</span> p2 = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">\tresolve(<span class=\"number\">43</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">p1.then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 第一个完成处理函数</span></span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(value); <span class=\"comment\">// 42</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> p2;</span><br><span class=\"line\">\t&#125;).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 第二个完成处理函数</span></span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(value); <span class=\"comment\">// 43</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>在以上例子中如果p2执行出错的话会导致第二个完成处理函数永不被调用，这是因为在promise链中每当一个promise完成后下一个promise才会被加入作业队列，并且同时会很创建一个新的promise对象获取上一个对象的数据，  因此这以上代码中存在四个promise对象也就是</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> p1 = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">resolve(<span class=\"number\">42</span>);<span class=\"comment\">//第一个</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"keyword\">let</span> p2 = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">resolve(<span class=\"number\">43</span>);<span class=\"comment\">//第二个</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"keyword\">let</span> p3 = p1.then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\"><span class=\"comment\">// 第一个完成处理函数</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(value); <span class=\"comment\">// 42</span></span><br><span class=\"line\"><span class=\"keyword\">return</span> p2;</span><br><span class=\"line\">&#125;);<span class=\"comment\">//第三个</span></span><br><span class=\"line\">\tp3.then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\"><span class=\"comment\">// 第二个完成处理函数</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(value); <span class=\"comment\">// 43</span></span><br><span class=\"line\">&#125;);<span class=\"comment\">//第四个对象</span></span><br></pre></td></tr></table></figure>\n\n<p>所以当p2报错时p3应当调用的是then()方法的第二个参数也就是拒绝函数而永不调用成功函数</p>\n</li>\n</ul>\n<h4 id=\"响应多个-Promise\"><a href=\"#响应多个-Promise\" class=\"headerlink\" title=\"响应多个 Promise\"></a>响应多个 Promise</h4><ul>\n<li><strong>Promise.all()</strong>：</li>\n<li><strong>Promise.race() 方法</strong>：</li>\n</ul>\n","site":{"data":{}},"excerpt":"<h1 id=\"ES6语法总结\"><a href=\"#ES6语法总结\" class=\"headerlink\" title=\"ES6语法总结\"></a>ES6语法总结</h1><h2 id=\"Promise与异步\"><a href=\"#Promise与异步\" class=\"headerlink\" title=\"Promise与异步\"></a>Promise与异步</h2><h3 id=\"Promise诞生的原因\"><a href=\"#Promise诞生的原因\" class=\"headerlink\" title=\"Promise诞生的原因\"></a>Promise诞生的原因</h3><p>前端和后端各种多样化交互才使各种程序拥有了使用的实际价值，而前后端交互绝大部分都属于异步编程，所以了解异步是对于前端来说是异常重要的一步，接下来先看一下传统的异步</p>\n<ul>\n<li><p><strong>传统的异步</strong>：</p>\n<ul>\n<li>事件模型</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> button = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"btn\"</span>);</span><br><span class=\"line\">    button.onclick = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">event</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Clicked\"</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li></ul>","more":"<p>在这段代码中就是事件模型的一种，给id为<code>btn</code>的dom元素绑定了一个点击方法，但是它只会被编译而不会被执行，只有当该元素被点击之后才会js引擎才会把click的方法加入到作业队列的末尾，而所有类似这种绑定特定事件只有在特定条件下才会执行的模式叫做事件模式，这也是异步的一种。</p>\n<ul>\n<li>问题：对于这种模式来说当需要简单的交互时简单好用但是又两个问题<ul>\n<li>每一个事件模型都需要追踪事件对象，有一百个点击事件就要监控一百个对象很麻烦</li>\n<li>未必能够完成绑定因为也可能绑定事件的时候dom还不存在</li>\n</ul>\n</li>\n<li>回调模式</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">readFile(<span class=\"string\">\"example.txt\"</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err, contents</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (err) &#123;</span><br><span class=\"line\">   \t\t <span class=\"keyword\">throw</span> err;</span><br><span class=\"line\">   \t &#125;</span><br><span class=\"line\">   \t\t<span class=\"built_in\">console</span>.log(contents);</span><br><span class=\"line\">   &#125;);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"Hi!\"</span>);</span><br></pre></td></tr></table></figure>\n\n<p><code>readFile()</code> 函数用于读取磁盘中的文件（由第一个参数指定），并在读取完毕后执行回调函数（即第二个参数）。如果存在错误，回调函数的 err 参数会是一个错误对象；否则 contents 参数就会以字符串形式包含文件内容。使用回调函数模式， <code>readFile()</code> 会立即开始执行，并在开始读取磁盘时暂停。这意味着<code>console.log(&quot;Hi!&quot;)</code>会在 <code>readFile()</code> 被调用后立即进行输出，要早于<code>console.log(contents)</code>的打印操作。当 <code>readFile()</code>结束操作后，它会将回调函数以及相关参数作为一个新的作业添加到作业队列的尾部。在之前的作业全部结束后，该作业才会执行,在这种情况下如果要进行异步串联就容易得多，但是会出现<strong>回调地狱</strong>的情况</p>\n\n\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">method1(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err, result</span>) </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">if</span> (err) &#123;</span><br><span class=\"line\">         <span class=\"keyword\">throw</span> err</span><br><span class=\"line\">       \t &#125;</span><br><span class=\"line\">       method2(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err, result</span>) </span>&#123;</span><br><span class=\"line\">         <span class=\"keyword\">if</span> (err) &#123;</span><br><span class=\"line\">           <span class=\"keyword\">throw</span> err</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">         method3(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err, result</span>) </span>&#123;</span><br><span class=\"line\">           <span class=\"keyword\">if</span> (err) &#123;</span><br><span class=\"line\">             <span class=\"keyword\">throw</span> err</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">           method4(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err, result</span>) </span>&#123;</span><br><span class=\"line\">             <span class=\"keyword\">if</span> (err) &#123;</span><br><span class=\"line\">               <span class=\"keyword\">throw</span> err</span><br><span class=\"line\">             &#125;</span><br><span class=\"line\">             method5(result)</span><br><span class=\"line\">           &#125;)</span><br><span class=\"line\">         &#125;)</span><br><span class=\"line\">       &#125;)</span><br><span class=\"line\">     &#125;)</span><br></pre></td></tr></table></figure>\n\n<p>​    是不是看了就很想死…不但代码复杂高度耦合而且当你需要两个异步并行操作或者想同时开始两个异步的时候就    特别麻烦了，所以才有了Promise</p>\n<ul>\n<li><h3 id=\"Promise\"><a href=\"#Promise\" class=\"headerlink\" title=\"Promise\"></a>Promise</h3><h4 id=\"Promise-生命周期\"><a href=\"#Promise-生命周期\" class=\"headerlink\" title=\"Promise 生命周期\"></a>Promise 生命周期</h4><p><img src=\"/2020/01/20/ES6%E8%AF%AD%E6%B3%95%E6%80%BB%E7%BB%93%E5%9B%9B(%E8%BF%AD%E4%BB%A3%E7%94%9F%E6%88%90%E5%99%A8%E3%80%81Promise%E5%92%8C%E5%BC%82%E6%AD%A5)/Promise%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png\" alt=\"1585030576405\"></p>\n<p>在这里把几个意思都解释一下：</p>\n<ol>\n<li>程序整体状态：<ul>\n<li>unsettled(未决):就是挂起状态，但是这个状态是用来描述程序的整体状况</li>\n<li>settled(已决):程序已经执行完成</li>\n<li>resolve(决议):推进为程序执行状态为已决</li>\n</ul>\n</li>\n<li>程序具体状态:<ul>\n<li>pending(挂起):异步程序尚未结束，等待结果中</li>\n<li>fulfilled(完成):异步程序结束，操作完成</li>\n<li>rejected(拒绝):异步程序结束，操作失败</li>\n</ul>\n</li>\n<li>推进状态操作函数<ul>\n<li>resolve():调用resolve()更改程序状态为已完成</li>\n<li>reject():调用resolve()更改程序状态为已失败</li>\n</ul>\n</li>\n<li>状态完成函数<ul>\n<li>fulfillment handler:成功决议之后调用的函数</li>\n<li>rejection handler :失败之后调用的函数</li>\n</ul>\n</li>\n</ol>\n<p>在以上描述中描述程序具体状态的值会被设置在Promise对象的<code>PromiseState</code>属性中但是这个属性没有暴露所以不能访问，因此才需要<code>.then()</code>方法来对Promise的不同情况进行想要的操作</p>\n<p><strong>then()方法</strong>：</p>\n<p>​    在Promise状态为settled的时候会被调用，接收两个可选参数（都是回调函数的形式）,第一个是成功的回调函数，第二个是失败的回调函数，在失败的时候会默认传递一个包含有错误信息的对象进去。</p>\n<p><strong>catch()方法</strong>:</p>\n<p>​     在这里的<code>promise.catch(function...)</code>&lt;=&gt;<code>promise.then(null,function..)</code>,默认传递rejection handler</p>\n</li>\n</ul>\n<p>​            <strong>当没有写入都有的错误都会静默发生所以最好给promise都写一个默认的日志</strong></p>\n<h4 id=\"创建Promise\"><a href=\"#创建Promise\" class=\"headerlink\" title=\"创建Promise\"></a>创建Promise</h4><h5 id=\"创建未决Promise\"><a href=\"#创建未决Promise\" class=\"headerlink\" title=\"创建未决Promise\"></a>创建未决Promise</h5><p>​    使用 Promise 构造器来创建。此构造器接受单个参数：执行器(executor)函数，包含初始化 Promise 的代码。该执行器会被传递两个名为 resolve()与 reject() 的函数作为参数</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> promise = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"啊啊啊\"</span>);</span><br><span class=\"line\">    resolve();</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(err)&#123;</span><br><span class=\"line\">       reject();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"哦哦哦\"</span>);</span><br><span class=\"line\"><span class=\"comment\">//啊啊啊</span></span><br><span class=\"line\"><span class=\"comment\">//哦哦哦</span></span><br></pre></td></tr></table></figure>\n\n<p>​    构造器会在promise实例化的时候立刻执行。然后才会发生而里面 resolve() 或 reject() 在执行器内部被调用          时，一个作业被添加到作业队列中，以便决议（ resolve ）这个 Promise 。这也称为作业调度( job scheduling )，要注意一下被调度的作业会被放到队列的末尾最后执行</p>\n<h5 id=\"创建已决Promise\"><a href=\"#创建已决Promise\" class=\"headerlink\" title=\"创建已决Promise\"></a>创建已决Promise</h5><p>​    Promise.resolve()和Promise.reject()的使用方式一样的所以只列举一个，另外一个照搬就行了</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> promise = <span class=\"built_in\">Promise</span>.resolve(<span class=\"number\">42</span>);</span><br><span class=\"line\">    promise.then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(value); <span class=\"comment\">// 42</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>​    接受单个参数并返回一个处于完成态的 Promise 。没有任何作业调度会发生，并且需要向 Promise 添加一个或更多的完成处理函数来提取这个参数值。</p>\n<h5 id=\"执行器错误\"><a href=\"#执行器错误\" class=\"headerlink\" title=\"执行器错误\"></a>执行器错误</h5><p>​    如果在执行器内部抛出了错误， Promise 的拒绝处理函数就会被调用，如果没有错误就会静默</p>\n<p>#####全局的 Promise 拒绝处理</p>\n<p>​    Promise有一个问题就是报错静默：当没有指定报错处理时发生的所有错误都不会被暴露和抛出而且你没有什么直观的办法去判断Promise的处理结果，而且你也不知道一个Promise对象什么时候会被处理</p>\n <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> rejected = <span class=\"built_in\">Promise</span>.reject(<span class=\"number\">42</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 一段时间后……</span></span><br><span class=\"line\">\trejected.catch(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\"><span class=\"comment\">// rejected 被处理</span></span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(value);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>​    但是不用担心浏览器已经有了解决方案：</p>\n<p>​    <strong>浏览器的拒绝处理</strong>：</p>\n<p>当有有未处理的拒绝 时window 对象会触发两个事件：            </p>\n<blockquote>\n<p><code>unhandledrejection</code> ：当一个 Promise 被拒绝、而在事件循环的一个轮次中没有任何拒绝处理函数被调用，该事件就会被触发；<br><code>rejectionHandled</code> ：若一个 Promise 被拒绝、并在事件循环的一个轮次之后再有拒绝处理函数被调用，该事件就会被触发。</p>\n</blockquote>\n<p>以上两个浏览器事件的处理函数会接收到含下列属性的一个对象：</p>\n<blockquote>\n<p>type ： 事件的名称（ “unhandledrejection” 或 “rejectionhandled” ）；<br>promise ：被拒绝的 Promise 对象；<br>reason ： Promise 中的拒绝值（拒绝原因）。</p>\n</blockquote>\n<h4 id=\"串联-Promise-Promise链\"><a href=\"#串联-Promise-Promise链\" class=\"headerlink\" title=\"串联 Promise(Promise链)\"></a>串联 Promise(Promise链)</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> p1 = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">\tresolve(<span class=\"number\">42</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">p1.then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(value);</span><br><span class=\"line\">\t&#125;).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(<span class=\"string\">\"Finished\"</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>对 p1.then() 的调用返回了第二个 Promise ，又在这之上调用了 then() 。仅当第一个Promise 已被决议后，第二个 then() 的完成处理函数才会被调用,每一次的加入作业队列时都会新生成一个promise</p>\n<ul>\n<li><p><strong>捕获错误</strong></p>\n<ul>\n<li>Promise 链允许捕获上一个 Promise 的完成或拒绝处理函数中发生的错误</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> p1 = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">\tresolve(<span class=\"number\">42</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">p1.then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">\"Boom!\"</span>);</span><br><span class=\"line\">&#125;).catch(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">error</span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(error.message); <span class=\"comment\">// \"Boom!\"</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>在以上代码中， p1 的完成处理函数抛出了一个错误，链式调用指向了第二个 Promise 上的catch() 方法，能通过此拒绝处理函数接收前面的错误，前面如果是拒绝函数的话也是一样的。</p>\n</li>\n<li><p>在 Promise 链中返回值</p>\n<p>Promise 链的另一重要方面是能从一个 Promise 传递数据给下一个 Promise 的能力。传递给<br>执行器中的 resolve() 处理函数的参数，会被传递给对应 Promise 的完成处理函数，</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> p1 = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">\tresolve(<span class=\"number\">42</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">p1.then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">console</span>.log(value); <span class=\"comment\">// \"42\"</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> value + <span class=\"number\">1</span>;</span><br><span class=\"line\">\t&#125;).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">console</span>.log(value); <span class=\"comment\">// \"43\"</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>p1 的完成处理函数在被执行时返回了 value + 1 。由于 value 的值为 42 （来自执行<br>器），此完成处理函数就返回了 43 。这个值随后被传递给第二个 Promise 的完成处理函数，</p>\n</li>\n<li><p>在 Promise 链中返回 Promise</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> p1 = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">\tresolve(<span class=\"number\">42</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"keyword\">let</span> p2 = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">\tresolve(<span class=\"number\">43</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">p1.then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 第一个完成处理函数</span></span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(value); <span class=\"comment\">// 42</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> p2;</span><br><span class=\"line\">\t&#125;).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 第二个完成处理函数</span></span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(value); <span class=\"comment\">// 43</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>在以上例子中如果p2执行出错的话会导致第二个完成处理函数永不被调用，这是因为在promise链中每当一个promise完成后下一个promise才会被加入作业队列，并且同时会很创建一个新的promise对象获取上一个对象的数据，  因此这以上代码中存在四个promise对象也就是</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> p1 = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">resolve(<span class=\"number\">42</span>);<span class=\"comment\">//第一个</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"keyword\">let</span> p2 = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">resolve(<span class=\"number\">43</span>);<span class=\"comment\">//第二个</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"keyword\">let</span> p3 = p1.then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\"><span class=\"comment\">// 第一个完成处理函数</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(value); <span class=\"comment\">// 42</span></span><br><span class=\"line\"><span class=\"keyword\">return</span> p2;</span><br><span class=\"line\">&#125;);<span class=\"comment\">//第三个</span></span><br><span class=\"line\">\tp3.then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\"><span class=\"comment\">// 第二个完成处理函数</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(value); <span class=\"comment\">// 43</span></span><br><span class=\"line\">&#125;);<span class=\"comment\">//第四个对象</span></span><br></pre></td></tr></table></figure>\n\n<p>所以当p2报错时p3应当调用的是then()方法的第二个参数也就是拒绝函数而永不调用成功函数</p>\n</li>\n</ul>\n<h4 id=\"响应多个-Promise\"><a href=\"#响应多个-Promise\" class=\"headerlink\" title=\"响应多个 Promise\"></a>响应多个 Promise</h4><ul>\n<li><strong>Promise.all()</strong>：</li>\n<li><strong>Promise.race() 方法</strong>：</li>\n</ul>"},{"title":"浅谈SVG","date":"2019-12-07T08:14:44.000Z","_content":"\n\n\n# 浅谈SVG\n\n## 一、SVG相关概念\n\n- 什么是SVG\n\n  svg(Scalable Vector Graphic)，是一种可缩放的矢量图形，现在就针对定义来聊聊。\n\n  - 矢量图形和栅格图形\n\n    - 栅格图形\n\n      在这种系统中，图像由一个像素数组组成，这个数组里面的每一个像素都会用图形对应位置的RGB值表示，可以认为在一个图像上划分出N个正方形小方块，每一个小方块的值都等于图像在该位置的颜色，且改颜色用RBG的形式表示\n\n    - 矢量图形\n\n      在这种系统中，图像由一组几何图形的指令组成，矢量阅读器会按照指令在对应的指标集上绘制出一系列对应的图形。可以把图像切割成了N个几何图形，每一个图形都会记录相关的坐标，坐标间的连接顺序，方法等要素从而生成完成这个图形的指令，阅读器就会根据这些指令画出一个个几何图形最后形成完整的图像\n<!--more-->\n  - 可缩放\n\n    其实在上面一点我们就能很清楚的知道矢量图实际上是拿到了画图的指令所以当我们方法缩小的时候其实只是改变了背景画布的大小并不会改变指令，所以阅读器依旧能根据指令绘制出完整的图像\n\n## 二、SVG基本属性\n\n- ### 坐标系统\n\n  坐标系统是svg的基础，只有连接坐标我们才能确定各种图形的定位和属性的值，并通过操作各类标签和坐标实现我们想要的效果\n\n  1. 视口:也就是画布的区域，默认单位为px，可选的单位有：em,ex,px,cm,mm等\n  2. 用户默认坐标系：原点(0,0)在视口坐上角，水平坐标轴(x轴)向右递增，垂直坐标轴(y轴)向下递增\n  3. 为视口指定坐标系(viewbox):在视口中所有单位都默认为px且使用默认坐标系统，但如果需要从新修改坐标系统的话就需要用到viewbox属性，该属性有4个值(最小x坐标，最小y坐标，宽度，高度)\n\n- ### 图形\n\n  - 图形标签\n\n    - 线段(line):使用`<line>`标签，需要制定起止点的x,y坐标，默认单位为坐标系坐标\n    - 矩形(rect):使用`<revt>`标签，需要制定左上角起始点的x,y坐标，宽度(width)和高度(height)\n    - 圆(circle)和椭圆(ellipse):使用`<circle>`标签，需要制定圆心坐标cx,cy，半径(r),若是椭圆还要制定xy的半轴长度rx,ry\n    - 多边形(polygon):使用`<polygon>`标签，这个标签可以组成任意封闭图形只要在points属性制定一系列的点的坐标并用逗号或空格分隔，会根据points各点依次连接并在最后自动重回起点\n    - 折线(polyline):使用`<polyline>`标签，这个标签基本上等同于多边形标签，但有一点不同的是它在画完最后一点时不会重回起点，所以一般用来画不封闭的图形\n\n  - 图形属性：\n\n    - 画笔类\n\n      1. stroke:画笔颜色，默认none\n      2. stroke-width:画笔宽度，默认1\n      3. stroke-opacity:画笔透明度，默认1.0\n      4. stroke-dasharry:用一组的数字制定虚线和间隙的长度，默认none\n      5. stroke-linejoin:图形连接处的形状，默认miter(尖),round(圆滑),bevel(平的)\n\n    - 填充类\n\n      1. fill:制定填充颜色，默认blcak\n      2. fill-opacity:填充透明度，默认1.0\n      3. fill-rule:是否在图形内，当线段有交叉时才有效。默认nonezero\n\n    - 样式类(简单来说SVG标签和HTML的样式使用方法是一样的，只是属性不同而已)\n\n      1. 结构:和HTML标签应用CSS类似\n\n         `stroke:blue;fill:red;`\n\n      2. 内联样式(Style):给标签应用style属性\n\n         ```css\n         <circle cx='10',cy='50',r='10' style=\"fill:red; stroke:blue\">\n         <rect x='10',y='50',width='30' height='40'style=\"fill:red;stroke:blue\" >\n         ```\n\n         \n\n      3. 样式类(Class):给标签应用calss属性，所有带有同名类的标签都会应用同一样式\n\n         ```scss\n         .special{\n             fill:red;\n             stroke:blue\n         }\n         <circle cx='10',cy='50',r='10' class='special'>\n         <rect x='10',y='50',width='30' height='40' class='special'>\n         ```\n\n## 三、 组合与复用\n\n#### \\<g>标签\n\n​\t`<g>`标签会把它所有的子元素都当成一个组合，每个组合都可以有自己的id，title，类似于自定义的标签，这样我们就能够很方便的复用组合好的复杂图形\n\n```xml\n<g id='demo1'>\n\t<circle cx='100' cy='50' r='10'></circle>\n    <polyline points='100 60,100 70,100 80,110 80,100 70'></polyline>\n</g>\n```\n\n\n\n#### \\<use>标签\n\n`<use>`元素在指定对应的值（`xline:href='xx'`）后能够实现类似于复制粘贴的功能,并且需要指定定赋值的样本原点需要移动到的位置，一般和`<g>`组合使用\n\n```xml\t\n<g id='house'>\n    <desc>周家堡</desc>\n    <rect x=\"0\" y=\"40\" width=\"60\" height=\"60\"></rect>\n    <polyline points='0 40,30 0,60 40'></polyline>\n    <polyline points='30 100,30 70,44 70,44 100'></polyline>\n</g>\n<use xline:href='#house' x=\"100\" y=\"100\"></use>\n<use xline:href='#house' x=\"-50\" y=\"-50\"></use>\n```\n\n#### \\<defs>标签\n\n在我们使用`<g>`标签的时候会有一个问题就是只要定义了组合就马上会被创建,而且我们没有办法去对组合的样式进行修改，因此这样一来复用性其实不是很好，这个时候就需要使用`<defs>`标签，我们可以预先在该标签内写好我们想要复用的组合或者图形，他们会被定义但并不会被创建出来，只有当我们使用`<use>`引用时才会被创建，并且能够对模板使用样式\n\n```xml\n<defs>\n<g id='house'>\n    <desc>周家堡</desc>\n    <rect x=\"0\" y=\"40\" width=\"60\" height=\"60\"></rect>\n    <polyline points='0 40,30 0,60 40'></polyline>\n    <polyline points='30 100,30 70,44 70,44 100'></polyline>\n</g>\n</defs>\n<use xline:href='#house' x=\"100\" y=\"100\" style=\"fill:pink;\"></use>//粉色房子\n<use xline:href='#house' x=\"-50\" y=\"-50\" style=\"fill:blue;\"></use>//蓝色房子\n```\n\n### 四、路径\\<Path>\n\n`<path>`标签可以绘制出任意图形，只需要指定一系列的坐标，所有描述属性坐标的数据都放在d属性(data)里面\n\n> 一段path可以有多个绘制组合，也就是说在一个path标签里面可以画出N个任意中断或者连接的的图形，\n>\n> ```xml\n> <path d=\"M 10,20 L10,60 40,45 M60,60 L90,90 60,45\"></path>//绘制出了两个角度\n> ```\n\n##### d(data)属性\n\n**指令**:\n\n**M(moveto)**：d属性必须以此开头,代表的是画笔起始的位置，后面紧接着一个使用逗号或者空格分\t隔符的x,y坐标，M表示绝对位置，m表示相对位置，但是由于m没有参照系所以第一个m也会变成\t绝对位置\n\n**L(Lineto)**:L属性后面也是跟着坐标以逗号或者空格分隔，表示的是画笔移动的目的地坐标，L绝对，l相对(参考的是前一个M的位置，下同不赘述)\n\n**Z(closepath)**:用来关闭当前路径同时开启一个子路径，Z后面不跟坐标且他的大小写效果一模一样，同时Z标签会连接起始点从而形成封闭的图形\n\n**V，H**:用来绘制水平方向(H)和垂直方向(V)的路径，后面只要跟一个目标点的x或y坐标，因为另一个坐标是定死的，大小写情况和其他标签相同\n\n**A(elliptical Arc)**:用来绘制一条到目标点的椭圆弧，有以下参数\n\n1. 起始点坐标，x,y\n2. x轴旋转角度\n3. 圆弧角度是否大于180,0是小于1是大于\n4. 圆弧正负角度0是负角度，1是正角度也就是画笔以逆时针还是顺时针画弧\n5. 终点x,y坐标\n\n**Q、T、C、S**：贝塞尔曲线相关不建议使用（因为太难了我搞不懂...）\n\n### 五、文本\n\n文本标签用来绘制svg图形中的文字\n\n#### \\<text>标签\n\n`<text>`需要制定x,y坐标来作为第一个文字的位置其样式基本属性和css中文字有关的属性基本一样，\n\n属性：\n\n> font-size:字体大小\n>\n> font-style:字体是否倾斜italic(倾斜)，normal\n>\n> text-decoration:是否有下划线none,underline,overline,line-through\n\n#### \\<tspan>标签\n\n我们可以简单的把该标签理解成span，他们都可以嵌入到文本中，在这个标签你可以为它单独定制样式等属性，而且由于是内嵌元素所以也不需要指定坐标\n\n**改变位置的属性**：\n\n​\tdx,dy(水平和垂直方向偏移量):dx,dy的值都是你想偏移的具体数值，且都是相对于原本位置来说\t的，类似于position里面的relative\n\n​\tx,y(绝对定位):这里的xy都是当前文本的绝对位置，类似于`<text>`的xy\n\n> x，y，dx，dy都可以单独或者组合使用，单独使用时其他为指明的值为默认值\n\n#### 文本路径\\<textPath>\n\n这个也是以后可能使用频率很高的属性，这个属性类似于`<path>`标签，让文字按照指定路径排列，\n\n> 使用步骤\n>\n> 1：将文字的显示路径用path预先定义我们想要的path路径一般放在`<defs>`里面\n>\n> 2：定义好\\<text>文本域，在文本里面加入\\<textPath>标签，并且使用`xline:href=xxx`来引用\n>\n> 3.在\\<textPath>标签中定义我们的文字\n\n\n\n","source":"_posts/浅谈SVG.md","raw":"---\ntitle: 浅谈SVG\ndate: 2019-12-07 16:14:44\ntags:\n\t- 前端\n\t- SVG\ncategories:\n\t- web前端\n---\n\n\n\n# 浅谈SVG\n\n## 一、SVG相关概念\n\n- 什么是SVG\n\n  svg(Scalable Vector Graphic)，是一种可缩放的矢量图形，现在就针对定义来聊聊。\n\n  - 矢量图形和栅格图形\n\n    - 栅格图形\n\n      在这种系统中，图像由一个像素数组组成，这个数组里面的每一个像素都会用图形对应位置的RGB值表示，可以认为在一个图像上划分出N个正方形小方块，每一个小方块的值都等于图像在该位置的颜色，且改颜色用RBG的形式表示\n\n    - 矢量图形\n\n      在这种系统中，图像由一组几何图形的指令组成，矢量阅读器会按照指令在对应的指标集上绘制出一系列对应的图形。可以把图像切割成了N个几何图形，每一个图形都会记录相关的坐标，坐标间的连接顺序，方法等要素从而生成完成这个图形的指令，阅读器就会根据这些指令画出一个个几何图形最后形成完整的图像\n<!--more-->\n  - 可缩放\n\n    其实在上面一点我们就能很清楚的知道矢量图实际上是拿到了画图的指令所以当我们方法缩小的时候其实只是改变了背景画布的大小并不会改变指令，所以阅读器依旧能根据指令绘制出完整的图像\n\n## 二、SVG基本属性\n\n- ### 坐标系统\n\n  坐标系统是svg的基础，只有连接坐标我们才能确定各种图形的定位和属性的值，并通过操作各类标签和坐标实现我们想要的效果\n\n  1. 视口:也就是画布的区域，默认单位为px，可选的单位有：em,ex,px,cm,mm等\n  2. 用户默认坐标系：原点(0,0)在视口坐上角，水平坐标轴(x轴)向右递增，垂直坐标轴(y轴)向下递增\n  3. 为视口指定坐标系(viewbox):在视口中所有单位都默认为px且使用默认坐标系统，但如果需要从新修改坐标系统的话就需要用到viewbox属性，该属性有4个值(最小x坐标，最小y坐标，宽度，高度)\n\n- ### 图形\n\n  - 图形标签\n\n    - 线段(line):使用`<line>`标签，需要制定起止点的x,y坐标，默认单位为坐标系坐标\n    - 矩形(rect):使用`<revt>`标签，需要制定左上角起始点的x,y坐标，宽度(width)和高度(height)\n    - 圆(circle)和椭圆(ellipse):使用`<circle>`标签，需要制定圆心坐标cx,cy，半径(r),若是椭圆还要制定xy的半轴长度rx,ry\n    - 多边形(polygon):使用`<polygon>`标签，这个标签可以组成任意封闭图形只要在points属性制定一系列的点的坐标并用逗号或空格分隔，会根据points各点依次连接并在最后自动重回起点\n    - 折线(polyline):使用`<polyline>`标签，这个标签基本上等同于多边形标签，但有一点不同的是它在画完最后一点时不会重回起点，所以一般用来画不封闭的图形\n\n  - 图形属性：\n\n    - 画笔类\n\n      1. stroke:画笔颜色，默认none\n      2. stroke-width:画笔宽度，默认1\n      3. stroke-opacity:画笔透明度，默认1.0\n      4. stroke-dasharry:用一组的数字制定虚线和间隙的长度，默认none\n      5. stroke-linejoin:图形连接处的形状，默认miter(尖),round(圆滑),bevel(平的)\n\n    - 填充类\n\n      1. fill:制定填充颜色，默认blcak\n      2. fill-opacity:填充透明度，默认1.0\n      3. fill-rule:是否在图形内，当线段有交叉时才有效。默认nonezero\n\n    - 样式类(简单来说SVG标签和HTML的样式使用方法是一样的，只是属性不同而已)\n\n      1. 结构:和HTML标签应用CSS类似\n\n         `stroke:blue;fill:red;`\n\n      2. 内联样式(Style):给标签应用style属性\n\n         ```css\n         <circle cx='10',cy='50',r='10' style=\"fill:red; stroke:blue\">\n         <rect x='10',y='50',width='30' height='40'style=\"fill:red;stroke:blue\" >\n         ```\n\n         \n\n      3. 样式类(Class):给标签应用calss属性，所有带有同名类的标签都会应用同一样式\n\n         ```scss\n         .special{\n             fill:red;\n             stroke:blue\n         }\n         <circle cx='10',cy='50',r='10' class='special'>\n         <rect x='10',y='50',width='30' height='40' class='special'>\n         ```\n\n## 三、 组合与复用\n\n#### \\<g>标签\n\n​\t`<g>`标签会把它所有的子元素都当成一个组合，每个组合都可以有自己的id，title，类似于自定义的标签，这样我们就能够很方便的复用组合好的复杂图形\n\n```xml\n<g id='demo1'>\n\t<circle cx='100' cy='50' r='10'></circle>\n    <polyline points='100 60,100 70,100 80,110 80,100 70'></polyline>\n</g>\n```\n\n\n\n#### \\<use>标签\n\n`<use>`元素在指定对应的值（`xline:href='xx'`）后能够实现类似于复制粘贴的功能,并且需要指定定赋值的样本原点需要移动到的位置，一般和`<g>`组合使用\n\n```xml\t\n<g id='house'>\n    <desc>周家堡</desc>\n    <rect x=\"0\" y=\"40\" width=\"60\" height=\"60\"></rect>\n    <polyline points='0 40,30 0,60 40'></polyline>\n    <polyline points='30 100,30 70,44 70,44 100'></polyline>\n</g>\n<use xline:href='#house' x=\"100\" y=\"100\"></use>\n<use xline:href='#house' x=\"-50\" y=\"-50\"></use>\n```\n\n#### \\<defs>标签\n\n在我们使用`<g>`标签的时候会有一个问题就是只要定义了组合就马上会被创建,而且我们没有办法去对组合的样式进行修改，因此这样一来复用性其实不是很好，这个时候就需要使用`<defs>`标签，我们可以预先在该标签内写好我们想要复用的组合或者图形，他们会被定义但并不会被创建出来，只有当我们使用`<use>`引用时才会被创建，并且能够对模板使用样式\n\n```xml\n<defs>\n<g id='house'>\n    <desc>周家堡</desc>\n    <rect x=\"0\" y=\"40\" width=\"60\" height=\"60\"></rect>\n    <polyline points='0 40,30 0,60 40'></polyline>\n    <polyline points='30 100,30 70,44 70,44 100'></polyline>\n</g>\n</defs>\n<use xline:href='#house' x=\"100\" y=\"100\" style=\"fill:pink;\"></use>//粉色房子\n<use xline:href='#house' x=\"-50\" y=\"-50\" style=\"fill:blue;\"></use>//蓝色房子\n```\n\n### 四、路径\\<Path>\n\n`<path>`标签可以绘制出任意图形，只需要指定一系列的坐标，所有描述属性坐标的数据都放在d属性(data)里面\n\n> 一段path可以有多个绘制组合，也就是说在一个path标签里面可以画出N个任意中断或者连接的的图形，\n>\n> ```xml\n> <path d=\"M 10,20 L10,60 40,45 M60,60 L90,90 60,45\"></path>//绘制出了两个角度\n> ```\n\n##### d(data)属性\n\n**指令**:\n\n**M(moveto)**：d属性必须以此开头,代表的是画笔起始的位置，后面紧接着一个使用逗号或者空格分\t隔符的x,y坐标，M表示绝对位置，m表示相对位置，但是由于m没有参照系所以第一个m也会变成\t绝对位置\n\n**L(Lineto)**:L属性后面也是跟着坐标以逗号或者空格分隔，表示的是画笔移动的目的地坐标，L绝对，l相对(参考的是前一个M的位置，下同不赘述)\n\n**Z(closepath)**:用来关闭当前路径同时开启一个子路径，Z后面不跟坐标且他的大小写效果一模一样，同时Z标签会连接起始点从而形成封闭的图形\n\n**V，H**:用来绘制水平方向(H)和垂直方向(V)的路径，后面只要跟一个目标点的x或y坐标，因为另一个坐标是定死的，大小写情况和其他标签相同\n\n**A(elliptical Arc)**:用来绘制一条到目标点的椭圆弧，有以下参数\n\n1. 起始点坐标，x,y\n2. x轴旋转角度\n3. 圆弧角度是否大于180,0是小于1是大于\n4. 圆弧正负角度0是负角度，1是正角度也就是画笔以逆时针还是顺时针画弧\n5. 终点x,y坐标\n\n**Q、T、C、S**：贝塞尔曲线相关不建议使用（因为太难了我搞不懂...）\n\n### 五、文本\n\n文本标签用来绘制svg图形中的文字\n\n#### \\<text>标签\n\n`<text>`需要制定x,y坐标来作为第一个文字的位置其样式基本属性和css中文字有关的属性基本一样，\n\n属性：\n\n> font-size:字体大小\n>\n> font-style:字体是否倾斜italic(倾斜)，normal\n>\n> text-decoration:是否有下划线none,underline,overline,line-through\n\n#### \\<tspan>标签\n\n我们可以简单的把该标签理解成span，他们都可以嵌入到文本中，在这个标签你可以为它单独定制样式等属性，而且由于是内嵌元素所以也不需要指定坐标\n\n**改变位置的属性**：\n\n​\tdx,dy(水平和垂直方向偏移量):dx,dy的值都是你想偏移的具体数值，且都是相对于原本位置来说\t的，类似于position里面的relative\n\n​\tx,y(绝对定位):这里的xy都是当前文本的绝对位置，类似于`<text>`的xy\n\n> x，y，dx，dy都可以单独或者组合使用，单独使用时其他为指明的值为默认值\n\n#### 文本路径\\<textPath>\n\n这个也是以后可能使用频率很高的属性，这个属性类似于`<path>`标签，让文字按照指定路径排列，\n\n> 使用步骤\n>\n> 1：将文字的显示路径用path预先定义我们想要的path路径一般放在`<defs>`里面\n>\n> 2：定义好\\<text>文本域，在文本里面加入\\<textPath>标签，并且使用`xline:href=xxx`来引用\n>\n> 3.在\\<textPath>标签中定义我们的文字\n\n\n\n","slug":"浅谈SVG","published":1,"updated":"2020-04-16T11:42:49.723Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9cue22y00183gcs16jl49dc","content":"<h1 id=\"浅谈SVG\"><a href=\"#浅谈SVG\" class=\"headerlink\" title=\"浅谈SVG\"></a>浅谈SVG</h1><h2 id=\"一、SVG相关概念\"><a href=\"#一、SVG相关概念\" class=\"headerlink\" title=\"一、SVG相关概念\"></a>一、SVG相关概念</h2><ul>\n<li><p>什么是SVG</p>\n<p>svg(Scalable Vector Graphic)，是一种可缩放的矢量图形，现在就针对定义来聊聊。</p>\n<ul>\n<li><p>矢量图形和栅格图形</p>\n<ul>\n<li><p>栅格图形</p>\n<p>在这种系统中，图像由一个像素数组组成，这个数组里面的每一个像素都会用图形对应位置的RGB值表示，可以认为在一个图像上划分出N个正方形小方块，每一个小方块的值都等于图像在该位置的颜色，且改颜色用RBG的形式表示</p>\n</li>\n<li><p>矢量图形</p>\n<p>在这种系统中，图像由一组几何图形的指令组成，矢量阅读器会按照指令在对应的指标集上绘制出一系列对应的图形。可以把图像切割成了N个几何图形，每一个图形都会记录相关的坐标，坐标间的连接顺序，方法等要素从而生成完成这个图形的指令，阅读器就会根据这些指令画出一个个几何图形最后形成完整的图像</p>\n<a id=\"more\"></a></li>\n</ul>\n</li>\n<li><p>可缩放</p>\n<p>其实在上面一点我们就能很清楚的知道矢量图实际上是拿到了画图的指令所以当我们方法缩小的时候其实只是改变了背景画布的大小并不会改变指令，所以阅读器依旧能根据指令绘制出完整的图像</p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"二、SVG基本属性\"><a href=\"#二、SVG基本属性\" class=\"headerlink\" title=\"二、SVG基本属性\"></a>二、SVG基本属性</h2><ul>\n<li><h3 id=\"坐标系统\"><a href=\"#坐标系统\" class=\"headerlink\" title=\"坐标系统\"></a>坐标系统</h3><p>坐标系统是svg的基础，只有连接坐标我们才能确定各种图形的定位和属性的值，并通过操作各类标签和坐标实现我们想要的效果</p>\n<ol>\n<li>视口:也就是画布的区域，默认单位为px，可选的单位有：em,ex,px,cm,mm等</li>\n<li>用户默认坐标系：原点(0,0)在视口坐上角，水平坐标轴(x轴)向右递增，垂直坐标轴(y轴)向下递增</li>\n<li>为视口指定坐标系(viewbox):在视口中所有单位都默认为px且使用默认坐标系统，但如果需要从新修改坐标系统的话就需要用到viewbox属性，该属性有4个值(最小x坐标，最小y坐标，宽度，高度)</li>\n</ol>\n</li>\n<li><h3 id=\"图形\"><a href=\"#图形\" class=\"headerlink\" title=\"图形\"></a>图形</h3><ul>\n<li><p>图形标签</p>\n<ul>\n<li>线段(line):使用<code>&lt;line&gt;</code>标签，需要制定起止点的x,y坐标，默认单位为坐标系坐标</li>\n<li>矩形(rect):使用<code>&lt;revt&gt;</code>标签，需要制定左上角起始点的x,y坐标，宽度(width)和高度(height)</li>\n<li>圆(circle)和椭圆(ellipse):使用<code>&lt;circle&gt;</code>标签，需要制定圆心坐标cx,cy，半径(r),若是椭圆还要制定xy的半轴长度rx,ry</li>\n<li>多边形(polygon):使用<code>&lt;polygon&gt;</code>标签，这个标签可以组成任意封闭图形只要在points属性制定一系列的点的坐标并用逗号或空格分隔，会根据points各点依次连接并在最后自动重回起点</li>\n<li>折线(polyline):使用<code>&lt;polyline&gt;</code>标签，这个标签基本上等同于多边形标签，但有一点不同的是它在画完最后一点时不会重回起点，所以一般用来画不封闭的图形</li>\n</ul>\n</li>\n<li><p>图形属性：</p>\n<ul>\n<li><p>画笔类</p>\n<ol>\n<li>stroke:画笔颜色，默认none</li>\n<li>stroke-width:画笔宽度，默认1</li>\n<li>stroke-opacity:画笔透明度，默认1.0</li>\n<li>stroke-dasharry:用一组的数字制定虚线和间隙的长度，默认none</li>\n<li>stroke-linejoin:图形连接处的形状，默认miter(尖),round(圆滑),bevel(平的)</li>\n</ol>\n</li>\n<li><p>填充类</p>\n<ol>\n<li>fill:制定填充颜色，默认blcak</li>\n<li>fill-opacity:填充透明度，默认1.0</li>\n<li>fill-rule:是否在图形内，当线段有交叉时才有效。默认nonezero</li>\n</ol>\n</li>\n<li><p>样式类(简单来说SVG标签和HTML的样式使用方法是一样的，只是属性不同而已)</p>\n<ol>\n<li><p>结构:和HTML标签应用CSS类似</p>\n<p><code>stroke:blue;fill:red;</code></p>\n</li>\n<li><p>内联样式(Style):给标签应用style属性</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;circle cx='10',cy='50',r='10' style=\"fill:red; stroke:blue\"&gt;</span><br><span class=\"line\">&lt;rect x='10',y='50',width='30' height='40'style=\"fill:red;stroke:blue\" &gt;</span><br></pre></td></tr></table></figure>\n\n\n\n</li>\n</ol>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<pre><code>3. 样式类(Class):给标签应用calss属性，所有带有同名类的标签都会应用同一样式\n\n   <figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.special</span>&#123;</span><br><span class=\"line\">    fill:red;</span><br><span class=\"line\">    stroke:blue</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;circle cx=<span class=\"string\">'10'</span>,cy=<span class=\"string\">'50'</span>,r=<span class=\"string\">'10'</span> class=<span class=\"string\">'special'</span>&gt;</span><br><span class=\"line\">&lt;rect x=<span class=\"string\">'10'</span>,y=<span class=\"string\">'50'</span>,width=<span class=\"string\">'30'</span> height=<span class=\"string\">'40'</span> class=<span class=\"string\">'special'</span>&gt;</span><br></pre></td></tr></table></figure></code></pre><h2 id=\"三、-组合与复用\"><a href=\"#三、-组合与复用\" class=\"headerlink\" title=\"三、 组合与复用\"></a>三、 组合与复用</h2><h4 id=\"lt-g-gt-标签\"><a href=\"#lt-g-gt-标签\" class=\"headerlink\" title=\"&lt;g&gt;标签\"></a>&lt;g&gt;标签</h4><p>​    <code>&lt;g&gt;</code>标签会把它所有的子元素都当成一个组合，每个组合都可以有自己的id，title，类似于自定义的标签，这样我们就能够很方便的复用组合好的复杂图形</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">g</span> <span class=\"attr\">id</span>=<span class=\"string\">'demo1'</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">circle</span> <span class=\"attr\">cx</span>=<span class=\"string\">'100'</span> <span class=\"attr\">cy</span>=<span class=\"string\">'50'</span> <span class=\"attr\">r</span>=<span class=\"string\">'10'</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">circle</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">polyline</span> <span class=\"attr\">points</span>=<span class=\"string\">'100 60,100 70,100 80,110 80,100 70'</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">polyline</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">g</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"lt-use-gt-标签\"><a href=\"#lt-use-gt-标签\" class=\"headerlink\" title=\"&lt;use&gt;标签\"></a>&lt;use&gt;标签</h4><p><code>&lt;use&gt;</code>元素在指定对应的值（<code>xline:href=&#39;xx&#39;</code>）后能够实现类似于复制粘贴的功能,并且需要指定定赋值的样本原点需要移动到的位置，一般和<code>&lt;g&gt;</code>组合使用</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">g</span> <span class=\"attr\">id</span>=<span class=\"string\">'house'</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">desc</span>&gt;</span>周家堡<span class=\"tag\">&lt;/<span class=\"name\">desc</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">rect</span> <span class=\"attr\">x</span>=<span class=\"string\">\"0\"</span> <span class=\"attr\">y</span>=<span class=\"string\">\"40\"</span> <span class=\"attr\">width</span>=<span class=\"string\">\"60\"</span> <span class=\"attr\">height</span>=<span class=\"string\">\"60\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">rect</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">polyline</span> <span class=\"attr\">points</span>=<span class=\"string\">'0 40,30 0,60 40'</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">polyline</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">polyline</span> <span class=\"attr\">points</span>=<span class=\"string\">'30 100,30 70,44 70,44 100'</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">polyline</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">g</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">use</span> <span class=\"attr\">xline:href</span>=<span class=\"string\">'#house'</span> <span class=\"attr\">x</span>=<span class=\"string\">\"100\"</span> <span class=\"attr\">y</span>=<span class=\"string\">\"100\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">use</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">use</span> <span class=\"attr\">xline:href</span>=<span class=\"string\">'#house'</span> <span class=\"attr\">x</span>=<span class=\"string\">\"-50\"</span> <span class=\"attr\">y</span>=<span class=\"string\">\"-50\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">use</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"lt-defs-gt-标签\"><a href=\"#lt-defs-gt-标签\" class=\"headerlink\" title=\"&lt;defs&gt;标签\"></a>&lt;defs&gt;标签</h4><p>在我们使用<code>&lt;g&gt;</code>标签的时候会有一个问题就是只要定义了组合就马上会被创建,而且我们没有办法去对组合的样式进行修改，因此这样一来复用性其实不是很好，这个时候就需要使用<code>&lt;defs&gt;</code>标签，我们可以预先在该标签内写好我们想要复用的组合或者图形，他们会被定义但并不会被创建出来，只有当我们使用<code>&lt;use&gt;</code>引用时才会被创建，并且能够对模板使用样式</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">defs</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">g</span> <span class=\"attr\">id</span>=<span class=\"string\">'house'</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">desc</span>&gt;</span>周家堡<span class=\"tag\">&lt;/<span class=\"name\">desc</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">rect</span> <span class=\"attr\">x</span>=<span class=\"string\">\"0\"</span> <span class=\"attr\">y</span>=<span class=\"string\">\"40\"</span> <span class=\"attr\">width</span>=<span class=\"string\">\"60\"</span> <span class=\"attr\">height</span>=<span class=\"string\">\"60\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">rect</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">polyline</span> <span class=\"attr\">points</span>=<span class=\"string\">'0 40,30 0,60 40'</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">polyline</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">polyline</span> <span class=\"attr\">points</span>=<span class=\"string\">'30 100,30 70,44 70,44 100'</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">polyline</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">g</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">defs</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">use</span> <span class=\"attr\">xline:href</span>=<span class=\"string\">'#house'</span> <span class=\"attr\">x</span>=<span class=\"string\">\"100\"</span> <span class=\"attr\">y</span>=<span class=\"string\">\"100\"</span> <span class=\"attr\">style</span>=<span class=\"string\">\"fill:pink;\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">use</span>&gt;</span>//粉色房子</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">use</span> <span class=\"attr\">xline:href</span>=<span class=\"string\">'#house'</span> <span class=\"attr\">x</span>=<span class=\"string\">\"-50\"</span> <span class=\"attr\">y</span>=<span class=\"string\">\"-50\"</span> <span class=\"attr\">style</span>=<span class=\"string\">\"fill:blue;\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">use</span>&gt;</span>//蓝色房子</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"四、路径-lt-Path-gt\"><a href=\"#四、路径-lt-Path-gt\" class=\"headerlink\" title=\"四、路径&lt;Path&gt;\"></a>四、路径&lt;Path&gt;</h3><p><code>&lt;path&gt;</code>标签可以绘制出任意图形，只需要指定一系列的坐标，所有描述属性坐标的数据都放在d属性(data)里面</p>\n<blockquote>\n<p>一段path可以有多个绘制组合，也就是说在一个path标签里面可以画出N个任意中断或者连接的的图形，</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">path</span> <span class=\"attr\">d</span>=<span class=\"string\">\"M 10,20 L10,60 40,45 M60,60 L90,90 60,45\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">path</span>&gt;</span>//绘制出了两个角度</span><br></pre></td></tr></table></figure>\n</blockquote>\n<h5 id=\"d-data-属性\"><a href=\"#d-data-属性\" class=\"headerlink\" title=\"d(data)属性\"></a>d(data)属性</h5><p><strong>指令</strong>:</p>\n<p><strong>M(moveto)</strong>：d属性必须以此开头,代表的是画笔起始的位置，后面紧接着一个使用逗号或者空格分    隔符的x,y坐标，M表示绝对位置，m表示相对位置，但是由于m没有参照系所以第一个m也会变成    绝对位置</p>\n<p><strong>L(Lineto)</strong>:L属性后面也是跟着坐标以逗号或者空格分隔，表示的是画笔移动的目的地坐标，L绝对，l相对(参考的是前一个M的位置，下同不赘述)</p>\n<p><strong>Z(closepath)</strong>:用来关闭当前路径同时开启一个子路径，Z后面不跟坐标且他的大小写效果一模一样，同时Z标签会连接起始点从而形成封闭的图形</p>\n<p><strong>V，H</strong>:用来绘制水平方向(H)和垂直方向(V)的路径，后面只要跟一个目标点的x或y坐标，因为另一个坐标是定死的，大小写情况和其他标签相同</p>\n<p><strong>A(elliptical Arc)</strong>:用来绘制一条到目标点的椭圆弧，有以下参数</p>\n<ol>\n<li>起始点坐标，x,y</li>\n<li>x轴旋转角度</li>\n<li>圆弧角度是否大于180,0是小于1是大于</li>\n<li>圆弧正负角度0是负角度，1是正角度也就是画笔以逆时针还是顺时针画弧</li>\n<li>终点x,y坐标</li>\n</ol>\n<p><strong>Q、T、C、S</strong>：贝塞尔曲线相关不建议使用（因为太难了我搞不懂…）</p>\n<h3 id=\"五、文本\"><a href=\"#五、文本\" class=\"headerlink\" title=\"五、文本\"></a>五、文本</h3><p>文本标签用来绘制svg图形中的文字</p>\n<h4 id=\"lt-text-gt-标签\"><a href=\"#lt-text-gt-标签\" class=\"headerlink\" title=\"&lt;text&gt;标签\"></a>&lt;text&gt;标签</h4><p><code>&lt;text&gt;</code>需要制定x,y坐标来作为第一个文字的位置其样式基本属性和css中文字有关的属性基本一样，</p>\n<p>属性：</p>\n<blockquote>\n<p>font-size:字体大小</p>\n<p>font-style:字体是否倾斜italic(倾斜)，normal</p>\n<p>text-decoration:是否有下划线none,underline,overline,line-through</p>\n</blockquote>\n<h4 id=\"lt-tspan-gt-标签\"><a href=\"#lt-tspan-gt-标签\" class=\"headerlink\" title=\"&lt;tspan&gt;标签\"></a>&lt;tspan&gt;标签</h4><p>我们可以简单的把该标签理解成span，他们都可以嵌入到文本中，在这个标签你可以为它单独定制样式等属性，而且由于是内嵌元素所以也不需要指定坐标</p>\n<p><strong>改变位置的属性</strong>：</p>\n<p>​    dx,dy(水平和垂直方向偏移量):dx,dy的值都是你想偏移的具体数值，且都是相对于原本位置来说    的，类似于position里面的relative</p>\n<p>​    x,y(绝对定位):这里的xy都是当前文本的绝对位置，类似于<code>&lt;text&gt;</code>的xy</p>\n<blockquote>\n<p>x，y，dx，dy都可以单独或者组合使用，单独使用时其他为指明的值为默认值</p>\n</blockquote>\n<h4 id=\"文本路径-lt-textPath-gt\"><a href=\"#文本路径-lt-textPath-gt\" class=\"headerlink\" title=\"文本路径&lt;textPath&gt;\"></a>文本路径&lt;textPath&gt;</h4><p>这个也是以后可能使用频率很高的属性，这个属性类似于<code>&lt;path&gt;</code>标签，让文字按照指定路径排列，</p>\n<blockquote>\n<p>使用步骤</p>\n<p>1：将文字的显示路径用path预先定义我们想要的path路径一般放在<code>&lt;defs&gt;</code>里面</p>\n<p>2：定义好&lt;text&gt;文本域，在文本里面加入&lt;textPath&gt;标签，并且使用<code>xline:href=xxx</code>来引用</p>\n<p>3.在&lt;textPath&gt;标签中定义我们的文字</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<h1 id=\"浅谈SVG\"><a href=\"#浅谈SVG\" class=\"headerlink\" title=\"浅谈SVG\"></a>浅谈SVG</h1><h2 id=\"一、SVG相关概念\"><a href=\"#一、SVG相关概念\" class=\"headerlink\" title=\"一、SVG相关概念\"></a>一、SVG相关概念</h2><ul>\n<li><p>什么是SVG</p>\n<p>svg(Scalable Vector Graphic)，是一种可缩放的矢量图形，现在就针对定义来聊聊。</p>\n<ul>\n<li><p>矢量图形和栅格图形</p>\n<ul>\n<li><p>栅格图形</p>\n<p>在这种系统中，图像由一个像素数组组成，这个数组里面的每一个像素都会用图形对应位置的RGB值表示，可以认为在一个图像上划分出N个正方形小方块，每一个小方块的值都等于图像在该位置的颜色，且改颜色用RBG的形式表示</p>\n</li>\n<li><p>矢量图形</p>\n<p>在这种系统中，图像由一组几何图形的指令组成，矢量阅读器会按照指令在对应的指标集上绘制出一系列对应的图形。可以把图像切割成了N个几何图形，每一个图形都会记录相关的坐标，坐标间的连接顺序，方法等要素从而生成完成这个图形的指令，阅读器就会根据这些指令画出一个个几何图形最后形成完整的图像</p></li></ul></li></ul></li></ul>","more":"\n\n\n<li><p>可缩放</p>\n<p>其实在上面一点我们就能很清楚的知道矢量图实际上是拿到了画图的指令所以当我们方法缩小的时候其实只是改变了背景画布的大小并不会改变指令，所以阅读器依旧能根据指令绘制出完整的图像</p>\n</li>\n\n\n\n<h2 id=\"二、SVG基本属性\"><a href=\"#二、SVG基本属性\" class=\"headerlink\" title=\"二、SVG基本属性\"></a>二、SVG基本属性</h2><ul>\n<li><h3 id=\"坐标系统\"><a href=\"#坐标系统\" class=\"headerlink\" title=\"坐标系统\"></a>坐标系统</h3><p>坐标系统是svg的基础，只有连接坐标我们才能确定各种图形的定位和属性的值，并通过操作各类标签和坐标实现我们想要的效果</p>\n<ol>\n<li>视口:也就是画布的区域，默认单位为px，可选的单位有：em,ex,px,cm,mm等</li>\n<li>用户默认坐标系：原点(0,0)在视口坐上角，水平坐标轴(x轴)向右递增，垂直坐标轴(y轴)向下递增</li>\n<li>为视口指定坐标系(viewbox):在视口中所有单位都默认为px且使用默认坐标系统，但如果需要从新修改坐标系统的话就需要用到viewbox属性，该属性有4个值(最小x坐标，最小y坐标，宽度，高度)</li>\n</ol>\n</li>\n<li><h3 id=\"图形\"><a href=\"#图形\" class=\"headerlink\" title=\"图形\"></a>图形</h3><ul>\n<li><p>图形标签</p>\n<ul>\n<li>线段(line):使用<code>&lt;line&gt;</code>标签，需要制定起止点的x,y坐标，默认单位为坐标系坐标</li>\n<li>矩形(rect):使用<code>&lt;revt&gt;</code>标签，需要制定左上角起始点的x,y坐标，宽度(width)和高度(height)</li>\n<li>圆(circle)和椭圆(ellipse):使用<code>&lt;circle&gt;</code>标签，需要制定圆心坐标cx,cy，半径(r),若是椭圆还要制定xy的半轴长度rx,ry</li>\n<li>多边形(polygon):使用<code>&lt;polygon&gt;</code>标签，这个标签可以组成任意封闭图形只要在points属性制定一系列的点的坐标并用逗号或空格分隔，会根据points各点依次连接并在最后自动重回起点</li>\n<li>折线(polyline):使用<code>&lt;polyline&gt;</code>标签，这个标签基本上等同于多边形标签，但有一点不同的是它在画完最后一点时不会重回起点，所以一般用来画不封闭的图形</li>\n</ul>\n</li>\n<li><p>图形属性：</p>\n<ul>\n<li><p>画笔类</p>\n<ol>\n<li>stroke:画笔颜色，默认none</li>\n<li>stroke-width:画笔宽度，默认1</li>\n<li>stroke-opacity:画笔透明度，默认1.0</li>\n<li>stroke-dasharry:用一组的数字制定虚线和间隙的长度，默认none</li>\n<li>stroke-linejoin:图形连接处的形状，默认miter(尖),round(圆滑),bevel(平的)</li>\n</ol>\n</li>\n<li><p>填充类</p>\n<ol>\n<li>fill:制定填充颜色，默认blcak</li>\n<li>fill-opacity:填充透明度，默认1.0</li>\n<li>fill-rule:是否在图形内，当线段有交叉时才有效。默认nonezero</li>\n</ol>\n</li>\n<li><p>样式类(简单来说SVG标签和HTML的样式使用方法是一样的，只是属性不同而已)</p>\n<ol>\n<li><p>结构:和HTML标签应用CSS类似</p>\n<p><code>stroke:blue;fill:red;</code></p>\n</li>\n<li><p>内联样式(Style):给标签应用style属性</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;circle cx='10',cy='50',r='10' style=\"fill:red; stroke:blue\"&gt;</span><br><span class=\"line\">&lt;rect x='10',y='50',width='30' height='40'style=\"fill:red;stroke:blue\" &gt;</span><br></pre></td></tr></table></figure>\n\n\n\n</li>\n</ol>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<pre><code>3. 样式类(Class):给标签应用calss属性，所有带有同名类的标签都会应用同一样式\n\n   <figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.special</span>&#123;</span><br><span class=\"line\">    fill:red;</span><br><span class=\"line\">    stroke:blue</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;circle cx=<span class=\"string\">'10'</span>,cy=<span class=\"string\">'50'</span>,r=<span class=\"string\">'10'</span> class=<span class=\"string\">'special'</span>&gt;</span><br><span class=\"line\">&lt;rect x=<span class=\"string\">'10'</span>,y=<span class=\"string\">'50'</span>,width=<span class=\"string\">'30'</span> height=<span class=\"string\">'40'</span> class=<span class=\"string\">'special'</span>&gt;</span><br></pre></td></tr></table></figure></code></pre><h2 id=\"三、-组合与复用\"><a href=\"#三、-组合与复用\" class=\"headerlink\" title=\"三、 组合与复用\"></a>三、 组合与复用</h2><h4 id=\"lt-g-gt-标签\"><a href=\"#lt-g-gt-标签\" class=\"headerlink\" title=\"&lt;g&gt;标签\"></a>&lt;g&gt;标签</h4><p>​    <code>&lt;g&gt;</code>标签会把它所有的子元素都当成一个组合，每个组合都可以有自己的id，title，类似于自定义的标签，这样我们就能够很方便的复用组合好的复杂图形</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">g</span> <span class=\"attr\">id</span>=<span class=\"string\">'demo1'</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">circle</span> <span class=\"attr\">cx</span>=<span class=\"string\">'100'</span> <span class=\"attr\">cy</span>=<span class=\"string\">'50'</span> <span class=\"attr\">r</span>=<span class=\"string\">'10'</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">circle</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">polyline</span> <span class=\"attr\">points</span>=<span class=\"string\">'100 60,100 70,100 80,110 80,100 70'</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">polyline</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">g</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"lt-use-gt-标签\"><a href=\"#lt-use-gt-标签\" class=\"headerlink\" title=\"&lt;use&gt;标签\"></a>&lt;use&gt;标签</h4><p><code>&lt;use&gt;</code>元素在指定对应的值（<code>xline:href=&#39;xx&#39;</code>）后能够实现类似于复制粘贴的功能,并且需要指定定赋值的样本原点需要移动到的位置，一般和<code>&lt;g&gt;</code>组合使用</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">g</span> <span class=\"attr\">id</span>=<span class=\"string\">'house'</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">desc</span>&gt;</span>周家堡<span class=\"tag\">&lt;/<span class=\"name\">desc</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">rect</span> <span class=\"attr\">x</span>=<span class=\"string\">\"0\"</span> <span class=\"attr\">y</span>=<span class=\"string\">\"40\"</span> <span class=\"attr\">width</span>=<span class=\"string\">\"60\"</span> <span class=\"attr\">height</span>=<span class=\"string\">\"60\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">rect</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">polyline</span> <span class=\"attr\">points</span>=<span class=\"string\">'0 40,30 0,60 40'</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">polyline</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">polyline</span> <span class=\"attr\">points</span>=<span class=\"string\">'30 100,30 70,44 70,44 100'</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">polyline</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">g</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">use</span> <span class=\"attr\">xline:href</span>=<span class=\"string\">'#house'</span> <span class=\"attr\">x</span>=<span class=\"string\">\"100\"</span> <span class=\"attr\">y</span>=<span class=\"string\">\"100\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">use</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">use</span> <span class=\"attr\">xline:href</span>=<span class=\"string\">'#house'</span> <span class=\"attr\">x</span>=<span class=\"string\">\"-50\"</span> <span class=\"attr\">y</span>=<span class=\"string\">\"-50\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">use</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"lt-defs-gt-标签\"><a href=\"#lt-defs-gt-标签\" class=\"headerlink\" title=\"&lt;defs&gt;标签\"></a>&lt;defs&gt;标签</h4><p>在我们使用<code>&lt;g&gt;</code>标签的时候会有一个问题就是只要定义了组合就马上会被创建,而且我们没有办法去对组合的样式进行修改，因此这样一来复用性其实不是很好，这个时候就需要使用<code>&lt;defs&gt;</code>标签，我们可以预先在该标签内写好我们想要复用的组合或者图形，他们会被定义但并不会被创建出来，只有当我们使用<code>&lt;use&gt;</code>引用时才会被创建，并且能够对模板使用样式</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">defs</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">g</span> <span class=\"attr\">id</span>=<span class=\"string\">'house'</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">desc</span>&gt;</span>周家堡<span class=\"tag\">&lt;/<span class=\"name\">desc</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">rect</span> <span class=\"attr\">x</span>=<span class=\"string\">\"0\"</span> <span class=\"attr\">y</span>=<span class=\"string\">\"40\"</span> <span class=\"attr\">width</span>=<span class=\"string\">\"60\"</span> <span class=\"attr\">height</span>=<span class=\"string\">\"60\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">rect</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">polyline</span> <span class=\"attr\">points</span>=<span class=\"string\">'0 40,30 0,60 40'</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">polyline</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">polyline</span> <span class=\"attr\">points</span>=<span class=\"string\">'30 100,30 70,44 70,44 100'</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">polyline</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">g</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">defs</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">use</span> <span class=\"attr\">xline:href</span>=<span class=\"string\">'#house'</span> <span class=\"attr\">x</span>=<span class=\"string\">\"100\"</span> <span class=\"attr\">y</span>=<span class=\"string\">\"100\"</span> <span class=\"attr\">style</span>=<span class=\"string\">\"fill:pink;\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">use</span>&gt;</span>//粉色房子</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">use</span> <span class=\"attr\">xline:href</span>=<span class=\"string\">'#house'</span> <span class=\"attr\">x</span>=<span class=\"string\">\"-50\"</span> <span class=\"attr\">y</span>=<span class=\"string\">\"-50\"</span> <span class=\"attr\">style</span>=<span class=\"string\">\"fill:blue;\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">use</span>&gt;</span>//蓝色房子</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"四、路径-lt-Path-gt\"><a href=\"#四、路径-lt-Path-gt\" class=\"headerlink\" title=\"四、路径&lt;Path&gt;\"></a>四、路径&lt;Path&gt;</h3><p><code>&lt;path&gt;</code>标签可以绘制出任意图形，只需要指定一系列的坐标，所有描述属性坐标的数据都放在d属性(data)里面</p>\n<blockquote>\n<p>一段path可以有多个绘制组合，也就是说在一个path标签里面可以画出N个任意中断或者连接的的图形，</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">path</span> <span class=\"attr\">d</span>=<span class=\"string\">\"M 10,20 L10,60 40,45 M60,60 L90,90 60,45\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">path</span>&gt;</span>//绘制出了两个角度</span><br></pre></td></tr></table></figure>\n</blockquote>\n<h5 id=\"d-data-属性\"><a href=\"#d-data-属性\" class=\"headerlink\" title=\"d(data)属性\"></a>d(data)属性</h5><p><strong>指令</strong>:</p>\n<p><strong>M(moveto)</strong>：d属性必须以此开头,代表的是画笔起始的位置，后面紧接着一个使用逗号或者空格分    隔符的x,y坐标，M表示绝对位置，m表示相对位置，但是由于m没有参照系所以第一个m也会变成    绝对位置</p>\n<p><strong>L(Lineto)</strong>:L属性后面也是跟着坐标以逗号或者空格分隔，表示的是画笔移动的目的地坐标，L绝对，l相对(参考的是前一个M的位置，下同不赘述)</p>\n<p><strong>Z(closepath)</strong>:用来关闭当前路径同时开启一个子路径，Z后面不跟坐标且他的大小写效果一模一样，同时Z标签会连接起始点从而形成封闭的图形</p>\n<p><strong>V，H</strong>:用来绘制水平方向(H)和垂直方向(V)的路径，后面只要跟一个目标点的x或y坐标，因为另一个坐标是定死的，大小写情况和其他标签相同</p>\n<p><strong>A(elliptical Arc)</strong>:用来绘制一条到目标点的椭圆弧，有以下参数</p>\n<ol>\n<li>起始点坐标，x,y</li>\n<li>x轴旋转角度</li>\n<li>圆弧角度是否大于180,0是小于1是大于</li>\n<li>圆弧正负角度0是负角度，1是正角度也就是画笔以逆时针还是顺时针画弧</li>\n<li>终点x,y坐标</li>\n</ol>\n<p><strong>Q、T、C、S</strong>：贝塞尔曲线相关不建议使用（因为太难了我搞不懂…）</p>\n<h3 id=\"五、文本\"><a href=\"#五、文本\" class=\"headerlink\" title=\"五、文本\"></a>五、文本</h3><p>文本标签用来绘制svg图形中的文字</p>\n<h4 id=\"lt-text-gt-标签\"><a href=\"#lt-text-gt-标签\" class=\"headerlink\" title=\"&lt;text&gt;标签\"></a>&lt;text&gt;标签</h4><p><code>&lt;text&gt;</code>需要制定x,y坐标来作为第一个文字的位置其样式基本属性和css中文字有关的属性基本一样，</p>\n<p>属性：</p>\n<blockquote>\n<p>font-size:字体大小</p>\n<p>font-style:字体是否倾斜italic(倾斜)，normal</p>\n<p>text-decoration:是否有下划线none,underline,overline,line-through</p>\n</blockquote>\n<h4 id=\"lt-tspan-gt-标签\"><a href=\"#lt-tspan-gt-标签\" class=\"headerlink\" title=\"&lt;tspan&gt;标签\"></a>&lt;tspan&gt;标签</h4><p>我们可以简单的把该标签理解成span，他们都可以嵌入到文本中，在这个标签你可以为它单独定制样式等属性，而且由于是内嵌元素所以也不需要指定坐标</p>\n<p><strong>改变位置的属性</strong>：</p>\n<p>​    dx,dy(水平和垂直方向偏移量):dx,dy的值都是你想偏移的具体数值，且都是相对于原本位置来说    的，类似于position里面的relative</p>\n<p>​    x,y(绝对定位):这里的xy都是当前文本的绝对位置，类似于<code>&lt;text&gt;</code>的xy</p>\n<blockquote>\n<p>x，y，dx，dy都可以单独或者组合使用，单独使用时其他为指明的值为默认值</p>\n</blockquote>\n<h4 id=\"文本路径-lt-textPath-gt\"><a href=\"#文本路径-lt-textPath-gt\" class=\"headerlink\" title=\"文本路径&lt;textPath&gt;\"></a>文本路径&lt;textPath&gt;</h4><p>这个也是以后可能使用频率很高的属性，这个属性类似于<code>&lt;path&gt;</code>标签，让文字按照指定路径排列，</p>\n<blockquote>\n<p>使用步骤</p>\n<p>1：将文字的显示路径用path预先定义我们想要的path路径一般放在<code>&lt;defs&gt;</code>里面</p>\n<p>2：定义好&lt;text&gt;文本域，在文本里面加入&lt;textPath&gt;标签，并且使用<code>xline:href=xxx</code>来引用</p>\n<p>3.在&lt;textPath&gt;标签中定义我们的文字</p>\n</blockquote>"},{"title":"VueX","date":"2020-01-21T10:38:45.000Z","_content":"\n# VueX ���(���۲���)\n\n## һ��VueX �ĸ���\n\n### 1.�ο��ٷ��ĵ��� Vuex ��һ��ר��Ϊ Vue.js ��Ƶ�Ӧ�ó���״̬����ģʽ�����ü��д洢����Ӧ�õ����������״̬��������Ӧ�Ĺ���֤״̬��һ�ֿ�Ԥ��ķ�ʽ�����仯������˵��λ������¼����ؼ��㣺\n\n    1.״̬����ģʽ\n    2.��Ӧ�Ĺ���Ϳ�Ԥ��ķ�ʽ\n\n����һһ������һ�£�\n\n#### 1.״̬����ģʽ\n\n�Դ� vuex ���ṩ��һ���ٷ�������˵����\n\n```\nnew Vue({\n // state\n data () {\n   return {\n     count: 0\n   }\n },\n // view\n template: `\n   <div>{{ count }}</div>\n `,\n // actions\n methods: {\n   increment () {\n     this.count++\n   }\n }\n})\n```\n\n    ���������ܿ�����ʵ�Ϲ���vuex�ܹ��������󲿷֣�\n    1.`data���ִ������Ҳ�����������������Դ`-state\n    2.`template���ִ�ŵ���html��ǩҲ������ͼ`-view\n    3.`methods���ִ����صĺ���Ҳ�����������ݸı䷽ʽ`-actions\n\n������������Ϲ�ͬ������һ��״̬�Թ���Ӧ�ò��Ե����������ķ�ʽ���У����Ա�֤���ݵļ�༴��\n![����������](VueX/flow.png \"����������\")\n\n#### 2.��Ӧ�Ĺ���Ϳ�Ԥ��ķ�ʽ\n���������ϸ�������Ҳ�ܺ����⣬״̬����ģʽ�µ����ݵļ���п�����ĳЩӦ�ó����б��ƻ���\n`1.�����ͼ����ͬһ״̬`\n`2.�����ͬ����ͼ��Ϊ����Ҫ����ͬһ״̬`\n\n- �������� 1.һ�㶼�Ǹ�������Ƕ�ף����� 2.һ�㶼�Ǹ��������ֵ�� bus �¼������������Ͻ���취�����ᵼ�´����߳�����ά�����в���Ҫ�������������⡣\n- ��ʱ��һ����˼·�����������⣺�����й�����״̬�������������������λ�õ���ͼ�����Ի�ȡ�͸��Ķ�Ӧ״̬��ͨ�����������״̬�����ĸ��ͨ��ǿ�ƵĹ�������֤��ͼ��״̬�Ķ����ԣ������ͱȽ������Ľ����������⣬��������һ��ȫ�ֵ�������ģʽ�������ķ�ʽҲ�� v ʱ uex �Ļ������˼·\n  ���ڴ� vuex �ƶ�������ص�ǿ�Ʒ������Ա������и��Ĺ���״̬����Ϊ�������ͬʱά������\n\n## ����VueX ��ʹ�ó���\nvuex ������ͳһ����״̬�ĵ������Ǹ�ʲôʱ��ʹ���أ�һ���������ձ���������˵�����д�����Ŀ�лῼ��ʹ�ã������Ҿ��Ų�̫׼ȷ�����ҵ��������Ƿ�ʹ�� vuex Ӧ���������Ŀ���Ƿ������ vuex �����������⣬������Ƴ������ʲô�����������ʲô�����Ը����Ҳ���ľ���򵥵�������һ��ʹ�ó�����\n`1.����ṹ���Ӷ��ֽ��������ﳵ���б�����...`\n`2.����ظ����������ɵ���Ҫ�������ݣ�������...`\n`3.����������������������ͼ��ȫ�ַ��...`\n\n## ����vueX ���ĸ��� ###�ȿ����ٷ��ĵ��е�ͼ��\n![����](VueX/vuex.png \"VueX\")\n�� 3 ������`State`��`Action`��`Mutaiton`�ټ���`Getter`��`Moudule`�ܼ��� 5 ��,һһ����һ��\n\n#### 1.State\n\n- `���`State ��Ϊ����ģʽ�����µĸ����ȫ����Ψһ�Ķ���ʽ�����ڣ���ΪΨһ������Դ����ܹ������Ҫ������״̬\n- `��Vuex�еĶ����ʹ�ã�`\n\n```\nconst Counter = {\n template: `<div>{{ count }}</div>`,\n computed: {\n   count () {\n     return this.$store.state.count\n   }\n }\n}\n```\n\n- `��������mapState��`һ����˵�� computed ��ʹ�ö���չ������������״̬���ɶ�Ӧ�ļ�������\n\n```\ncomputed: {\nlocalComputed () { /* ... */ },\n// ʹ�ö���չ����������˶�����뵽�ⲿ������\n...mapState({\n  // ...\n})\n}\n```\n\n#### 2.Mutation\n\n- `���`Mutation �� Vuex ����Ψһ�ܶ� State ״̬���в��������ԣ��������Ÿ��ֶ� State ��״̬�ĸ��ֲ������� vue �е� methods �����ƣ����ԶԱ������⡣\n- `��Vuex�еĶ�����ʹ�ã�`\n  ```\n  const store = new Vuex.Store({\n  state: {\n  count: 1\n  },\n  mutations: {\n  increment (state) {\n    // ���״̬\n    state.count++\n  }\n  }\n  })\n  ```\n\n`1.����`:�ɴ�Ҳ�ܿ������� mutation �еĸ��ַ��������¼�����(type)+�ص�����(handler)��ɣ������ڷ�����+������\n`2.����`:store.commit(Type ��)������\n\n- `�ύ�غ�(PayLoad)`:�����ǵ��� Mutation ��Ӧ����ʱ�������� Type ���ƻ������ں��洫����������������ʹ����Ҳ�������������ͣ������ں����еĲ����б�\n- `�������ύ`���� commit ʱֱ�Ӱ� Type �ͺ���д��ͬһ��������\n\n```\n store.commit({\n  type: 'increment',\n  amount: 10\n  })\n```\n\n`3.ͬ���ԣ�`�� Mutation �еĲ���������ͬ���ģ�Ϊ�˱�֤�� state ״̬��ȷ�����޸�\n`4.��������MapMutation:`һ����˵��Ӧ�� Methods ��ʹ�ö���չ������ Mutation �еĶ�Ӧ����ӳ�䵽�ֲ������\n\n```\nimport { mapMutations } from 'vuex'\n\nexport default {\n // ...\n methods: {\n   ...mapMutations([\n     'increment', // �� `this.increment()` ӳ��Ϊ `this.$store.commit('increment')`\n\n     // `mapMutations` Ҳ֧���غɣ�\n     'incrementBy' // �� `this.incrementBy(amount)` ӳ��Ϊ `this.$store.commit('incrementBy', amount)`\n   ]),\n   ...mapMutations({\n     add: 'increment' // �� `this.add()` ӳ��Ϊ `this.$store.commit('increment')`\n   })\n }\n}\n```\n\n#### 3.Action\n\n- `����`:Action �����ʺ� Mutation ����һ�������������� Action �п��԰���ͬ���첽������ͬʱ Action ������ֱ�Ӷ� State ���в�����Ҫ�ύ�ĵ� Mutation������ Mutation �еķ����� State ���в���\n\n- `��VueX�еĶ�����ʹ��`\n\n```\n\nconst store = new Vuex.Store({\n state: {\n   count: 0\n },\n mutations: {\n   increment (state) {\n     state.count++\n   }\n },\n actions: {\n   increment (context) {\n     context.commit('increment')\n   }\n }\n})\n```\n\n`1.������`�� Mutation ��ͬ\n`2.����(�ַ�)��`context.dispatch(Type ��)\n`3.�ύ���أ�`�� Mutation ��ͬ\n`4.�������ύ��`�� Mutation ��ͬ\n\n- `�첽��`���� Action ���첽������ɺ󷵻ص���һ�� Promise ������Ҫʵ�ֶ� State �Ĳ������������м��� commit ͬ������\n- `��������MapAction��`�� Mutation ��ͬ\n  ####4.Getter\n- `���`����Ҫ�� Store ������ state �Ĳ������Խ���ĳЩ����֮�����ɵ��ų����Դ���� getter ���棬������ Computed��\n\n```\n   computed: {\n  doneTodosCount () {\n    return this.$store.state.todos.filter(todo => todo.done).length\n  }\n}\n```\n\n- `��Vuex�еĶ�����ʹ��`\n  `1.����:`����+�ύ����+�ص�����\n  `2.���ã�`\n  `1ͨ�����Է���`��Getter �ᱩ¶һ�� store.getters ����ͨ���ö���.��Ӧ���Ե���ʽ����\n  `store.getters.doneTodos`\n  `2.ͨ���������ʣ�`�� getters ����һ���������ڵ���ʱ������Ӧ����ͨ�� getters �ж�Ӧ�����Լ�ӵĶ� store �е�ĳЩ���Խ��в���\n\n```\n     getters: {\n  // ...\n  getTodoById: (state) => (id) => {\n    return state.todos.find(todo => todo.id === id)\n  }\n}\n```\n\n- `MapperGetter����������`�ö���չ������ computed ���Խ���ӳ�䣬��ʱ��Ҫ��������Ҫ�ö������ʽ���½���\n\n```\nimport { mapGetters } from 'vuex'\n\nexport default {\n // ...\n computed: {\n // ʹ�ö���չ��������� getter ���� computed ������\n   ...mapGetters([\n     'doneTodosCount',\n     'anotherGetter',\n     // ...\n   ])\n }\n}\n```\n\n#### 5.Moudule\n\n- `���`��Ӧ�ù��ڸ���ʱ store ��������쳣��ӷ�ף�Ϊ�˽������������Ҫʹ�õ� Vuex �е� Moudule ����(ģ��)�����ڶԸ��ӵ� store �����иʹ֮�ָ��һ��������ģ�飬ÿ��ģ��ӵ�ж����� state,Mutation,��ͬʱģ���ڲ�Ҳ�ܹ��໥Ƕ�ף������� vue �е���� components �ĸ���\n\n```\n const moduleA = {\n  state: { ... },\n  mutations: { ... },\n  actions: { ... },\n  getters: { ... }\n}\n\nconst moduleB = {\n  state: { ... },\n  mutations: { ... },\n  actions: { ... }\n}\n\nconst store = new Vuex.Store({\n  modules: {\n    a: moduleA,\n    b: moduleB\n  }\n})\nstore.state.a // -> moduleA ��״̬\nstore.state.b // -> moduleB ��״̬\n```\n\n- `Moudule�ڵľֲ�״̬��`�ڲ�ͬĳ���л�ȡ��Ĭ�϶���������Ҳ������ģ���ڲ��������ڲ�ͬ����� this\n  `1.�ֲ�״̬�µ�Mutation��state:`ʹ�÷�ʽ��ȫ����û������\n  `2.�ֲ�״̬�µ�action��getters��`�ھֲ�״̬�½��յĲ����еĵ������Ǿֲ�״̬�ĸ��ڵ�\n- `Module�����ռ䣺`\n  `���ݣ�`ͨ���� moudule ������ namespace:true �����ɶ�Ӧ���Ƶ�ģ�飬��ģ�鱻ע���ģ���ڵ��������ݶ������������vue ��ֳ��������� name:'xx'���ö�Ӧ��������·���ı䣩\n- `�������ռ��Module������ķ���`\n  `1.Module����ȫ������`\n  `1.1.`ʹ��ȫ�ֵ� state �� getter���ھֲ�״̬�н��յ������ĸ������ֱ����ȫ��״̬��ȫ�� getters��Ҳ��ͨ����Ӧ context �� store ���뷽��\n  `1.2`ʹ��ȫ�ֵ� mutation �� action���ھֲ������н�����Ϊ�����������������Ӧ�� dispatch �� commit\n  `1.3`�ֲ�ע��ȫ�� action:�� root:true ��Ϊ������� handler ��\n\n```\n modules: {\n  foo: {\n   namespaced: true,\n   getters: {\n     // �����ģ��� getter �У�`getters` ���ֲ�����\n     // �����ʹ�� getter �ĵ��ĸ����������� `rootGetters`\n     someGetter (state, getters, rootState, rootGetters) {\n       getters.someOtherGetter // -> 'foo/someOtherGetter'\n       rootGetters.someOtherGetter // -> 'someOtherGetter'\n     },\n     someOtherGetter: state => { ... }\n   },\n\n   actions: {\n     // �����ģ���У� dispatch �� commit Ҳ���ֲ�����\n     // ���ǿ��Խ��� `root` �����Է��ʸ� dispatch �� commit\n     someAction ({ dispatch, commit, getters, rootGetters }) {\n       getters.someGetter // -> 'foo/someGetter'\n       rootGetters.someGetter // -> 'someGetter'\n\n       dispatch('someOtherAction') // -> 'foo/someOtherAction'\n       dispatch('someOtherAction', null, { root: true }) // -> 'someOtherAction'\n\n       commit('someMutation') // -> 'foo/someMutation'\n       commit('someMutation', null, { root: true }) // -> 'someMutation'\n     },\n     someOtherAction (ctx, payload) { ... }\n   }\n }\n}\n```\n\n`2.�ⲿ����Moudule�ֲ����ݣ�`\n`1.ͨ�������������ʣ�`\n`2.ͨ��createNamespacedHelpers���ʣ�`ͨ������ vue �е� createNamespacedHelpers�����ص���һ���������л�����������������ĸ����������������Ӧ�ú��ȡ�������������\n\n```\nimport { createNamespacedHelpers } from 'vuex'\n\nconst { mapState, mapActions } = createNamespacedHelpers('some/nested/module')\n\nexport default {\n computed: {\n   // �� `some/nested/module` �в���\n   ...mapState({\n     a: state => state.a,\n     b: state => state.b\n   })\n },\n methods: {\n   // �� `some/nested/module` �в���\n   ...mapActions([\n     'foo',\n     'bar'\n   ])\n }\n}\n```\n\n## VueX ��������\n\n### �ϸ�ģʽ\n\n- `���`���ϸ�ģʽ�»���ȼ������״̬����������״̬�ı�Ķ������������� mutation ���ᱨ��\n- `���ã�`�� store ����ʱ����`strict��true\n- `ע�����`\n  `�ϸ�ģʽ�µı���������`���� input ȥ�� vuex �е�״̬ʱ���ڸı䲻���� mutation ���������Իᱨ����Ҫ������������һ����˵ �� input �� change �¼����ڶ�Ӧ������ʹ�� commit �ύ\n  ���߰�һ����������ʹ�� get ������ȡ״̬ʹ�� set ��������״̬`\n\n#### �������� VueX ��Ӧ�ĸ���󣬽�������Ӧ�ü���ʵս�ˣ�������ʱ��Ļ����Ჹ��һƪ���� VueX ��ʹ�����飬�����ڴ�\n","source":"_posts/VueX.md","raw":"---\ntitle: VueX\ndate: 2020-1-21 18:38:45\ncategories: \n\t- Webǰ��\ntags: \n    - Vue\n    - VueX\n---\n\n# VueX ���(���۲���)\n\n## һ��VueX �ĸ���\n\n### 1.�ο��ٷ��ĵ��� Vuex ��һ��ר��Ϊ Vue.js ��Ƶ�Ӧ�ó���״̬����ģʽ�����ü��д洢����Ӧ�õ����������״̬��������Ӧ�Ĺ���֤״̬��һ�ֿ�Ԥ��ķ�ʽ�����仯������˵��λ������¼����ؼ��㣺\n\n    1.״̬����ģʽ\n    2.��Ӧ�Ĺ���Ϳ�Ԥ��ķ�ʽ\n\n����һһ������һ�£�\n\n#### 1.״̬����ģʽ\n\n�Դ� vuex ���ṩ��һ���ٷ�������˵����\n\n```\nnew Vue({\n // state\n data () {\n   return {\n     count: 0\n   }\n },\n // view\n template: `\n   <div>{{ count }}</div>\n `,\n // actions\n methods: {\n   increment () {\n     this.count++\n   }\n }\n})\n```\n\n    ���������ܿ�����ʵ�Ϲ���vuex�ܹ��������󲿷֣�\n    1.`data���ִ������Ҳ�����������������Դ`-state\n    2.`template���ִ�ŵ���html��ǩҲ������ͼ`-view\n    3.`methods���ִ����صĺ���Ҳ�����������ݸı䷽ʽ`-actions\n\n������������Ϲ�ͬ������һ��״̬�Թ���Ӧ�ò��Ե����������ķ�ʽ���У����Ա�֤���ݵļ�༴��\n![����������](VueX/flow.png \"����������\")\n\n#### 2.��Ӧ�Ĺ���Ϳ�Ԥ��ķ�ʽ\n���������ϸ�������Ҳ�ܺ����⣬״̬����ģʽ�µ����ݵļ���п�����ĳЩӦ�ó����б��ƻ���\n`1.�����ͼ����ͬһ״̬`\n`2.�����ͬ����ͼ��Ϊ����Ҫ����ͬһ״̬`\n\n- �������� 1.һ�㶼�Ǹ�������Ƕ�ף����� 2.һ�㶼�Ǹ��������ֵ�� bus �¼������������Ͻ���취�����ᵼ�´����߳�����ά�����в���Ҫ�������������⡣\n- ��ʱ��һ����˼·�����������⣺�����й�����״̬�������������������λ�õ���ͼ�����Ի�ȡ�͸��Ķ�Ӧ״̬��ͨ�����������״̬�����ĸ��ͨ��ǿ�ƵĹ�������֤��ͼ��״̬�Ķ����ԣ������ͱȽ������Ľ����������⣬��������һ��ȫ�ֵ�������ģʽ�������ķ�ʽҲ�� v ʱ uex �Ļ������˼·\n  ���ڴ� vuex �ƶ�������ص�ǿ�Ʒ������Ա������и��Ĺ���״̬����Ϊ�������ͬʱά������\n\n## ����VueX ��ʹ�ó���\nvuex ������ͳһ����״̬�ĵ������Ǹ�ʲôʱ��ʹ���أ�һ���������ձ���������˵�����д�����Ŀ�лῼ��ʹ�ã������Ҿ��Ų�̫׼ȷ�����ҵ��������Ƿ�ʹ�� vuex Ӧ���������Ŀ���Ƿ������ vuex �����������⣬������Ƴ������ʲô�����������ʲô�����Ը����Ҳ���ľ���򵥵�������һ��ʹ�ó�����\n`1.����ṹ���Ӷ��ֽ��������ﳵ���б�����...`\n`2.����ظ����������ɵ���Ҫ�������ݣ�������...`\n`3.����������������������ͼ��ȫ�ַ��...`\n\n## ����vueX ���ĸ��� ###�ȿ����ٷ��ĵ��е�ͼ��\n![����](VueX/vuex.png \"VueX\")\n�� 3 ������`State`��`Action`��`Mutaiton`�ټ���`Getter`��`Moudule`�ܼ��� 5 ��,һһ����һ��\n\n#### 1.State\n\n- `���`State ��Ϊ����ģʽ�����µĸ����ȫ����Ψһ�Ķ���ʽ�����ڣ���ΪΨһ������Դ����ܹ������Ҫ������״̬\n- `��Vuex�еĶ����ʹ�ã�`\n\n```\nconst Counter = {\n template: `<div>{{ count }}</div>`,\n computed: {\n   count () {\n     return this.$store.state.count\n   }\n }\n}\n```\n\n- `��������mapState��`һ����˵�� computed ��ʹ�ö���չ������������״̬���ɶ�Ӧ�ļ�������\n\n```\ncomputed: {\nlocalComputed () { /* ... */ },\n// ʹ�ö���չ����������˶�����뵽�ⲿ������\n...mapState({\n  // ...\n})\n}\n```\n\n#### 2.Mutation\n\n- `���`Mutation �� Vuex ����Ψһ�ܶ� State ״̬���в��������ԣ��������Ÿ��ֶ� State ��״̬�ĸ��ֲ������� vue �е� methods �����ƣ����ԶԱ������⡣\n- `��Vuex�еĶ�����ʹ�ã�`\n  ```\n  const store = new Vuex.Store({\n  state: {\n  count: 1\n  },\n  mutations: {\n  increment (state) {\n    // ���״̬\n    state.count++\n  }\n  }\n  })\n  ```\n\n`1.����`:�ɴ�Ҳ�ܿ������� mutation �еĸ��ַ��������¼�����(type)+�ص�����(handler)��ɣ������ڷ�����+������\n`2.����`:store.commit(Type ��)������\n\n- `�ύ�غ�(PayLoad)`:�����ǵ��� Mutation ��Ӧ����ʱ�������� Type ���ƻ������ں��洫����������������ʹ����Ҳ�������������ͣ������ں����еĲ����б�\n- `�������ύ`���� commit ʱֱ�Ӱ� Type �ͺ���д��ͬһ��������\n\n```\n store.commit({\n  type: 'increment',\n  amount: 10\n  })\n```\n\n`3.ͬ���ԣ�`�� Mutation �еĲ���������ͬ���ģ�Ϊ�˱�֤�� state ״̬��ȷ�����޸�\n`4.��������MapMutation:`һ����˵��Ӧ�� Methods ��ʹ�ö���չ������ Mutation �еĶ�Ӧ����ӳ�䵽�ֲ������\n\n```\nimport { mapMutations } from 'vuex'\n\nexport default {\n // ...\n methods: {\n   ...mapMutations([\n     'increment', // �� `this.increment()` ӳ��Ϊ `this.$store.commit('increment')`\n\n     // `mapMutations` Ҳ֧���غɣ�\n     'incrementBy' // �� `this.incrementBy(amount)` ӳ��Ϊ `this.$store.commit('incrementBy', amount)`\n   ]),\n   ...mapMutations({\n     add: 'increment' // �� `this.add()` ӳ��Ϊ `this.$store.commit('increment')`\n   })\n }\n}\n```\n\n#### 3.Action\n\n- `����`:Action �����ʺ� Mutation ����һ�������������� Action �п��԰���ͬ���첽������ͬʱ Action ������ֱ�Ӷ� State ���в�����Ҫ�ύ�ĵ� Mutation������ Mutation �еķ����� State ���в���\n\n- `��VueX�еĶ�����ʹ��`\n\n```\n\nconst store = new Vuex.Store({\n state: {\n   count: 0\n },\n mutations: {\n   increment (state) {\n     state.count++\n   }\n },\n actions: {\n   increment (context) {\n     context.commit('increment')\n   }\n }\n})\n```\n\n`1.������`�� Mutation ��ͬ\n`2.����(�ַ�)��`context.dispatch(Type ��)\n`3.�ύ���أ�`�� Mutation ��ͬ\n`4.�������ύ��`�� Mutation ��ͬ\n\n- `�첽��`���� Action ���첽������ɺ󷵻ص���һ�� Promise ������Ҫʵ�ֶ� State �Ĳ������������м��� commit ͬ������\n- `��������MapAction��`�� Mutation ��ͬ\n  ####4.Getter\n- `���`����Ҫ�� Store ������ state �Ĳ������Խ���ĳЩ����֮�����ɵ��ų����Դ���� getter ���棬������ Computed��\n\n```\n   computed: {\n  doneTodosCount () {\n    return this.$store.state.todos.filter(todo => todo.done).length\n  }\n}\n```\n\n- `��Vuex�еĶ�����ʹ��`\n  `1.����:`����+�ύ����+�ص�����\n  `2.���ã�`\n  `1ͨ�����Է���`��Getter �ᱩ¶һ�� store.getters ����ͨ���ö���.��Ӧ���Ե���ʽ����\n  `store.getters.doneTodos`\n  `2.ͨ���������ʣ�`�� getters ����һ���������ڵ���ʱ������Ӧ����ͨ�� getters �ж�Ӧ�����Լ�ӵĶ� store �е�ĳЩ���Խ��в���\n\n```\n     getters: {\n  // ...\n  getTodoById: (state) => (id) => {\n    return state.todos.find(todo => todo.id === id)\n  }\n}\n```\n\n- `MapperGetter����������`�ö���չ������ computed ���Խ���ӳ�䣬��ʱ��Ҫ��������Ҫ�ö������ʽ���½���\n\n```\nimport { mapGetters } from 'vuex'\n\nexport default {\n // ...\n computed: {\n // ʹ�ö���չ��������� getter ���� computed ������\n   ...mapGetters([\n     'doneTodosCount',\n     'anotherGetter',\n     // ...\n   ])\n }\n}\n```\n\n#### 5.Moudule\n\n- `���`��Ӧ�ù��ڸ���ʱ store ��������쳣��ӷ�ף�Ϊ�˽������������Ҫʹ�õ� Vuex �е� Moudule ����(ģ��)�����ڶԸ��ӵ� store �����иʹ֮�ָ��һ��������ģ�飬ÿ��ģ��ӵ�ж����� state,Mutation,��ͬʱģ���ڲ�Ҳ�ܹ��໥Ƕ�ף������� vue �е���� components �ĸ���\n\n```\n const moduleA = {\n  state: { ... },\n  mutations: { ... },\n  actions: { ... },\n  getters: { ... }\n}\n\nconst moduleB = {\n  state: { ... },\n  mutations: { ... },\n  actions: { ... }\n}\n\nconst store = new Vuex.Store({\n  modules: {\n    a: moduleA,\n    b: moduleB\n  }\n})\nstore.state.a // -> moduleA ��״̬\nstore.state.b // -> moduleB ��״̬\n```\n\n- `Moudule�ڵľֲ�״̬��`�ڲ�ͬĳ���л�ȡ��Ĭ�϶���������Ҳ������ģ���ڲ��������ڲ�ͬ����� this\n  `1.�ֲ�״̬�µ�Mutation��state:`ʹ�÷�ʽ��ȫ����û������\n  `2.�ֲ�״̬�µ�action��getters��`�ھֲ�״̬�½��յĲ����еĵ������Ǿֲ�״̬�ĸ��ڵ�\n- `Module�����ռ䣺`\n  `���ݣ�`ͨ���� moudule ������ namespace:true �����ɶ�Ӧ���Ƶ�ģ�飬��ģ�鱻ע���ģ���ڵ��������ݶ������������vue ��ֳ��������� name:'xx'���ö�Ӧ��������·���ı䣩\n- `�������ռ��Module������ķ���`\n  `1.Module����ȫ������`\n  `1.1.`ʹ��ȫ�ֵ� state �� getter���ھֲ�״̬�н��յ������ĸ������ֱ����ȫ��״̬��ȫ�� getters��Ҳ��ͨ����Ӧ context �� store ���뷽��\n  `1.2`ʹ��ȫ�ֵ� mutation �� action���ھֲ������н�����Ϊ�����������������Ӧ�� dispatch �� commit\n  `1.3`�ֲ�ע��ȫ�� action:�� root:true ��Ϊ������� handler ��\n\n```\n modules: {\n  foo: {\n   namespaced: true,\n   getters: {\n     // �����ģ��� getter �У�`getters` ���ֲ�����\n     // �����ʹ�� getter �ĵ��ĸ����������� `rootGetters`\n     someGetter (state, getters, rootState, rootGetters) {\n       getters.someOtherGetter // -> 'foo/someOtherGetter'\n       rootGetters.someOtherGetter // -> 'someOtherGetter'\n     },\n     someOtherGetter: state => { ... }\n   },\n\n   actions: {\n     // �����ģ���У� dispatch �� commit Ҳ���ֲ�����\n     // ���ǿ��Խ��� `root` �����Է��ʸ� dispatch �� commit\n     someAction ({ dispatch, commit, getters, rootGetters }) {\n       getters.someGetter // -> 'foo/someGetter'\n       rootGetters.someGetter // -> 'someGetter'\n\n       dispatch('someOtherAction') // -> 'foo/someOtherAction'\n       dispatch('someOtherAction', null, { root: true }) // -> 'someOtherAction'\n\n       commit('someMutation') // -> 'foo/someMutation'\n       commit('someMutation', null, { root: true }) // -> 'someMutation'\n     },\n     someOtherAction (ctx, payload) { ... }\n   }\n }\n}\n```\n\n`2.�ⲿ����Moudule�ֲ����ݣ�`\n`1.ͨ�������������ʣ�`\n`2.ͨ��createNamespacedHelpers���ʣ�`ͨ������ vue �е� createNamespacedHelpers�����ص���һ���������л�����������������ĸ����������������Ӧ�ú��ȡ�������������\n\n```\nimport { createNamespacedHelpers } from 'vuex'\n\nconst { mapState, mapActions } = createNamespacedHelpers('some/nested/module')\n\nexport default {\n computed: {\n   // �� `some/nested/module` �в���\n   ...mapState({\n     a: state => state.a,\n     b: state => state.b\n   })\n },\n methods: {\n   // �� `some/nested/module` �в���\n   ...mapActions([\n     'foo',\n     'bar'\n   ])\n }\n}\n```\n\n## VueX ��������\n\n### �ϸ�ģʽ\n\n- `���`���ϸ�ģʽ�»���ȼ������״̬����������״̬�ı�Ķ������������� mutation ���ᱨ��\n- `���ã�`�� store ����ʱ����`strict��true\n- `ע�����`\n  `�ϸ�ģʽ�µı���������`���� input ȥ�� vuex �е�״̬ʱ���ڸı䲻���� mutation ���������Իᱨ����Ҫ������������һ����˵ �� input �� change �¼����ڶ�Ӧ������ʹ�� commit �ύ\n  ���߰�һ����������ʹ�� get ������ȡ״̬ʹ�� set ��������״̬`\n\n#### �������� VueX ��Ӧ�ĸ���󣬽�������Ӧ�ü���ʵս�ˣ�������ʱ��Ļ����Ჹ��һƪ���� VueX ��ʹ�����飬�����ڴ�\n","slug":"VueX","published":1,"updated":"2020-04-28T01:33:50.546Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9j8lyer0000n0cs3bcohpwx","content":"<h1 id=\"VueX-���-���۲���\"><a href=\"#VueX-���-���۲���\" class=\"headerlink\" title=\"VueX ���(���۲���)\"></a>VueX ���(���۲���)</h1><h2 id=\"һ��VueX-�ĸ���\"><a href=\"#һ��VueX-�ĸ���\" class=\"headerlink\" title=\"һ��VueX �ĸ���\"></a>һ��VueX �ĸ���</h2><h3 id=\"1-�ο��ٷ��j���-Vuex-��һ��ר��Ϊ-Vue-js-��Z�Ӧ�o���״̬����gʽ�����u��д洢����Ӧ�o����������״̬��������Ӧ�L���֤״̬��һ�ֿ�Ԥ��k�ʽ�����仯������˵��λ������¼����ؼ��㣺\"><a href=\"#1-�ο��ٷ��j���-Vuex-��һ��ר��Ϊ-Vue-js-��Z�Ӧ�o���״̬����gʽ�����u��д洢����Ӧ�o����������״̬��������Ӧ�L���֤״̬��һ�ֿ�Ԥ��k�ʽ�����仯������˵��λ������¼����ؼ��㣺\" class=\"headerlink\" title=\"1.�ο��ٷ��ĵ��� Vuex ��һ��ר��Ϊ Vue.js ��Ƶ�Ӧ�ó���״̬����ģʽ�����ü��д洢����Ӧ�õ����������״̬��������Ӧ�Ĺ���֤״̬��һ�ֿ�Ԥ��ķ�ʽ�����仯������˵��λ������¼����ؼ��㣺\"></a>1.�ο��ٷ��ĵ��� Vuex ��һ��ר��Ϊ Vue.js ��Ƶ�Ӧ�ó���״̬����ģʽ�����ü��д洢����Ӧ�õ����������״̬��������Ӧ�Ĺ���֤״̬��һ�ֿ�Ԥ��ķ�ʽ�����仯������˵��λ������¼����ؼ��㣺</h3><pre><code>1.״̬����ģʽ\n2.��Ӧ�Ĺ���Ϳ�Ԥ��ķ�ʽ</code></pre><p>����һһ������һ�£�</p>\n<h4 id=\"1-״̬����gʽ\"><a href=\"#1-״̬����gʽ\" class=\"headerlink\" title=\"1.״̬����ģʽ\"></a>1.״̬����ģʽ</h4><p>�Դ� vuex ���ṩ��һ���ٷ�������˵����</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">new Vue(&#123;</span><br><span class=\"line\"> &#x2F;&#x2F; state</span><br><span class=\"line\"> data () &#123;</span><br><span class=\"line\">   return &#123;</span><br><span class=\"line\">     count: 0</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"> &#125;,</span><br><span class=\"line\"> &#x2F;&#x2F; view</span><br><span class=\"line\"> template: &#96;</span><br><span class=\"line\">   &lt;div&gt;&#123;&#123; count &#125;&#125;&lt;&#x2F;div&gt;</span><br><span class=\"line\"> &#96;,</span><br><span class=\"line\"> &#x2F;&#x2F; actions</span><br><span class=\"line\"> methods: &#123;</span><br><span class=\"line\">   increment () &#123;</span><br><span class=\"line\">     this.count++</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<pre><code>���������ܿ�����ʵ�Ϲ���vuex�ܹ��������󲿷֣�\n1.`data���ִ������Ҳ�����������������Դ`-state\n2.`template���ִ�ŵ���html��ǩҲ������ͼ`-view\n3.`methods���ִ����صĺ���Ҳ�����������ݸı䷽ʽ`-actions</code></pre><p>������������Ϲ�ͬ������һ��״̬�Թ���Ӧ�ò��Ե����������ķ�ʽ���У����Ա�֤���ݵļ�༴��<br><img src=\"/2020/01/21/VueX/flow.png\" alt=\"����������\" title=\"����������\"></p>\n<h4 id=\"2-��Ӧ�L���Ϳ�Ԥ��k�ʽ\"><a href=\"#2-��Ӧ�L���Ϳ�Ԥ��k�ʽ\" class=\"headerlink\" title=\"2.��Ӧ�Ĺ���Ϳ�Ԥ��ķ�ʽ\"></a>2.��Ӧ�Ĺ���Ϳ�Ԥ��ķ�ʽ</h4><p>���������ϸ�������Ҳ�ܺ����⣬״̬����ģʽ�µ����ݵļ���п�����ĳЩӦ�ó����б��ƻ���<br><code>1.�����ͼ����ͬһ״̬</code><br><code>2.�����ͬ����ͼ��Ϊ����Ҫ����ͬһ״̬</code></p>\n<ul>\n<li>�������� 1.һ�㶼�Ǹ�������Ƕ�ף����� 2.һ�㶼�Ǹ��������ֵ�� bus �¼������������Ͻ���취�����ᵼ�´����߳�����ά�����в���Ҫ�������������⡣</li>\n<li>��ʱ��һ����˼·�����������⣺�����й�����״̬�������������������λ�õ���ͼ�����Ի�ȡ�͸��Ķ�Ӧ״̬��ͨ�����������״̬�����ĸ��ͨ��ǿ�ƵĹ�������֤��ͼ��״̬�Ķ����ԣ������ͱȽ������Ľ����������⣬��������һ��ȫ�ֵ�������ģʽ�������ķ�ʽҲ�� v ʱ uex �Ļ������˼·<br>���ڴ� vuex �ƶ�������ص�ǿ�Ʒ������Ա������и��Ĺ���״̬����Ϊ�������ͬʱά������</li>\n</ul>\n<h2 id=\"����VueX-��ʹ�o���\"><a href=\"#����VueX-��ʹ�o���\" class=\"headerlink\" title=\"����VueX ��ʹ�ó���\"></a>����VueX ��ʹ�ó���</h2><p>vuex ������ͳһ����״̬�ĵ������Ǹ�ʲôʱ��ʹ���أ�һ���������ձ���������˵�����д�����Ŀ�лῼ��ʹ�ã������Ҿ��Ų�̫׼ȷ�����ҵ��������Ƿ�ʹ�� vuex Ӧ���������Ŀ���Ƿ������ vuex �����������⣬������Ƴ������ʲô�����������ʲô�����Ը����Ҳ���ľ���򵥵�������һ��ʹ�ó�����<br><code>1.����ṹ���Ӷ��ֽ��������ﳵ���б�����...</code><br><code>2.����ظ����������ɵ���Ҫ�������ݣ�������...</code><br><code>3.����������������������ͼ��ȫ�ַ��...</code></p>\n<h2 id=\"����vueX-���ĸ���-�s����ٷ��j��е�ͼ��\"><a href=\"#����vueX-���ĸ���-�s����ٷ��j��е�ͼ��\" class=\"headerlink\" title=\"����vueX ���ĸ��� ###�ȿ����ٷ��ĵ��е�ͼ��\"></a>����vueX ���ĸ��� ###�ȿ����ٷ��ĵ��е�ͼ��</h2><p><img src=\"/2020/01/21/VueX/vuex.png\" alt=\"����\" title=\"VueX\"><br>�� 3 ������<code>State</code>��<code>Action</code>��<code>Mutaiton</code>�ټ���<code>Getter</code>��<code>Moudule</code>�ܼ��� 5 ��,һһ����һ��</p>\n<h4 id=\"1-State\"><a href=\"#1-State\" class=\"headerlink\" title=\"1.State\"></a>1.State</h4><ul>\n<li><code>���</code>State ��Ϊ����ģʽ�����µĸ����ȫ����Ψһ�Ķ���ʽ�����ڣ���ΪΨһ������Դ����ܹ������Ҫ������״̬</li>\n<li><code>��Vuex�еĶ����ʹ�ã�</code></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const Counter &#x3D; &#123;</span><br><span class=\"line\"> template: &#96;&lt;div&gt;&#123;&#123; count &#125;&#125;&lt;&#x2F;div&gt;&#96;,</span><br><span class=\"line\"> computed: &#123;</span><br><span class=\"line\">   count () &#123;</span><br><span class=\"line\">     return this.$store.state.count</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>��������mapState��</code>һ����˵�� computed ��ʹ�ö���չ������������״̬���ɶ�Ӧ�ļ�������</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">computed: &#123;</span><br><span class=\"line\">localComputed () &#123; &#x2F;* ... *&#x2F; &#125;,</span><br><span class=\"line\">&#x2F;&#x2F; ʹ�ö���չ����������˶�����뵽�ⲿ������</span><br><span class=\"line\">...mapState(&#123;</span><br><span class=\"line\">  &#x2F;&#x2F; ...</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-Mutation\"><a href=\"#2-Mutation\" class=\"headerlink\" title=\"2.Mutation\"></a>2.Mutation</h4><ul>\n<li><code>���</code>Mutation �� Vuex ����Ψһ�ܶ� State ״̬���в��������ԣ��������Ÿ��ֶ� State ��״̬�ĸ��ֲ������� vue �е� methods �����ƣ����ԶԱ������⡣</li>\n<li><code>��Vuex�еĶ�����ʹ�ã�</code><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const store &#x3D; new Vuex.Store(&#123;</span><br><span class=\"line\">state: &#123;</span><br><span class=\"line\">count: 1</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">mutations: &#123;</span><br><span class=\"line\">increment (state) &#123;</span><br><span class=\"line\">  &#x2F;&#x2F; ���״̬</span><br><span class=\"line\">  state.count++</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<p><code>1.����</code>:�ɴ�Ҳ�ܿ������� mutation �еĸ��ַ��������¼�����(type)+�ص�����(handler)��ɣ������ڷ�����+������<br><code>2.����</code>:store.commit(Type ��)������</p>\n<ul>\n<li><code>�ύ�غ�(PayLoad)</code>:�����ǵ��� Mutation ��Ӧ����ʱ�������� Type ���ƻ������ں��洫����������������ʹ����Ҳ�������������ͣ������ں����еĲ����б�</li>\n<li><code>�������ύ</code>���� commit ʱֱ�Ӱ� Type �ͺ���д��ͬһ��������</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">store.commit(&#123;</span><br><span class=\"line\"> type: &#39;increment&#39;,</span><br><span class=\"line\"> amount: 10</span><br><span class=\"line\"> &#125;)</span><br></pre></td></tr></table></figure>\n\n<p><code>3.ͬ���ԣ�</code>�� Mutation �еĲ���������ͬ���ģ�Ϊ�˱�֤�� state ״̬��ȷ�����޸�<br><code>4.��������MapMutation:</code>һ����˵��Ӧ�� Methods ��ʹ�ö���չ������ Mutation �еĶ�Ӧ����ӳ�䵽�ֲ������</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import &#123; mapMutations &#125; from &#39;vuex&#39;</span><br><span class=\"line\"></span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\"> &#x2F;&#x2F; ...</span><br><span class=\"line\"> methods: &#123;</span><br><span class=\"line\">   ...mapMutations([</span><br><span class=\"line\">     &#39;increment&#39;, &#x2F;&#x2F; �� &#96;this.increment()&#96; ӳ��Ϊ &#96;this.$store.commit(&#39;increment&#39;)&#96;</span><br><span class=\"line\"></span><br><span class=\"line\">     &#x2F;&#x2F; &#96;mapMutations&#96; Ҳ֧���غɣ�</span><br><span class=\"line\">     &#39;incrementBy&#39; &#x2F;&#x2F; �� &#96;this.incrementBy(amount)&#96; ӳ��Ϊ &#96;this.$store.commit(&#39;incrementBy&#39;, amount)&#96;</span><br><span class=\"line\">   ]),</span><br><span class=\"line\">   ...mapMutations(&#123;</span><br><span class=\"line\">     add: &#39;increment&#39; &#x2F;&#x2F; �� &#96;this.add()&#96; ӳ��Ϊ &#96;this.$store.commit(&#39;increment&#39;)&#96;</span><br><span class=\"line\">   &#125;)</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"3-Action\"><a href=\"#3-Action\" class=\"headerlink\" title=\"3.Action\"></a>3.Action</h4><ul>\n<li><p><code>����</code>:Action �����ʺ� Mutation ����һ�������������� Action �п��԰���ͬ���첽������ͬʱ Action ������ֱ�Ӷ� State ���в�����Ҫ�ύ�ĵ� Mutation������ Mutation �еķ����� State ���в���</p>\n</li>\n<li><p><code>��VueX�еĶ�����ʹ��</code></p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">const store &#x3D; new Vuex.Store(&#123;</span><br><span class=\"line\"> state: &#123;</span><br><span class=\"line\">   count: 0</span><br><span class=\"line\"> &#125;,</span><br><span class=\"line\"> mutations: &#123;</span><br><span class=\"line\">   increment (state) &#123;</span><br><span class=\"line\">     state.count++</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"> &#125;,</span><br><span class=\"line\"> actions: &#123;</span><br><span class=\"line\">   increment (context) &#123;</span><br><span class=\"line\">     context.commit(&#39;increment&#39;)</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p><code>1.������</code>�� Mutation ��ͬ<br><code>2.����(�ַ�)��</code>context.dispatch(Type ��)<br><code>3.�ύ���أ�</code>�� Mutation ��ͬ<br><code>4.�������ύ��</code>�� Mutation ��ͬ</p>\n<ul>\n<li><code>�첽��</code>���� Action ���첽������ɺ󷵻ص���һ�� Promise ������Ҫʵ�ֶ� State �Ĳ������������м��� commit ͬ������</li>\n<li><code>��������MapAction��</code>�� Mutation ��ͬ<br>####4.Getter</li>\n<li><code>���</code>����Ҫ�� Store ������ state �Ĳ������Խ���ĳЩ����֮�����ɵ��ų����Դ���� getter ���棬������ Computed��</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   computed: &#123;</span><br><span class=\"line\">  doneTodosCount () &#123;</span><br><span class=\"line\">    return this.$store.state.todos.filter(todo &#x3D;&gt; todo.done).length</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>��Vuex�еĶ�����ʹ��</code><br><code>1.����:</code>����+�ύ����+�ص�����<br><code>2.���ã�</code><br><code>1ͨ�����Է���</code>��Getter �ᱩ¶һ�� store.getters ����ͨ���ö���.��Ӧ���Ե���ʽ����<br><code>store.getters.doneTodos</code><br><code>2.ͨ���������ʣ�</code>�� getters ����һ���������ڵ���ʱ������Ӧ����ͨ�� getters �ж�Ӧ�����Լ�ӵĶ� store �е�ĳЩ���Խ��в���</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">     getters: &#123;</span><br><span class=\"line\">  &#x2F;&#x2F; ...</span><br><span class=\"line\">  getTodoById: (state) &#x3D;&gt; (id) &#x3D;&gt; &#123;</span><br><span class=\"line\">    return state.todos.find(todo &#x3D;&gt; todo.id &#x3D;&#x3D;&#x3D; id)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>MapperGetter����������</code>�ö���չ������ computed ���Խ���ӳ�䣬��ʱ��Ҫ��������Ҫ�ö������ʽ���½���</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import &#123; mapGetters &#125; from &#39;vuex&#39;</span><br><span class=\"line\"></span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\"> &#x2F;&#x2F; ...</span><br><span class=\"line\"> computed: &#123;</span><br><span class=\"line\"> &#x2F;&#x2F; ʹ�ö���չ��������� getter ���� computed ������</span><br><span class=\"line\">   ...mapGetters([</span><br><span class=\"line\">     &#39;doneTodosCount&#39;,</span><br><span class=\"line\">     &#39;anotherGetter&#39;,</span><br><span class=\"line\">     &#x2F;&#x2F; ...</span><br><span class=\"line\">   ])</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"5-Moudule\"><a href=\"#5-Moudule\" class=\"headerlink\" title=\"5.Moudule\"></a>5.Moudule</h4><ul>\n<li><code>���</code>��Ӧ�ù��ڸ���ʱ store ��������쳣��ӷ�ף�Ϊ�˽������������Ҫʹ�õ� Vuex �е� Moudule ����(ģ��)�����ڶԸ��ӵ� store �����иʹ֮�ָ��һ��������ģ�飬ÿ��ģ��ӵ�ж����� state,Mutation,��ͬʱģ���ڲ�Ҳ�ܹ��໥Ƕ�ף������� vue �е���� components �ĸ���</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> const moduleA &#x3D; &#123;</span><br><span class=\"line\">  state: &#123; ... &#125;,</span><br><span class=\"line\">  mutations: &#123; ... &#125;,</span><br><span class=\"line\">  actions: &#123; ... &#125;,</span><br><span class=\"line\">  getters: &#123; ... &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">const moduleB &#x3D; &#123;</span><br><span class=\"line\">  state: &#123; ... &#125;,</span><br><span class=\"line\">  mutations: &#123; ... &#125;,</span><br><span class=\"line\">  actions: &#123; ... &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">const store &#x3D; new Vuex.Store(&#123;</span><br><span class=\"line\">  modules: &#123;</span><br><span class=\"line\">    a: moduleA,</span><br><span class=\"line\">    b: moduleB</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">store.state.a &#x2F;&#x2F; -&gt; moduleA ��״̬</span><br><span class=\"line\">store.state.b &#x2F;&#x2F; -&gt; moduleB ��״̬</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>Moudule�ڵľֲ�״̬��</code>�ڲ�ͬĳ���л�ȡ��Ĭ�϶���������Ҳ������ģ���ڲ��������ڲ�ͬ����� this<br><code>1.�ֲ�״̬�µ�Mutation��state:</code>ʹ�÷�ʽ��ȫ����û������<br><code>2.�ֲ�״̬�µ�action��getters��</code>�ھֲ�״̬�½��յĲ����еĵ������Ǿֲ�״̬�ĸ��ڵ�</li>\n<li><code>Module�����ռ䣺</code><br><code>���ݣ�</code>ͨ���� moudule ������ namespace:true �����ɶ�Ӧ���Ƶ�ģ�飬��ģ�鱻ע���ģ���ڵ��������ݶ������������vue ��ֳ��������� name:’xx’���ö�Ӧ��������·���ı䣩</li>\n<li><code>�������ռ��Module������ķ���</code><br><code>1.Module����ȫ������</code><br><code>1.1.</code>ʹ��ȫ�ֵ� state �� getter���ھֲ�״̬�н��յ������ĸ������ֱ����ȫ��״̬��ȫ�� getters��Ҳ��ͨ����Ӧ context �� store ���뷽��<br><code>1.2</code>ʹ��ȫ�ֵ� mutation �� action���ھֲ������н�����Ϊ�����������������Ӧ�� dispatch �� commit<br><code>1.3</code>�ֲ�ע��ȫ�� action:�� root:true ��Ϊ������� handler ��</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> modules: &#123;</span><br><span class=\"line\">  foo: &#123;</span><br><span class=\"line\">   namespaced: true,</span><br><span class=\"line\">   getters: &#123;</span><br><span class=\"line\">     &#x2F;&#x2F; �����ģ��� getter �У�&#96;getters&#96; ���ֲ�����</span><br><span class=\"line\">     &#x2F;&#x2F; �����ʹ�� getter �ĵ��ĸ����������� &#96;rootGetters&#96;</span><br><span class=\"line\">     someGetter (state, getters, rootState, rootGetters) &#123;</span><br><span class=\"line\">       getters.someOtherGetter &#x2F;&#x2F; -&gt; &#39;foo&#x2F;someOtherGetter&#39;</span><br><span class=\"line\">       rootGetters.someOtherGetter &#x2F;&#x2F; -&gt; &#39;someOtherGetter&#39;</span><br><span class=\"line\">     &#125;,</span><br><span class=\"line\">     someOtherGetter: state &#x3D;&gt; &#123; ... &#125;</span><br><span class=\"line\">   &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">   actions: &#123;</span><br><span class=\"line\">     &#x2F;&#x2F; �����ģ���У� dispatch �� commit Ҳ���ֲ�����</span><br><span class=\"line\">     &#x2F;&#x2F; ���ǿ��Խ��� &#96;root&#96; �����Է��ʸ� dispatch �� commit</span><br><span class=\"line\">     someAction (&#123; dispatch, commit, getters, rootGetters &#125;) &#123;</span><br><span class=\"line\">       getters.someGetter &#x2F;&#x2F; -&gt; &#39;foo&#x2F;someGetter&#39;</span><br><span class=\"line\">       rootGetters.someGetter &#x2F;&#x2F; -&gt; &#39;someGetter&#39;</span><br><span class=\"line\"></span><br><span class=\"line\">       dispatch(&#39;someOtherAction&#39;) &#x2F;&#x2F; -&gt; &#39;foo&#x2F;someOtherAction&#39;</span><br><span class=\"line\">       dispatch(&#39;someOtherAction&#39;, null, &#123; root: true &#125;) &#x2F;&#x2F; -&gt; &#39;someOtherAction&#39;</span><br><span class=\"line\"></span><br><span class=\"line\">       commit(&#39;someMutation&#39;) &#x2F;&#x2F; -&gt; &#39;foo&#x2F;someMutation&#39;</span><br><span class=\"line\">       commit(&#39;someMutation&#39;, null, &#123; root: true &#125;) &#x2F;&#x2F; -&gt; &#39;someMutation&#39;</span><br><span class=\"line\">     &#125;,</span><br><span class=\"line\">     someOtherAction (ctx, payload) &#123; ... &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>2.�ⲿ����Moudule�ֲ����ݣ�</code><br><code>1.ͨ�������������ʣ�</code><br><code>2.ͨ��createNamespacedHelpers���ʣ�</code>ͨ������ vue �е� createNamespacedHelpers�����ص���һ���������л�����������������ĸ����������������Ӧ�ú��ȡ�������������</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import &#123; createNamespacedHelpers &#125; from &#39;vuex&#39;</span><br><span class=\"line\"></span><br><span class=\"line\">const &#123; mapState, mapActions &#125; &#x3D; createNamespacedHelpers(&#39;some&#x2F;nested&#x2F;module&#39;)</span><br><span class=\"line\"></span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\"> computed: &#123;</span><br><span class=\"line\">   &#x2F;&#x2F; �� &#96;some&#x2F;nested&#x2F;module&#96; �в���</span><br><span class=\"line\">   ...mapState(&#123;</span><br><span class=\"line\">     a: state &#x3D;&gt; state.a,</span><br><span class=\"line\">     b: state &#x3D;&gt; state.b</span><br><span class=\"line\">   &#125;)</span><br><span class=\"line\"> &#125;,</span><br><span class=\"line\"> methods: &#123;</span><br><span class=\"line\">   &#x2F;&#x2F; �� &#96;some&#x2F;nested&#x2F;module&#96; �в���</span><br><span class=\"line\">   ...mapActions([</span><br><span class=\"line\">     &#39;foo&#39;,</span><br><span class=\"line\">     &#39;bar&#39;</span><br><span class=\"line\">   ])</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"VueX-��������\"><a href=\"#VueX-��������\" class=\"headerlink\" title=\"VueX ��������\"></a>VueX ��������</h2><h3 id=\"�ϸ�gʽ\"><a href=\"#�ϸ�gʽ\" class=\"headerlink\" title=\"�ϸ�ģʽ\"></a>�ϸ�ģʽ</h3><ul>\n<li><code>���</code>���ϸ�ģʽ�»���ȼ������״̬����������״̬�ı�Ķ������������� mutation ���ᱨ��</li>\n<li><code>���ã�</code>�� store ����ʱ����`strict��true</li>\n<li><code>ע�����</code><br><code>�ϸ�ģʽ�µı���������</code>���� input ȥ�� vuex �е�״̬ʱ���ڸı䲻���� mutation ���������Իᱨ����Ҫ������������һ����˵ �� input �� change �¼����ڶ�Ӧ������ʹ�� commit �ύ<br>���߰�һ����������ʹ�� get ������ȡ״̬ʹ�� set ��������״̬`</li>\n</ul>\n<h4 id=\"��������-VueX-��Ӧ�ĸ���󣬽�������Ӧ�u���ʵս�ˣ�������ʱ��L����Ჹ��һƪ����-VueX-��ʹ�����飬�����ڴ�\"><a href=\"#��������-VueX-��Ӧ�ĸ���󣬽�������Ӧ�u���ʵս�ˣ�������ʱ��L����Ჹ��һƪ����-VueX-��ʹ�����飬�����ڴ�\" class=\"headerlink\" title=\"�������� VueX ��Ӧ�ĸ���󣬽�������Ӧ�ü���ʵս�ˣ�������ʱ��Ļ����Ჹ��һƪ���� VueX ��ʹ�����飬�����ڴ�\"></a>�������� VueX ��Ӧ�ĸ���󣬽�������Ӧ�ü���ʵս�ˣ�������ʱ��Ļ����Ჹ��һƪ���� VueX ��ʹ�����飬�����ڴ�</h4>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"VueX-���-���۲���\"><a href=\"#VueX-���-���۲���\" class=\"headerlink\" title=\"VueX ���(���۲���)\"></a>VueX ���(���۲���)</h1><h2 id=\"һ��VueX-�ĸ���\"><a href=\"#һ��VueX-�ĸ���\" class=\"headerlink\" title=\"һ��VueX �ĸ���\"></a>һ��VueX �ĸ���</h2><h3 id=\"1-�ο��ٷ��j���-Vuex-��һ��ר��Ϊ-Vue-js-��Z�Ӧ�o���״̬����gʽ�����u��д洢����Ӧ�o����������״̬��������Ӧ�L���֤״̬��һ�ֿ�Ԥ��k�ʽ�����仯������˵��λ������¼����ؼ��㣺\"><a href=\"#1-�ο��ٷ��j���-Vuex-��һ��ר��Ϊ-Vue-js-��Z�Ӧ�o���״̬����gʽ�����u��д洢����Ӧ�o����������״̬��������Ӧ�L���֤״̬��һ�ֿ�Ԥ��k�ʽ�����仯������˵��λ������¼����ؼ��㣺\" class=\"headerlink\" title=\"1.�ο��ٷ��ĵ��� Vuex ��һ��ר��Ϊ Vue.js ��Ƶ�Ӧ�ó���״̬����ģʽ�����ü��д洢����Ӧ�õ����������״̬��������Ӧ�Ĺ���֤״̬��һ�ֿ�Ԥ��ķ�ʽ�����仯������˵��λ������¼����ؼ��㣺\"></a>1.�ο��ٷ��ĵ��� Vuex ��һ��ר��Ϊ Vue.js ��Ƶ�Ӧ�ó���״̬����ģʽ�����ü��д洢����Ӧ�õ����������״̬��������Ӧ�Ĺ���֤״̬��һ�ֿ�Ԥ��ķ�ʽ�����仯������˵��λ������¼����ؼ��㣺</h3><pre><code>1.״̬����ģʽ\n2.��Ӧ�Ĺ���Ϳ�Ԥ��ķ�ʽ</code></pre><p>����һһ������һ�£�</p>\n<h4 id=\"1-״̬����gʽ\"><a href=\"#1-״̬����gʽ\" class=\"headerlink\" title=\"1.״̬����ģʽ\"></a>1.״̬����ģʽ</h4><p>�Դ� vuex ���ṩ��һ���ٷ�������˵����</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">new Vue(&#123;</span><br><span class=\"line\"> &#x2F;&#x2F; state</span><br><span class=\"line\"> data () &#123;</span><br><span class=\"line\">   return &#123;</span><br><span class=\"line\">     count: 0</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"> &#125;,</span><br><span class=\"line\"> &#x2F;&#x2F; view</span><br><span class=\"line\"> template: &#96;</span><br><span class=\"line\">   &lt;div&gt;&#123;&#123; count &#125;&#125;&lt;&#x2F;div&gt;</span><br><span class=\"line\"> &#96;,</span><br><span class=\"line\"> &#x2F;&#x2F; actions</span><br><span class=\"line\"> methods: &#123;</span><br><span class=\"line\">   increment () &#123;</span><br><span class=\"line\">     this.count++</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<pre><code>���������ܿ�����ʵ�Ϲ���vuex�ܹ��������󲿷֣�\n1.`data���ִ������Ҳ�����������������Դ`-state\n2.`template���ִ�ŵ���html��ǩҲ������ͼ`-view\n3.`methods���ִ����صĺ���Ҳ�����������ݸı䷽ʽ`-actions</code></pre><p>������������Ϲ�ͬ������һ��״̬�Թ���Ӧ�ò��Ե����������ķ�ʽ���У����Ա�֤���ݵļ�༴��<br><img src=\"/2020/01/21/VueX/flow.png\" alt=\"����������\" title=\"����������\"></p>\n<h4 id=\"2-��Ӧ�L���Ϳ�Ԥ��k�ʽ\"><a href=\"#2-��Ӧ�L���Ϳ�Ԥ��k�ʽ\" class=\"headerlink\" title=\"2.��Ӧ�Ĺ���Ϳ�Ԥ��ķ�ʽ\"></a>2.��Ӧ�Ĺ���Ϳ�Ԥ��ķ�ʽ</h4><p>���������ϸ�������Ҳ�ܺ����⣬״̬����ģʽ�µ����ݵļ���п�����ĳЩӦ�ó����б��ƻ���<br><code>1.�����ͼ����ͬһ״̬</code><br><code>2.�����ͬ����ͼ��Ϊ����Ҫ����ͬһ״̬</code></p>\n<ul>\n<li>�������� 1.һ�㶼�Ǹ�������Ƕ�ף����� 2.һ�㶼�Ǹ��������ֵ�� bus �¼������������Ͻ���취�����ᵼ�´����߳�����ά�����в���Ҫ�������������⡣</li>\n<li>��ʱ��һ����˼·�����������⣺�����й�����״̬�������������������λ�õ���ͼ�����Ի�ȡ�͸��Ķ�Ӧ״̬��ͨ�����������״̬�����ĸ��ͨ��ǿ�ƵĹ�������֤��ͼ��״̬�Ķ����ԣ������ͱȽ������Ľ����������⣬��������һ��ȫ�ֵ�������ģʽ�������ķ�ʽҲ�� v ʱ uex �Ļ������˼·<br>���ڴ� vuex �ƶ�������ص�ǿ�Ʒ������Ա������и��Ĺ���״̬����Ϊ�������ͬʱά������</li>\n</ul>\n<h2 id=\"����VueX-��ʹ�o���\"><a href=\"#����VueX-��ʹ�o���\" class=\"headerlink\" title=\"����VueX ��ʹ�ó���\"></a>����VueX ��ʹ�ó���</h2><p>vuex ������ͳһ����״̬�ĵ������Ǹ�ʲôʱ��ʹ���أ�һ���������ձ���������˵�����д�����Ŀ�лῼ��ʹ�ã������Ҿ��Ų�̫׼ȷ�����ҵ��������Ƿ�ʹ�� vuex Ӧ���������Ŀ���Ƿ������ vuex �����������⣬������Ƴ������ʲô�����������ʲô�����Ը����Ҳ���ľ���򵥵�������һ��ʹ�ó�����<br><code>1.����ṹ���Ӷ��ֽ��������ﳵ���б�����...</code><br><code>2.����ظ����������ɵ���Ҫ�������ݣ�������...</code><br><code>3.����������������������ͼ��ȫ�ַ��...</code></p>\n<h2 id=\"����vueX-���ĸ���-�s����ٷ��j��е�ͼ��\"><a href=\"#����vueX-���ĸ���-�s����ٷ��j��е�ͼ��\" class=\"headerlink\" title=\"����vueX ���ĸ��� ###�ȿ����ٷ��ĵ��е�ͼ��\"></a>����vueX ���ĸ��� ###�ȿ����ٷ��ĵ��е�ͼ��</h2><p><img src=\"/2020/01/21/VueX/vuex.png\" alt=\"����\" title=\"VueX\"><br>�� 3 ������<code>State</code>��<code>Action</code>��<code>Mutaiton</code>�ټ���<code>Getter</code>��<code>Moudule</code>�ܼ��� 5 ��,һһ����һ��</p>\n<h4 id=\"1-State\"><a href=\"#1-State\" class=\"headerlink\" title=\"1.State\"></a>1.State</h4><ul>\n<li><code>���</code>State ��Ϊ����ģʽ�����µĸ����ȫ����Ψһ�Ķ���ʽ�����ڣ���ΪΨһ������Դ����ܹ������Ҫ������״̬</li>\n<li><code>��Vuex�еĶ����ʹ�ã�</code></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const Counter &#x3D; &#123;</span><br><span class=\"line\"> template: &#96;&lt;div&gt;&#123;&#123; count &#125;&#125;&lt;&#x2F;div&gt;&#96;,</span><br><span class=\"line\"> computed: &#123;</span><br><span class=\"line\">   count () &#123;</span><br><span class=\"line\">     return this.$store.state.count</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>��������mapState��</code>һ����˵�� computed ��ʹ�ö���չ������������״̬���ɶ�Ӧ�ļ�������</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">computed: &#123;</span><br><span class=\"line\">localComputed () &#123; &#x2F;* ... *&#x2F; &#125;,</span><br><span class=\"line\">&#x2F;&#x2F; ʹ�ö���չ����������˶�����뵽�ⲿ������</span><br><span class=\"line\">...mapState(&#123;</span><br><span class=\"line\">  &#x2F;&#x2F; ...</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-Mutation\"><a href=\"#2-Mutation\" class=\"headerlink\" title=\"2.Mutation\"></a>2.Mutation</h4><ul>\n<li><code>���</code>Mutation �� Vuex ����Ψһ�ܶ� State ״̬���в��������ԣ��������Ÿ��ֶ� State ��״̬�ĸ��ֲ������� vue �е� methods �����ƣ����ԶԱ������⡣</li>\n<li><code>��Vuex�еĶ�����ʹ�ã�</code><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const store &#x3D; new Vuex.Store(&#123;</span><br><span class=\"line\">state: &#123;</span><br><span class=\"line\">count: 1</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">mutations: &#123;</span><br><span class=\"line\">increment (state) &#123;</span><br><span class=\"line\">  &#x2F;&#x2F; ���״̬</span><br><span class=\"line\">  state.count++</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<p><code>1.����</code>:�ɴ�Ҳ�ܿ������� mutation �еĸ��ַ��������¼�����(type)+�ص�����(handler)��ɣ������ڷ�����+������<br><code>2.����</code>:store.commit(Type ��)������</p>\n<ul>\n<li><code>�ύ�غ�(PayLoad)</code>:�����ǵ��� Mutation ��Ӧ����ʱ�������� Type ���ƻ������ں��洫����������������ʹ����Ҳ�������������ͣ������ں����еĲ����б�</li>\n<li><code>�������ύ</code>���� commit ʱֱ�Ӱ� Type �ͺ���д��ͬһ��������</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">store.commit(&#123;</span><br><span class=\"line\"> type: &#39;increment&#39;,</span><br><span class=\"line\"> amount: 10</span><br><span class=\"line\"> &#125;)</span><br></pre></td></tr></table></figure>\n\n<p><code>3.ͬ���ԣ�</code>�� Mutation �еĲ���������ͬ���ģ�Ϊ�˱�֤�� state ״̬��ȷ�����޸�<br><code>4.��������MapMutation:</code>һ����˵��Ӧ�� Methods ��ʹ�ö���չ������ Mutation �еĶ�Ӧ����ӳ�䵽�ֲ������</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import &#123; mapMutations &#125; from &#39;vuex&#39;</span><br><span class=\"line\"></span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\"> &#x2F;&#x2F; ...</span><br><span class=\"line\"> methods: &#123;</span><br><span class=\"line\">   ...mapMutations([</span><br><span class=\"line\">     &#39;increment&#39;, &#x2F;&#x2F; �� &#96;this.increment()&#96; ӳ��Ϊ &#96;this.$store.commit(&#39;increment&#39;)&#96;</span><br><span class=\"line\"></span><br><span class=\"line\">     &#x2F;&#x2F; &#96;mapMutations&#96; Ҳ֧���غɣ�</span><br><span class=\"line\">     &#39;incrementBy&#39; &#x2F;&#x2F; �� &#96;this.incrementBy(amount)&#96; ӳ��Ϊ &#96;this.$store.commit(&#39;incrementBy&#39;, amount)&#96;</span><br><span class=\"line\">   ]),</span><br><span class=\"line\">   ...mapMutations(&#123;</span><br><span class=\"line\">     add: &#39;increment&#39; &#x2F;&#x2F; �� &#96;this.add()&#96; ӳ��Ϊ &#96;this.$store.commit(&#39;increment&#39;)&#96;</span><br><span class=\"line\">   &#125;)</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"3-Action\"><a href=\"#3-Action\" class=\"headerlink\" title=\"3.Action\"></a>3.Action</h4><ul>\n<li><p><code>����</code>:Action �����ʺ� Mutation ����һ�������������� Action �п��԰���ͬ���첽������ͬʱ Action ������ֱ�Ӷ� State ���в�����Ҫ�ύ�ĵ� Mutation������ Mutation �еķ����� State ���в���</p>\n</li>\n<li><p><code>��VueX�еĶ�����ʹ��</code></p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">const store &#x3D; new Vuex.Store(&#123;</span><br><span class=\"line\"> state: &#123;</span><br><span class=\"line\">   count: 0</span><br><span class=\"line\"> &#125;,</span><br><span class=\"line\"> mutations: &#123;</span><br><span class=\"line\">   increment (state) &#123;</span><br><span class=\"line\">     state.count++</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"> &#125;,</span><br><span class=\"line\"> actions: &#123;</span><br><span class=\"line\">   increment (context) &#123;</span><br><span class=\"line\">     context.commit(&#39;increment&#39;)</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p><code>1.������</code>�� Mutation ��ͬ<br><code>2.����(�ַ�)��</code>context.dispatch(Type ��)<br><code>3.�ύ���أ�</code>�� Mutation ��ͬ<br><code>4.�������ύ��</code>�� Mutation ��ͬ</p>\n<ul>\n<li><code>�첽��</code>���� Action ���첽������ɺ󷵻ص���һ�� Promise ������Ҫʵ�ֶ� State �Ĳ������������м��� commit ͬ������</li>\n<li><code>��������MapAction��</code>�� Mutation ��ͬ<br>####4.Getter</li>\n<li><code>���</code>����Ҫ�� Store ������ state �Ĳ������Խ���ĳЩ����֮�����ɵ��ų����Դ���� getter ���棬������ Computed��</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   computed: &#123;</span><br><span class=\"line\">  doneTodosCount () &#123;</span><br><span class=\"line\">    return this.$store.state.todos.filter(todo &#x3D;&gt; todo.done).length</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>��Vuex�еĶ�����ʹ��</code><br><code>1.����:</code>����+�ύ����+�ص�����<br><code>2.���ã�</code><br><code>1ͨ�����Է���</code>��Getter �ᱩ¶һ�� store.getters ����ͨ���ö���.��Ӧ���Ե���ʽ����<br><code>store.getters.doneTodos</code><br><code>2.ͨ���������ʣ�</code>�� getters ����һ���������ڵ���ʱ������Ӧ����ͨ�� getters �ж�Ӧ�����Լ�ӵĶ� store �е�ĳЩ���Խ��в���</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">     getters: &#123;</span><br><span class=\"line\">  &#x2F;&#x2F; ...</span><br><span class=\"line\">  getTodoById: (state) &#x3D;&gt; (id) &#x3D;&gt; &#123;</span><br><span class=\"line\">    return state.todos.find(todo &#x3D;&gt; todo.id &#x3D;&#x3D;&#x3D; id)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>MapperGetter����������</code>�ö���չ������ computed ���Խ���ӳ�䣬��ʱ��Ҫ��������Ҫ�ö������ʽ���½���</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import &#123; mapGetters &#125; from &#39;vuex&#39;</span><br><span class=\"line\"></span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\"> &#x2F;&#x2F; ...</span><br><span class=\"line\"> computed: &#123;</span><br><span class=\"line\"> &#x2F;&#x2F; ʹ�ö���չ��������� getter ���� computed ������</span><br><span class=\"line\">   ...mapGetters([</span><br><span class=\"line\">     &#39;doneTodosCount&#39;,</span><br><span class=\"line\">     &#39;anotherGetter&#39;,</span><br><span class=\"line\">     &#x2F;&#x2F; ...</span><br><span class=\"line\">   ])</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"5-Moudule\"><a href=\"#5-Moudule\" class=\"headerlink\" title=\"5.Moudule\"></a>5.Moudule</h4><ul>\n<li><code>���</code>��Ӧ�ù��ڸ���ʱ store ��������쳣��ӷ�ף�Ϊ�˽������������Ҫʹ�õ� Vuex �е� Moudule ����(ģ��)�����ڶԸ��ӵ� store �����иʹ֮�ָ��һ��������ģ�飬ÿ��ģ��ӵ�ж����� state,Mutation,��ͬʱģ���ڲ�Ҳ�ܹ��໥Ƕ�ף������� vue �е���� components �ĸ���</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> const moduleA &#x3D; &#123;</span><br><span class=\"line\">  state: &#123; ... &#125;,</span><br><span class=\"line\">  mutations: &#123; ... &#125;,</span><br><span class=\"line\">  actions: &#123; ... &#125;,</span><br><span class=\"line\">  getters: &#123; ... &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">const moduleB &#x3D; &#123;</span><br><span class=\"line\">  state: &#123; ... &#125;,</span><br><span class=\"line\">  mutations: &#123; ... &#125;,</span><br><span class=\"line\">  actions: &#123; ... &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">const store &#x3D; new Vuex.Store(&#123;</span><br><span class=\"line\">  modules: &#123;</span><br><span class=\"line\">    a: moduleA,</span><br><span class=\"line\">    b: moduleB</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">store.state.a &#x2F;&#x2F; -&gt; moduleA ��״̬</span><br><span class=\"line\">store.state.b &#x2F;&#x2F; -&gt; moduleB ��״̬</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>Moudule�ڵľֲ�״̬��</code>�ڲ�ͬĳ���л�ȡ��Ĭ�϶���������Ҳ������ģ���ڲ��������ڲ�ͬ����� this<br><code>1.�ֲ�״̬�µ�Mutation��state:</code>ʹ�÷�ʽ��ȫ����û������<br><code>2.�ֲ�״̬�µ�action��getters��</code>�ھֲ�״̬�½��յĲ����еĵ������Ǿֲ�״̬�ĸ��ڵ�</li>\n<li><code>Module�����ռ䣺</code><br><code>���ݣ�</code>ͨ���� moudule ������ namespace:true �����ɶ�Ӧ���Ƶ�ģ�飬��ģ�鱻ע���ģ���ڵ��������ݶ������������vue ��ֳ��������� name:’xx’���ö�Ӧ��������·���ı䣩</li>\n<li><code>�������ռ��Module������ķ���</code><br><code>1.Module����ȫ������</code><br><code>1.1.</code>ʹ��ȫ�ֵ� state �� getter���ھֲ�״̬�н��յ������ĸ������ֱ����ȫ��״̬��ȫ�� getters��Ҳ��ͨ����Ӧ context �� store ���뷽��<br><code>1.2</code>ʹ��ȫ�ֵ� mutation �� action���ھֲ������н�����Ϊ�����������������Ӧ�� dispatch �� commit<br><code>1.3</code>�ֲ�ע��ȫ�� action:�� root:true ��Ϊ������� handler ��</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> modules: &#123;</span><br><span class=\"line\">  foo: &#123;</span><br><span class=\"line\">   namespaced: true,</span><br><span class=\"line\">   getters: &#123;</span><br><span class=\"line\">     &#x2F;&#x2F; �����ģ��� getter �У�&#96;getters&#96; ���ֲ�����</span><br><span class=\"line\">     &#x2F;&#x2F; �����ʹ�� getter �ĵ��ĸ����������� &#96;rootGetters&#96;</span><br><span class=\"line\">     someGetter (state, getters, rootState, rootGetters) &#123;</span><br><span class=\"line\">       getters.someOtherGetter &#x2F;&#x2F; -&gt; &#39;foo&#x2F;someOtherGetter&#39;</span><br><span class=\"line\">       rootGetters.someOtherGetter &#x2F;&#x2F; -&gt; &#39;someOtherGetter&#39;</span><br><span class=\"line\">     &#125;,</span><br><span class=\"line\">     someOtherGetter: state &#x3D;&gt; &#123; ... &#125;</span><br><span class=\"line\">   &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">   actions: &#123;</span><br><span class=\"line\">     &#x2F;&#x2F; �����ģ���У� dispatch �� commit Ҳ���ֲ�����</span><br><span class=\"line\">     &#x2F;&#x2F; ���ǿ��Խ��� &#96;root&#96; �����Է��ʸ� dispatch �� commit</span><br><span class=\"line\">     someAction (&#123; dispatch, commit, getters, rootGetters &#125;) &#123;</span><br><span class=\"line\">       getters.someGetter &#x2F;&#x2F; -&gt; &#39;foo&#x2F;someGetter&#39;</span><br><span class=\"line\">       rootGetters.someGetter &#x2F;&#x2F; -&gt; &#39;someGetter&#39;</span><br><span class=\"line\"></span><br><span class=\"line\">       dispatch(&#39;someOtherAction&#39;) &#x2F;&#x2F; -&gt; &#39;foo&#x2F;someOtherAction&#39;</span><br><span class=\"line\">       dispatch(&#39;someOtherAction&#39;, null, &#123; root: true &#125;) &#x2F;&#x2F; -&gt; &#39;someOtherAction&#39;</span><br><span class=\"line\"></span><br><span class=\"line\">       commit(&#39;someMutation&#39;) &#x2F;&#x2F; -&gt; &#39;foo&#x2F;someMutation&#39;</span><br><span class=\"line\">       commit(&#39;someMutation&#39;, null, &#123; root: true &#125;) &#x2F;&#x2F; -&gt; &#39;someMutation&#39;</span><br><span class=\"line\">     &#125;,</span><br><span class=\"line\">     someOtherAction (ctx, payload) &#123; ... &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>2.�ⲿ����Moudule�ֲ����ݣ�</code><br><code>1.ͨ�������������ʣ�</code><br><code>2.ͨ��createNamespacedHelpers���ʣ�</code>ͨ������ vue �е� createNamespacedHelpers�����ص���һ���������л�����������������ĸ����������������Ӧ�ú��ȡ�������������</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import &#123; createNamespacedHelpers &#125; from &#39;vuex&#39;</span><br><span class=\"line\"></span><br><span class=\"line\">const &#123; mapState, mapActions &#125; &#x3D; createNamespacedHelpers(&#39;some&#x2F;nested&#x2F;module&#39;)</span><br><span class=\"line\"></span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\"> computed: &#123;</span><br><span class=\"line\">   &#x2F;&#x2F; �� &#96;some&#x2F;nested&#x2F;module&#96; �в���</span><br><span class=\"line\">   ...mapState(&#123;</span><br><span class=\"line\">     a: state &#x3D;&gt; state.a,</span><br><span class=\"line\">     b: state &#x3D;&gt; state.b</span><br><span class=\"line\">   &#125;)</span><br><span class=\"line\"> &#125;,</span><br><span class=\"line\"> methods: &#123;</span><br><span class=\"line\">   &#x2F;&#x2F; �� &#96;some&#x2F;nested&#x2F;module&#96; �в���</span><br><span class=\"line\">   ...mapActions([</span><br><span class=\"line\">     &#39;foo&#39;,</span><br><span class=\"line\">     &#39;bar&#39;</span><br><span class=\"line\">   ])</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"VueX-��������\"><a href=\"#VueX-��������\" class=\"headerlink\" title=\"VueX ��������\"></a>VueX ��������</h2><h3 id=\"�ϸ�gʽ\"><a href=\"#�ϸ�gʽ\" class=\"headerlink\" title=\"�ϸ�ģʽ\"></a>�ϸ�ģʽ</h3><ul>\n<li><code>���</code>���ϸ�ģʽ�»���ȼ������״̬����������״̬�ı�Ķ������������� mutation ���ᱨ��</li>\n<li><code>���ã�</code>�� store ����ʱ����`strict��true</li>\n<li><code>ע�����</code><br><code>�ϸ�ģʽ�µı���������</code>���� input ȥ�� vuex �е�״̬ʱ���ڸı䲻���� mutation ���������Իᱨ����Ҫ������������һ����˵ �� input �� change �¼����ڶ�Ӧ������ʹ�� commit �ύ<br>���߰�һ����������ʹ�� get ������ȡ״̬ʹ�� set ��������״̬`</li>\n</ul>\n<h4 id=\"��������-VueX-��Ӧ�ĸ���󣬽�������Ӧ�u���ʵս�ˣ�������ʱ��L����Ჹ��һƪ����-VueX-��ʹ�����飬�����ڴ�\"><a href=\"#��������-VueX-��Ӧ�ĸ���󣬽�������Ӧ�u���ʵս�ˣ�������ʱ��L����Ჹ��һƪ����-VueX-��ʹ�����飬�����ڴ�\" class=\"headerlink\" title=\"�������� VueX ��Ӧ�ĸ���󣬽�������Ӧ�ü���ʵս�ˣ�������ʱ��Ļ����Ჹ��һƪ���� VueX ��ʹ�����飬�����ڴ�\"></a>�������� VueX ��Ӧ�ĸ���󣬽�������Ӧ�ü���ʵս�ˣ�������ʱ��Ļ����Ჹ��һƪ���� VueX ��ʹ�����飬�����ڴ�</h4>"}],"PostAsset":[{"_id":"source/_posts/日系风格调色思路/日系2.jpg","slug":"日系2.jpg","post":"ck9cue22b00063gcse83h4bmk","modified":0,"renderable":0},{"_id":"source/_posts/日系风格调色思路/日系3.jpg","slug":"日系3.jpg","post":"ck9cue22b00063gcse83h4bmk","modified":0,"renderable":0},{"_id":"source/_posts/青春向左/七号公园.jpg","slug":"七号公园.jpg","post":"ck9cue22d00073gcs7moa3c9b","modified":0,"renderable":0},{"_id":"source/_posts/日系风格调色思路/原图1.jpg","slug":"原图1.jpg","post":"ck9cue22b00063gcse83h4bmk","modified":0,"renderable":0},{"_id":"source/_posts/青春向左/人生海海.jpg","slug":"人生海海.jpg","post":"ck9cue22d00073gcs7moa3c9b","modified":0,"renderable":0},{"_id":"source/_posts/日系风格调色思路/日系1.jpg","slug":"日系1.jpg","post":"ck9cue22b00063gcse83h4bmk","modified":0,"renderable":0},{"_id":"source/_posts/ES6总结一(变量与函数)/const声明.png","slug":"const声明.png","post":"ck9cue22800023gcsaab3gbnf","modified":0,"renderable":0},{"_id":"source/_posts/ES6总结一(变量与函数)/全局块级绑定1.png","slug":"全局块级绑定1.png","post":"ck9cue22800023gcsaab3gbnf","modified":0,"renderable":0},{"_id":"source/_posts/ES6总结一(变量与函数)/全局块级绑定2.png","slug":"全局块级绑定2.png","post":"ck9cue22800023gcsaab3gbnf","modified":0,"renderable":0},{"_id":"source/_posts/青春向左/演唱会.jpg","slug":"演唱会.jpg","post":"ck9cue22d00073gcs7moa3c9b","modified":0,"renderable":0},{"_id":"source/_posts/日系风格调色思路/photograph.jpg","slug":"photograph.jpg","post":"ck9cue22b00063gcse83h4bmk","modified":0,"renderable":0},{"_id":"source/_posts/日系风格调色思路/小森林·冬春.jpg","slug":"小森林·冬春.jpg","post":"ck9cue22b00063gcse83h4bmk","modified":0,"renderable":0},{"_id":"source/_posts/日系风格调色思路/小森林·夏秋.jpg","slug":"小森林·夏秋.jpg","post":"ck9cue22b00063gcse83h4bmk","modified":0,"renderable":0},{"_id":"source/_posts/日系风格调色思路/海街日记1.jpg","slug":"海街日记1.jpg","post":"ck9cue22b00063gcse83h4bmk","modified":0,"renderable":0},{"_id":"source/_posts/日系风格调色思路/海街日记2.jpg","slug":"海街日记2.jpg","post":"ck9cue22b00063gcse83h4bmk","modified":0,"renderable":0},{"_id":"source/_posts/日系风格调色思路/海街日记3.jpg","slug":"海街日记3.jpg","post":"ck9cue22b00063gcse83h4bmk","modified":0,"renderable":0},{"_id":"source/_posts/ES6语法总结三(解构、Set和Map)/数组解构赋值.png","slug":"数组解构赋值.png","post":"ck9cue22w00153gcs3j4d0tda","modified":0,"renderable":0},{"_id":"source/_posts/ES6语法总结四(迭代生成器、Promise和异步)/Promise生命周期.png","slug":"Promise生命周期.png","post":"ck9cue22x00163gcsdiqdgzax","modified":0,"renderable":0},{"_id":"source/_posts/青春向左/logo.png","slug":"logo.png","post":"ck9cue22d00073gcs7moa3c9b","modified":0,"renderable":0},{"_id":"source/_posts/青春向左/自传.png","slug":"自传.png","post":"ck9cue22d00073gcs7moa3c9b","modified":0,"renderable":0},{"_id":"source/_posts/VueX/flow.png","post":"ck9j8lyer0000n0cs3bcohpwx","slug":"flow.png","modified":1,"renderable":1},{"_id":"source/_posts/VueX/vuex.png","post":"ck9j8lyer0000n0cs3bcohpwx","slug":"vuex.png","modified":1,"renderable":1}],"PostCategory":[{"post_id":"ck9cue22100003gcs93qy5nm4","category_id":"ck9cue22a00043gcsaej4hkqq","_id":"ck9cue22j000c3gcsdt1khjek"},{"post_id":"ck9cue22800023gcsaab3gbnf","category_id":"ck9cue22a00043gcsaej4hkqq","_id":"ck9cue22k000f3gcsen88d5um"},{"post_id":"ck9cue22b00063gcse83h4bmk","category_id":"ck9cue22j000b3gcsfa7r4jw0","_id":"ck9cue22l000j3gcs4g167bdh"},{"post_id":"ck9cue22d00073gcs7moa3c9b","category_id":"ck9cue22k000h3gcsh7980s6k","_id":"ck9cue22m000o3gcs0yut843h"},{"post_id":"ck9cue22g00083gcsanjocchj","category_id":"ck9cue22k000h3gcsh7980s6k","_id":"ck9cue22n000q3gcse6m7a5y3"},{"post_id":"ck9cue22w00153gcs3j4d0tda","category_id":"ck9cue22a00043gcsaej4hkqq","_id":"ck9cue230001a3gcs1stw3mqe"},{"post_id":"ck9cue22x00163gcsdiqdgzax","category_id":"ck9cue22a00043gcsaej4hkqq","_id":"ck9cue232001d3gcscnt01gp9"},{"post_id":"ck9cue22y00183gcs16jl49dc","category_id":"ck9cue22a00043gcsaej4hkqq","_id":"ck9cue232001f3gcs19qq17gr"},{"post_id":"ck9j8lyer0000n0cs3bcohpwx","category_id":"ck9j8lyev0001n0cs5eum2tos","_id":"ck9j8lyey0004n0cs02al5pnm"}],"PostTag":[{"post_id":"ck9cue22100003gcs93qy5nm4","tag_id":"ck9cue22b00053gcs4tn10h31","_id":"ck9cue22k000e3gcs16d19471"},{"post_id":"ck9cue22100003gcs93qy5nm4","tag_id":"ck9cue22g000a3gcs8deog1i2","_id":"ck9cue22k000g3gcs0phfe05y"},{"post_id":"ck9cue22800023gcsaab3gbnf","tag_id":"ck9cue22b00053gcs4tn10h31","_id":"ck9cue22m000m3gcs93hx003y"},{"post_id":"ck9cue22800023gcsaab3gbnf","tag_id":"ck9cue22g000a3gcs8deog1i2","_id":"ck9cue22m000n3gcs5567d98f"},{"post_id":"ck9cue22b00063gcse83h4bmk","tag_id":"ck9cue22l000k3gcsfked0e5h","_id":"ck9cue22o000u3gcs9b868f1j"},{"post_id":"ck9cue22b00063gcse83h4bmk","tag_id":"ck9cue22m000p3gcs5odp5227","_id":"ck9cue22o000v3gcsbx000bja"},{"post_id":"ck9cue22b00063gcse83h4bmk","tag_id":"ck9cue22n000r3gcs8f0dbavd","_id":"ck9cue22p000x3gcsa4yw3q3z"},{"post_id":"ck9cue22b00063gcse83h4bmk","tag_id":"ck9cue22n000s3gcs4ah18tgh","_id":"ck9cue22p000y3gcsbgsj4ndx"},{"post_id":"ck9cue22d00073gcs7moa3c9b","tag_id":"ck9cue22o000t3gcs7ygkbs8m","_id":"ck9cue22q00103gcs425dau2e"},{"post_id":"ck9cue22d00073gcs7moa3c9b","tag_id":"ck9cue22p000w3gcsbz2b1v0c","_id":"ck9cue22q00113gcsf0nd3dst"},{"post_id":"ck9cue22g00083gcsanjocchj","tag_id":"ck9cue22p000z3gcs8jndaj05","_id":"ck9cue22q00133gcsab411tdb"},{"post_id":"ck9cue22g00083gcsanjocchj","tag_id":"ck9cue22q00123gcs4hx2824g","_id":"ck9cue22r00143gcs3try089m"},{"post_id":"ck9cue22w00153gcs3j4d0tda","tag_id":"ck9cue22b00053gcs4tn10h31","_id":"ck9cue22y00173gcsdqkdelxz"},{"post_id":"ck9cue22w00153gcs3j4d0tda","tag_id":"ck9cue22g000a3gcs8deog1i2","_id":"ck9cue22z00193gcs9bt5d8xs"},{"post_id":"ck9cue22x00163gcsdiqdgzax","tag_id":"ck9cue22b00053gcs4tn10h31","_id":"ck9cue232001c3gcs4e6whtgr"},{"post_id":"ck9cue22x00163gcsdiqdgzax","tag_id":"ck9cue22g000a3gcs8deog1i2","_id":"ck9cue232001e3gcs7oi838ny"},{"post_id":"ck9cue22y00183gcs16jl49dc","tag_id":"ck9cue22b00053gcs4tn10h31","_id":"ck9cue233001g3gcsfqtu732b"},{"post_id":"ck9cue22y00183gcs16jl49dc","tag_id":"ck9cue231001b3gcs7iq91i0s","_id":"ck9cue233001h3gcs2ercfs4i"},{"post_id":"ck9j8lyer0000n0cs3bcohpwx","tag_id":"ck9j8lyex0002n0cs6ji16753","_id":"ck9j8lyey0005n0csfzvz7qzl"},{"post_id":"ck9j8lyer0000n0cs3bcohpwx","tag_id":"ck9j8lyex0003n0cs6qny8oak","_id":"ck9j8lyey0006n0cs8cuod8j8"}],"Tag":[{"name":"前端","_id":"ck9cue22b00053gcs4tn10h31"},{"name":"ES6","_id":"ck9cue22g000a3gcs8deog1i2"},{"name":"后期","_id":"ck9cue22l000k3gcsfked0e5h"},{"name":"随笔","_id":"ck9cue22m000p3gcs5odp5227"},{"name":"调色","_id":"ck9cue22n000r3gcs8f0dbavd"},{"name":"摄影","_id":"ck9cue22n000s3gcs4ah18tgh"},{"name":"五月天","_id":"ck9cue22o000t3gcs7ygkbs8m"},{"name":"生活","_id":"ck9cue22p000w3gcsbz2b1v0c"},{"name":"杂谈","_id":"ck9cue22p000z3gcs8jndaj05"},{"name":"Hello Ships","_id":"ck9cue22q00123gcs4hx2824g"},{"name":"SVG","_id":"ck9cue231001b3gcs7iq91i0s"},{"name":"Vue","_id":"ck9j8lyex0002n0cs6ji16753"},{"name":"VueX","_id":"ck9j8lyex0003n0cs6qny8oak"}]}}